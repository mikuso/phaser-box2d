{
  "version": 3,
  "sources": ["../src/math_functions_c.js", "../src/include/math_functions_h.js", "../src/include/base_h.js", "../src/core_c.js", "../src/include/core_h.js", "../src/include/id_h.js", "../src/include/collision_h.js", "../src/table_c.js", "../src/include/table_h.js", "../src/stack_allocator_c.js", "../src/allocate_c.js", "../src/types_c.js", "../src/include/types_h.js", "../src/id_pool_c.js", "../src/distance_c.js", "../src/hull_c.js", "../src/geometry_c.js", "../src/shape_c.js", "../src/include/shape_h.js", "../src/bitset_c.js", "../src/include/bitset_h.js", "../src/constraint_graph_c.js", "../src/contact_solver_c.js", "../src/aabb_c.js", "../src/dynamic_tree_c.js", "../src/include/dynamic_tree_h.js", "../src/include/ctz_h.js", "../src/solver_set_c.js", "../src/solver_c.js", "../src/distance_joint_c.js", "../src/prismatic_joint_c.js", "../src/revolute_joint_c.js", "../src/wheel_joint_c.js", "../src/motor_joint_c.js", "../src/mouse_joint_c.js", "../src/weld_joint_c.js", "../src/joint_c.js", "../src/include/joint_h.js", "../src/island_c.js", "../src/body_c.js", "../src/include/body_h.js", "../src/block_array_c.js", "../src/manifold_c.js", "../src/contact_c.js", "../src/include/contact_h.js", "../src/broad_phase_c.js", "../src/world_c.js", "../src/include/world_h.js", "../src/physics.js", "../src/debug_draw.js", "../src/ragdoll.js", "../src/fun_stuff.js", "../src/main.js"],
  "sourcesContent": ["/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2IsNormalized, b2Length, b2Vec2, eps } from \"./include/math_functions_h.js\";\r\n\r\n/**\r\n * @namespace MathFunctions\r\n */\r\n\r\n/**\r\n * @import {b2Rot} from './include/math_functions_h.js'\r\n */\r\n\r\n/**\r\n * @summary Checks if a number is valid (finite and not NaN).\r\n * @function b2IsValid\r\n * @param {number} a - The number to validate.\r\n * @returns {boolean} True if the number is valid (finite and not NaN), false otherwise.\r\n * @description\r\n * This function performs a validation check on a number by ensuring it is both\r\n * finite and not NaN (Not a Number).\r\n */\r\nexport function b2IsValid(a)\r\n{\r\n    return !isNaN(a) && isFinite(a);\r\n}\r\n\r\n/**\r\n * Validates a b2Vec2 object by checking if it exists and its components are valid numbers.\r\n * @function b2Vec2_IsValid\r\n * @param {b2Vec2} v - The vector to validate, containing x and y components.\r\n * @returns {boolean} True if the vector exists and both x and y components are valid numbers.\r\n */\r\nexport function b2Vec2_IsValid(v)\r\n{\r\n    return !isNaN(v.x) && !isNaN(v.y) && isFinite(v.x) && isFinite(v.y);\r\n}\r\n\r\n/**\r\n * Validates a 2D rotation object.\r\n * @function b2Rot_IsValid\r\n * @param {b2Rot} q - A rotation object containing sine (s) and cosine (c) components\r\n * @returns {boolean} True if the rotation is valid, false otherwise\r\n * @description\r\n * Checks if a b2Rot object is valid by verifying:\r\n * 1. The object exists\r\n * 2. Both sine and cosine components contain valid numbers\r\n * 3. The rotation is properly normalized (s\u00B2 + c\u00B2 = 1)\r\n */\r\nexport function b2Rot_IsValid(q)\r\n{\r\n    if (isNaN(q.s) || isNaN(q.c) || !isFinite(q.s) || !isFinite(q.c))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return b2IsNormalized(q);\r\n}\r\n\r\n/**\r\n * @function b2Normalize\r\n * @summary Normalizes a 2D vector to unit length.\r\n * @param {b2Vec2} v - The vector to normalize.\r\n * @returns {(b2Vec2|boolean)} Returns a new normalized b2Vec2 if successful, or false if the input is null.\r\n * If the vector length is less than epsilon, returns a zero vector (0,0).\r\n * @description\r\n * Normalizes the input vector by dividing its components by its length.\r\n * If the vector's length is greater than the epsilon value, the function\r\n * returns a new vector with the same direction but unit length.\r\n */\r\nexport function b2Normalize(v)\r\n{\r\n    const length = b2Length(v);\r\n\r\n    if (length < eps)\r\n    {\r\n        return new b2Vec2( 0, 0 );\r\n    }\r\n\r\n    const invLength = 1.0 / length;\r\n\r\n    return new b2Vec2( invLength * v.x, invLength * v.y );\r\n}\r\n\r\n/**\r\n * Normalizes a 2D vector and performs length validation.\r\n * @function b2NormalizeChecked\r\n * @param {b2Vec2} v - The vector to normalize.\r\n * @returns {b2Vec2} A new normalized vector with unit length.\r\n * @throws {Error} Throws an assertion error if the vector length is less than or equal to eps.\r\n */\r\nexport function b2NormalizeChecked(v)\r\n{\r\n    const length = b2Length(v);\r\n\r\n    if (length < eps)\r\n    {\r\n        // B2_ASSERT(false);\r\n        return new b2Vec2( 0, 0 );\r\n    }\r\n\r\n    const invLength = 1.0 / length;\r\n\r\n    return new b2Vec2( invLength * v.x, invLength * v.y );\r\n}\r\n\r\n/**\r\n * Calculates the length of a vector and returns its normalized form.\r\n * @function b2GetLengthAndNormalize\r\n * @param {b2Vec2} v - The input vector to normalize\r\n * @returns {{length: number, normal: b2Vec2}} An object containing:\r\n * - length: The original length of the vector\r\n * - normal: A normalized vector (unit length) in the same direction as v.\r\n * Returns (0,0) if the input vector length is below epsilon\r\n */\r\nexport function b2GetLengthAndNormalize(v)\r\n{\r\n    const length = b2Length(v);\r\n\r\n    if (length < eps)\r\n    {\r\n        return { length: 0, normal: new b2Vec2(0, 0) };// PJB: the C version returns the vec2 here and the length via parameter float* length\r\n    }\r\n\r\n    const invLength = 1.0 / length;\r\n\r\n    return { length: length, normal: new b2Vec2( invLength * v.x, invLength * v.y ) };// PJB: the C version returns the vec2 here and the length via parameter float* length\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2GetLengthAndNormalize } from '../math_functions_c.js';\r\n\r\nexport const B2_PI = 3.14159265359;\r\nexport const eps = 1.0e-10;\r\nexport const epsSqr = eps * eps;\r\n\r\nexport const GlobalDebug = {\r\n    b2Vec2Count: 0,\r\n    b2Rot2Count: 0,\r\n    b2ManifoldCount: 0,\r\n    b2ManifoldPointCount: 0,\r\n    b2FrameCount: 0,\r\n    b2PolyCollideCount: 0,\r\n    b2ContactSimCount: 0,\r\n    b2TOIInputCount: 0,\r\n    b2ShapeCastPairInputCount: 0,\r\n    b2SweepCount: 0\r\n};\r\n\r\nexport const b2Vec2Where = {\r\n    calls: {}\r\n};\r\n\r\nexport const b2Rot2Where = {\r\n    calls: {}\r\n};\r\n\r\nexport const b2ManifoldPointWhere = {\r\n    calls: {}\r\n};\r\n\r\nexport const b2ManifoldWhere = {\r\n    calls: {}\r\n};\r\n\r\n/**\r\n * @class b2Vec2\r\n * @summary 2D vector This can be used to represent a point or free vector\r\n * @property {number} x - x coordinate\r\n * @property {number} y - y coordinate\r\n */\r\nclass b2Vec2\r\n{\r\n    constructor(x = 0, y = 0)\r\n    {\r\n        // track number created\r\n        // GlobalDebug.b2Vec2Count++;\r\n\r\n        // // track where they were created\r\n        // const lines = new Error().stack.split('\\n');\r\n        // const [, file1, line1, column1] = (lines[1] || '').match(/[@](\\S+):(\\d+):(\\d+)/) || [];\r\n        // const [, file2, line2, column2] = (lines[2] || '').match(/[@](\\S+):(\\d+):(\\d+)/) || [];\r\n        // const key = `${file1}:${line1} <- ${file2}:${line2}`;\r\n        // if (b2Vec2Where.calls[key] == undefined) b2Vec2Where.calls[key] = 0;\r\n        // b2Vec2Where.calls[key]++;\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    copy(v)\r\n    {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2Vec2(this.x, this.y);\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Rot\r\n * @summary 2D rotation. This is similar to using a complex number for rotation\r\n * @property {number} s - The sine component of the rotation\r\n * @property {number} c - The cosine component of the rotation\r\n */\r\nclass b2Rot\r\n{\r\n    constructor(c = 1, s = 0)\r\n    {\r\n        // track number created\r\n        // GlobalDebug.b2Rot2Count++;\r\n\r\n        // // track where they were created\r\n        // const lines = new Error().stack.split('\\n');\r\n        // const [, file1, line1, column1] = (lines[1] || '').match(/[@](\\S+):(\\d+):(\\d+)/) || [];\r\n        // const [, file2, line2, column2] = (lines[2] || '').match(/[@](\\S+):(\\d+):(\\d+)/) || [];\r\n        // const key = `${file1}:${line1} <- ${file2}:${line2}`;\r\n        // if (b2Rot2Where.calls[key] == undefined) b2Rot2Where.calls[key] = 0;\r\n        // b2Rot2Where.calls[key]++;\r\n\r\n        this.c = c;\r\n        this.s = s;\r\n    }\r\n\r\n    copy(r)\r\n    {\r\n        this.c = r.c;\r\n        this.s = r.s;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2Rot(this.c, this.s);\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Transform\r\n * @summary A 2D rigid transform\r\n * @property {b2Vec2} p - Position vector\r\n * @property {b2Rot} q - Rotation component\r\n */\r\nclass b2Transform\r\n{\r\n    constructor(p = null, q = null)\r\n    {\r\n        this.p = p;\r\n        this.q = q;\r\n    }\r\n\r\n    static identity()\r\n    {\r\n        return new b2Transform(new b2Vec2(), new b2Rot());\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const xf = new b2Transform(this.p, this.q);\r\n\r\n        return xf;\r\n    }\r\n\r\n    deepClone()\r\n    {\r\n        const xf = new b2Transform(this.p.clone(), this.q.clone());\r\n\r\n        return xf;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Mat22\r\n * @summary A 2-by-2 Matrix\r\n * @property {b2Vec2} cy - Matrix columns\r\n */\r\nclass b2Mat22\r\n{\r\n    constructor(cx = new b2Vec2(), cy = new b2Vec2())\r\n    {\r\n        this.cx = cx;\r\n        this.cy = cy;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2Mat22(this.cx.clone(), this.cy.clone());\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2AABB\r\n * @summary Axis-aligned bounding box\r\n * @property {b2Vec2} lowerBound - The lower vertex of the bounding box\r\n * @property {b2Vec2} upperBound - The upper vertex of the bounding box\r\n */\r\nclass b2AABB\r\n{\r\n    constructor(lowerx = 0, lowery = 0, upperx = 0, uppery = 0)\r\n    {\r\n        this.lowerBoundX = lowerx;\r\n        this.lowerBoundY = lowery;\r\n        this.upperBoundX = upperx;\r\n        this.upperBoundY = uppery;\r\n    }\r\n}\r\n\r\n// Constants\r\n// PJB replaced with 'new' in each case. TODO: use an improved const as suggested by Claude\r\n// const b2Rot_identity = new b2Rot(1, 0);\r\n// const b2Transform_identity = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n// const b2Mat22_zero = new b2Mat22(new b2Vec2(0, 0), new b2Vec2(0, 0));\r\n\r\n// Inline functions\r\n\r\n/**\r\n * @summary Returns the minimum of two numbers.\r\n * @function b2MinFloat\r\n * @param {number} a - First number to compare\r\n * @param {number} b - Second number to compare\r\n * @returns {number} The smaller of the two input numbers\r\n */\r\nfunction b2MinFloat(a, b)\r\n{\r\n    return a < b ? a : b;\r\n}\r\n\r\n/**\r\n * @summary Returns the larger of two numbers.\r\n * @function b2MaxFloat\r\n * @param {number} a - First number to compare\r\n * @param {number} b - Second number to compare\r\n * @returns {number} The maximum value between a and b\r\n */\r\nfunction b2MaxFloat(a, b)\r\n{\r\n    return a > b ? a : b;\r\n}\r\n\r\n/**\r\n * @summary Returns the absolute value of a number\r\n * @function b2AbsFloat\r\n * @param {number} a - The input number\r\n * @returns {number} The absolute value of the input\r\n * @description\r\n * An implementation of absolute value that returns the positive magnitude\r\n * of the input number.\r\n */\r\nfunction b2AbsFloat(a)\r\n{\r\n    return a < 0 ? -a : a;\r\n}\r\n\r\n/**\r\n * @summary Clamps a floating point value between a lower and upper bound.\r\n * @function b2ClampFloat\r\n * @param {number} a - The value to clamp\r\n * @param {number} lower - The lower bound\r\n * @param {number} upper - The upper bound\r\n * @returns {number} The clamped value between lower and upper bounds\r\n * @description\r\n * Returns lower if a < lower, upper if a > upper, otherwise returns a.\r\n */\r\nfunction b2ClampFloat(a, lower, upper)\r\n{\r\n    return a < lower ? lower : (a > upper ? upper : a);\r\n}\r\n\r\n/**\r\n * @summary Returns the smaller of two integers.\r\n * @function b2MinInt\r\n * @param {number} a - First integer to compare\r\n * @param {number} b - Second integer to compare\r\n * @returns {number} The smaller of the two input integers\r\n * @description\r\n * A comparison function that returns the minimum value between two integers\r\n * using a ternary operator.\r\n */\r\nfunction b2MinInt(a, b)\r\n{\r\n    return a < b ? a : b;\r\n}\r\n\r\n/**\r\n * @summary Returns the larger of two integers.\r\n * @function b2MaxInt\r\n * @param {number} a - First integer to compare\r\n * @param {number} b - Second integer to compare\r\n * @returns {number} The larger of the two input integers\r\n */\r\nfunction b2MaxInt(a, b)\r\n{\r\n    return a > b ? a : b;\r\n}\r\n\r\n/**\r\n * @summary Returns the absolute value of an integer.\r\n * @function b2AbsInt\r\n * @param {number} a - The integer input value.\r\n * @returns {number} The absolute value of the input.\r\n * @description\r\n * Computes the absolute value of an integer using conditional logic rather than Math.abs().\r\n */\r\nfunction b2AbsInt(a)\r\n{\r\n    return a < 0 ? -a : a;\r\n}\r\n\r\n/**\r\n * Clamps an integer value between a lower and upper bound.\r\n * @function b2ClampInt\r\n * @param {number} a - The integer value to clamp\r\n * @param {number} lower - The lower bound (inclusive)\r\n * @param {number} upper - The upper bound (inclusive)\r\n * @returns {number} The clamped integer value\r\n * @description\r\n * Returns lower if a < lower, upper if a > upper, otherwise returns a.\r\n */\r\nfunction b2ClampInt(a, lower, upper)\r\n{\r\n    return a < lower ? lower : (a > upper ? upper : a);\r\n}\r\n\r\n/**\r\n * @summary Calculates the dot product of two 2D vectors.\r\n * @function b2Dot\r\n * @param {b2Vec2} a - First 2D vector.\r\n * @param {b2Vec2} b - Second 2D vector.\r\n * @returns {number} The dot product of vectors a and b.\r\n * @description\r\n * Computes the dot product (scalar product) of two 2D vectors using the formula:\r\n * dot = a.x * b.x + a.y * b.y\r\n */\r\nfunction b2Dot(a, b)\r\n{\r\n    return a.x * b.x + a.y * b.y;\r\n}\r\n\r\n/**\r\n * Computes the 2D cross product of two vectors.\r\n * @function b2Cross\r\n * @param {b2Vec2} a - The first 2D vector\r\n * @param {b2Vec2} b - The second 2D vector\r\n * @returns {number} The cross product (a.x * b.y - a.y * b.x)\r\n * @description\r\n * Calculates the cross product between two 2D vectors, which represents\r\n * the signed area of the parallelogram formed by these vectors.\r\n */\r\nfunction b2Cross(a, b)\r\n{\r\n    return a.x * b.y - a.y * b.x;\r\n}\r\n\r\n/**\r\n * @summary Performs a cross product between a 2D vector and a scalar.\r\n * @function b2CrossVS\r\n * @param {b2Vec2} v - The input vector\r\n * @param {number} s - The scalar value\r\n * @returns {b2Vec2} A new vector where x = s * v.y and y = -s * v.x\r\n * @description\r\n * Computes the cross product of a vector and scalar, returning a new vector\r\n * that is perpendicular to the input vector and scaled by the scalar value.\r\n */\r\nfunction b2CrossVS(v, s)\r\n{\r\n    return new b2Vec2(s * v.y, -s * v.x);\r\n}\r\n\r\n/**\r\n * Performs a cross product between a scalar and a 2D vector.\r\n * @function b2CrossSV\r\n * @param {number} s - The scalar value\r\n * @param {b2Vec2} v - The 2D vector\r\n * @returns {b2Vec2} A new vector perpendicular to the input vector, scaled by s\r\n * @description\r\n * Computes s \u00D7 v, where \u00D7 denotes the cross product.\r\n * The result is a new vector (-s * v.y, s * v.x).\r\n */\r\nfunction b2CrossSV(s, v)\r\n{\r\n    return new b2Vec2(-s * v.y, s * v.x);\r\n}\r\n\r\n/**\r\n * @summary Returns a vector rotated 90 degrees counter-clockwise.\r\n * @function b2LeftPerp\r\n * @param {b2Vec2} v - The input vector to rotate.\r\n * @returns {b2Vec2} A new vector perpendicular to the input, rotated 90 degrees counter-clockwise.\r\n * @description\r\n * Creates a new vector that is perpendicular to the input vector by rotating it\r\n * 90 degrees counter-clockwise. The new vector is computed by setting the x component\r\n * to the negative y component of the input, and the y component to the x component\r\n * of the input.\r\n */\r\nfunction b2LeftPerp(v)\r\n{\r\n    return new b2Vec2(-v.y, v.x);\r\n}\r\n\r\n/**\r\n * @summary Returns a vector rotated 90 degrees clockwise.\r\n * @function b2RightPerp\r\n * @param {b2Vec2} v - The input vector to rotate.\r\n * @returns {b2Vec2} A new vector perpendicular to the input, rotated 90 degrees clockwise.\r\n * @description\r\n * Creates a new vector that is perpendicular (rotated 90 degrees clockwise) to the input vector.\r\n * For a vector (x,y), returns (y,-x).\r\n */\r\nfunction b2RightPerp(v)\r\n{\r\n    return new b2Vec2(v.y, -v.x);\r\n}\r\n\r\n/**\r\n * @summary Adds two 2D vectors.\r\n * @function b2Add\r\n * @param {b2Vec2} a - The first vector.\r\n * @param {b2Vec2} b - The second vector.\r\n * @returns {b2Vec2} A new vector representing the sum of the input vectors (a + b).\r\n * @description\r\n * Creates a new b2Vec2 where the x and y components are the sums of the\r\n * corresponding components of the input vectors.\r\n */\r\nfunction b2Add(a, b)\r\n{\r\n    return new b2Vec2(a.x + b.x, a.y + b.y);\r\n}\r\n\r\n/**\r\n * @summary Subtracts two 2D vectors.\r\n * @function b2Sub\r\n * @param {b2Vec2} a - The first vector.\r\n * @param {b2Vec2} b - The second vector.\r\n * @returns {b2Vec2} A new vector representing (a - b).\r\n * @description\r\n * Creates a new 2D vector by subtracting the components of vector b from vector a.\r\n * The resulting vector has coordinates (a.x - b.x, a.y - b.y).\r\n */\r\nfunction b2Sub(a, b)\r\n{\r\n    return new b2Vec2(a.x - b.x, a.y - b.y);\r\n}\r\n\r\n/**\r\n * @summary Returns the negation of a 2D vector.\r\n * @function b2Neg\r\n * @param {b2Vec2} a - The input vector to negate.\r\n * @returns {b2Vec2} A new vector with components (-a.x, -a.y).\r\n * @description\r\n * Creates a new b2Vec2 with the negated x and y components of the input vector.\r\n */\r\nfunction b2Neg(a)\r\n{\r\n    return new b2Vec2(-a.x, -a.y);\r\n}\r\n\r\n/**\r\n * @function b2Lerp\r\n * @summary Performs linear interpolation between two 2D vectors.\r\n * @param {b2Vec2} a - The starting vector\r\n * @param {b2Vec2} b - The ending vector\r\n * @param {number} t - The interpolation parameter between 0 and 1\r\n * @returns {b2Vec2} A new vector representing the interpolated point\r\n * @description\r\n * Calculates a point that lies on the straight line between vectors a and b,\r\n * where t=0 returns a, t=1 returns b, and values in between return proportionally\r\n * interpolated points.\r\n */\r\nfunction b2Lerp(a, b, t)\r\n{\r\n    return new b2Vec2((1 - t) * a.x + t * b.x, (1 - t) * a.y + t * b.y);\r\n}\r\n\r\n/**\r\n * @summary Performs component-wise multiplication of two 2D vectors.\r\n * @function b2Mul\r\n * @param {b2Vec2} a - First 2D vector with x and y components.\r\n * @param {b2Vec2} b - Second 2D vector with x and y components.\r\n * @returns {b2Vec2} A new vector where each component is the product of the corresponding components of a and b.\r\n * @description\r\n * Multiplies the x components of both vectors together and the y components of both vectors together,\r\n * returning a new b2Vec2 with these products as its components.\r\n */\r\nfunction b2Mul(a, b)\r\n{\r\n    return new b2Vec2(a.x * b.x, a.y * b.y);\r\n}\r\n\r\n/**\r\n * @summary Multiplies a scalar value with a 2D vector.\r\n * @function b2MulSV\r\n * @param {number} s - The scalar value to multiply with the vector.\r\n * @param {b2Vec2} v - The 2D vector to be multiplied.\r\n * @returns {b2Vec2} A new b2Vec2 representing the scaled vector (s * v).\r\n * @description\r\n * Performs scalar multiplication on a 2D vector, where each component\r\n * of the vector is multiplied by the scalar value.\r\n */\r\nfunction b2MulSV(s, v)\r\n{\r\n    return new b2Vec2(s * v.x, s * v.y);\r\n}\r\n\r\n/**\r\n * @function b2MulAdd\r\n * @summary Performs vector addition with scalar multiplication (a + s * b).\r\n * @param {b2Vec2} a - First vector operand\r\n * @param {number} s - Scalar multiplier\r\n * @param {b2Vec2} b - Second vector operand\r\n * @returns {b2Vec2} A new vector representing the result of a + s * b\r\n */\r\nfunction b2MulAdd(a, s, b)\r\n{\r\n    return new b2Vec2(a.x + s * b.x, a.y + s * b.y);\r\n}\r\n\r\nfunction b2MulAddOut(a, s, b, out)\r\n{\r\n    out.x = a.x + s * b.x;\r\n    out.y = a.y + s * b.y;\r\n}\r\n\r\n/**\r\n * @function b2MulSub\r\n * @summary Performs vector subtraction with scalar multiplication: a - s * b\r\n * @param {b2Vec2} a - The first vector operand\r\n * @param {number} s - The scalar multiplier\r\n * @param {b2Vec2} b - The second vector operand\r\n * @returns {b2Vec2} A new vector representing the result of a - s * b\r\n */\r\nfunction b2MulSub(a, s, b)\r\n{\r\n    return new b2Vec2(a.x - s * b.x, a.y - s * b.y);\r\n}\r\n\r\nfunction b2DotSub(sub1, sub2, dot)\r\n{\r\n    const subX = sub1.x - sub2.x;\r\n    const subY = sub1.y - sub2.y;\r\n\r\n    return subX * dot.x + subY * dot.y;\r\n}\r\n\r\n/**\r\n * Returns a new b2Vec2 with the absolute values of the input vector's components.\r\n * @function b2Abs\r\n * @param {b2Vec2} a - The input vector whose components will be converted to absolute values.\r\n * @returns {b2Vec2} A new vector containing the absolute values of the input vector's x and y components.\r\n */\r\nfunction b2Abs(a)\r\n{\r\n    return new b2Vec2(Math.abs(a.x), Math.abs(a.y));\r\n}\r\n\r\n/**\r\n * @function b2Min\r\n * @summary Returns a new vector containing the minimum x and y components from two vectors.\r\n * @param {b2Vec2} a - First 2D vector\r\n * @param {b2Vec2} b - Second 2D vector\r\n * @returns {b2Vec2} A new vector with x = min(a.x, b.x) and y = min(a.y, b.y)\r\n */\r\nfunction b2Min(a, b)\r\n{\r\n    return new b2Vec2(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n}\r\n\r\n/**\r\n * @function b2Max\r\n * @summary Returns a new vector containing the component-wise maximum values from two vectors.\r\n * @param {b2Vec2} a - First input vector\r\n * @param {b2Vec2} b - Second input vector\r\n * @returns {b2Vec2} A new vector where each component is the maximum of the corresponding components from vectors a and b\r\n * @description\r\n * Creates a new b2Vec2 where:\r\n * - x component is the maximum of a.x and b.x\r\n * - y component is the maximum of a.y and b.y\r\n */\r\nfunction b2Max(a, b)\r\n{\r\n    return new b2Vec2(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n}\r\n\r\n/**\r\n * @function b2Clamp\r\n * @summary Clamps a 2D vector's components between minimum and maximum bounds.\r\n * @param {b2Vec2} v - The vector to clamp\r\n * @param {b2Vec2} a - The minimum bounds vector\r\n * @param {b2Vec2} b - The maximum bounds vector\r\n * @returns {b2Vec2} A new vector with components clamped between a and b\r\n * @description\r\n * Creates a new 2D vector where each component (x,y) is clamped between\r\n * the corresponding components of vectors a and b. Uses b2ClampFloat\r\n * internally to clamp individual components.\r\n */\r\nfunction b2Clamp(v, a, b)\r\n{\r\n    return new b2Vec2(\r\n        b2ClampFloat(v.x, a.x, b.x),\r\n        b2ClampFloat(v.y, a.y, b.y)\r\n    );\r\n}\r\n\r\n/**\r\n * @summary Calculates the length (magnitude) of a 2D vector.\r\n * @function b2Length\r\n * @param {b2Vec2} v - A 2D vector with x and y components.\r\n * @returns {number} The scalar length of the vector.\r\n * @description\r\n * Computes the Euclidean length of a 2D vector using the formula sqrt(x\u00B2 + y\u00B2).\r\n */\r\nfunction b2Length(v)\r\n{\r\n    return Math.sqrt(v.x * v.x + v.y * v.y);\r\n}\r\n\r\nfunction b2LengthXY(x, y)\r\n{\r\n    return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * @summary Calculates the squared length (magnitude) of a 2D vector.\r\n * @function b2LengthSquared\r\n * @param {b2Vec2} v - A 2D vector with x and y components.\r\n * @returns {number} The squared length of the vector (x\u00B2 + y\u00B2).\r\n * @description\r\n * Computes the dot product of a vector with itself, which gives the squared\r\n * length of the vector without performing a square root operation.\r\n */\r\nfunction b2LengthSquared(v)\r\n{\r\n    return v.x * v.x + v.y * v.y;\r\n}\r\n\r\n/**\r\n * @function b2Distance\r\n * @summary Calculates the Euclidean distance between two 2D points.\r\n * @param {b2Vec2} a - The first 2D vector point\r\n * @param {b2Vec2} b - The second 2D vector point\r\n * @returns {number} The distance between points a and b\r\n * @description\r\n * Computes the straight-line distance between two points using the Pythagorean theorem.\r\n */\r\nfunction b2Distance(a, b)\r\n{\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\n/**\r\n * @function b2DistanceSquared\r\n * @summary Calculates the squared distance between two 2D points.\r\n * @param {b2Vec2 | {x: number, y: number}} a - The first 2D vector point\r\n * @param {b2Vec2 | {x: number, y: number}} b - The second 2D vector point\r\n * @returns {number} The squared distance between points a and b\r\n * @description\r\n * Computes the squared Euclidean distance between two points without taking the square root.\r\n * The calculation is (b.x - a.x)\u00B2 + (b.y - a.y)\u00B2\r\n */\r\nfunction b2DistanceSquared(a, b)\r\n{\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Creates a new b2Rot object representing a 2D rotation.\r\n * @function b2MakeRot\r\n * @param {number} angle - The rotation angle in radians\r\n * @returns {b2Rot} A new b2Rot object containing the cosine and sine of the input angle\r\n * @description\r\n * Constructs a b2Rot object by computing the cosine and sine of the provided angle.\r\n * The resulting b2Rot contains these values as its 'c' and 's' components respectively.\r\n */\r\nfunction b2MakeRot(angle)\r\n{\r\n    return new b2Rot(Math.cos(angle), Math.sin(angle));\r\n}\r\n\r\n/**\r\n * Normalizes a rotation by scaling its components to create a unit vector.\r\n * @function b2NormalizeRot\r\n * @param {b2Rot} q - A rotation object containing cosine (c) and sine (s) components\r\n * @returns {b2Rot} A new normalized b2Rot object where the components form a unit vector\r\n * @description\r\n * Computes the magnitude of the rotation vector and divides both components by it\r\n * to create a normalized rotation. If the magnitude is 0, returns a default rotation.\r\n */\r\nfunction b2NormalizeRot(q)\r\n{\r\n    const mag = Math.sqrt(q.s * q.s + q.c * q.c);\r\n    const invMag = mag > 0 ? 1 / mag : 0;\r\n\r\n    return new b2Rot(q.c * invMag, q.s * invMag);\r\n}\r\n\r\nfunction b2InvMagRot(c, s)\r\n{\r\n    const mag = Math.sqrt(s * s + c * c);\r\n    const invMag = mag > 0 ? 1 / mag : 0;\r\n\r\n    return invMag;\r\n}\r\n\r\n/**\r\n * @function b2IsNormalized\r\n * @summary Checks if a rotation is properly normalized.\r\n * @param {b2Rot} q - A rotation object containing sine (s) and cosine (c) components\r\n * @returns {boolean} True if the rotation is normalized within a tolerance of 6e-4\r\n * @description\r\n * Verifies that the sum of squares of the sine and cosine components\r\n * equals 1 within a tolerance of \u00B16e-4, which indicates a valid rotation.\r\n */\r\nfunction b2IsNormalized(q)\r\n{\r\n    const qq = q.s * q.s + q.c * q.c;\r\n\r\n    return 1 - 0.0006 < qq && qq < 1 + 0.0006;\r\n}\r\n\r\n/**\r\n * @function b2NLerp\r\n * @summary Performs normalized linear interpolation between two rotations.\r\n * @param {b2Rot} q1 - The first rotation\r\n * @param {b2Rot} q2 - The second rotation\r\n * @param {number} t - Interpolation factor between 0 and 1\r\n * @returns {b2Rot} The normalized interpolated rotation\r\n * @description\r\n * Linearly interpolates between two rotations and normalizes the result.\r\n * When t=0 returns q12, when t=1 returns q22.\r\n */\r\nfunction b2NLerp(q1, q2, t)\r\n{\r\n    const omt = 1 - t;\r\n    const q = new b2Rot(\r\n        omt * q1.c + t * q2.c,\r\n        omt * q1.s + t * q2.s\r\n    );\r\n\r\n    return b2NormalizeRot(q);\r\n}\r\n\r\n/**\r\n * @function b2IntegrateRotation\r\n * @summary Integrates a rotation by a specified angle while maintaining normalization.\r\n * @param {b2Rot} q1 - The initial rotation.\r\n * @param {number} deltaAngle - The angle to rotate by, in radians.\r\n * @returns {b2Rot} A new normalized rotation after applying the integration.\r\n * @description\r\n * Performs rotation integration while ensuring the resulting rotation remains\r\n * normalized through magnitude scaling. The function handles the case where\r\n * magnitude could be zero by returning a default rotation.\r\n */\r\nfunction b2IntegrateRotation(q1, deltaAngle)\r\n{\r\n    const q2C =  q1.c - deltaAngle * q1.s;\r\n    const q2S =  q1.s + deltaAngle * q1.c;\r\n    const mag = Math.sqrt(q2S * q2S + q2C * q2C);\r\n    const invMag = mag > 0 ? 1 / mag : 0;\r\n\r\n    return new b2Rot(q2C * invMag, q2S * invMag);\r\n}\r\n\r\nfunction b2IntegrateRotationOut(q1, deltaAngle, out)\r\n{\r\n    const q2C =  q1.c - deltaAngle * q1.s;\r\n    const q2S =  q1.s + deltaAngle * q1.c;\r\n    const mag = Math.sqrt(q2S * q2S + q2C * q2C);\r\n    const invMag = mag > 0 ? 1 / mag : 0;\r\n    out.c = q2C * invMag;\r\n    out.s = q2S * invMag;\r\n}\r\n\r\n/**\r\n * @function b2ComputeAngularVelocity\r\n * @summary Computes the angular velocity between two rotations given a time step.\r\n * @param {b2Rot} q1 - The first rotation\r\n * @param {b2Rot} q2 - The second rotation\r\n * @param {number} inv_h - The inverse of the time step (1/dt)\r\n * @returns {number} The computed angular velocity in radians per second\r\n * @description\r\n * Calculates the angular velocity by comparing two rotations and dividing by the time step.\r\n * Uses the formula (\u03B82 - \u03B81)/dt where \u03B8 is extracted from the rotations using their sine\r\n * and cosine components.\r\n */\r\nfunction b2ComputeAngularVelocity(q1, q2, inv_h)\r\n{\r\n    return inv_h * (q2.s * q1.c - q2.c * q1.s);\r\n}\r\n\r\n/**\r\n * @function b2Rot_GetAngle\r\n * @summary Gets the angle of a rotation object in radians.\r\n * @param {b2Rot} q - A rotation object containing cosine (c) and sine (s) components.\r\n * @returns {number} The angle in radians, calculated using arctangent of s/c.\r\n * @description\r\n * Calculates the angle of a rotation by computing the arctangent of the sine\r\n * component divided by the cosine component using Math.atan2.\r\n */\r\nfunction b2Rot_GetAngle(q)\r\n{\r\n    return Math.atan2(q.s, q.c);\r\n}\r\n\r\n/**\r\n * Returns the x-axis vector from a rotation matrix.\r\n * @function b2Rot_GetXAxis\r\n * @param {b2Rot} q - A rotation matrix containing cosine (c) and sine (s) components\r\n * @returns {b2Vec2} A 2D vector representing the x-axis direction (c, s)\r\n * @description\r\n * Extracts the x-axis direction vector from a rotation matrix by returning\r\n * a vector containing the cosine component in x and sine component in y.\r\n */\r\nfunction b2Rot_GetXAxis(q)\r\n{\r\n    return new b2Vec2(q.c, q.s);\r\n}\r\n\r\n/**\r\n * Returns the Y axis vector from a rotation matrix.\r\n * @function b2Rot_GetYAxis\r\n * @param {b2Rot} q - A rotation matrix containing cosine (c) and sine (s) components\r\n * @returns {b2Vec2} A 2D vector (-sin, cos) representing the Y axis of the rotation\r\n * @description\r\n * Extracts the Y axis vector from a rotation matrix by returning the vector (-sin, cos).\r\n * This represents the vertical basis vector of the rotated coordinate system.\r\n */\r\nfunction b2Rot_GetYAxis(q)\r\n{\r\n    return new b2Vec2(-q.s, q.c);\r\n}\r\n\r\n/**\r\n * @function b2MulRot\r\n * @summary Multiplies two rotations together.\r\n * @param {b2Rot} q - First rotation\r\n * @param {b2Rot} r - Second rotation\r\n * @returns {b2Rot} A new rotation representing the product of the two input rotations\r\n * @description\r\n * Performs rotation multiplication by combining the cosine and sine components\r\n * of two b2Rot objects using the formula:\r\n * result.c = q4.c * r.c - q4.s * r.s\r\n * result.s = q4.s * r.c + q4.c * r.s\r\n */\r\nfunction b2MulRot(q, r)\r\n{\r\n    return new b2Rot(\r\n        q.c * r.c - q.s * r.s,\r\n        q.s * r.c + q.c * r.s\r\n    );\r\n}\r\n\r\nfunction b2MulRotC(q, r)\r\n{\r\n    return q.c * r.c - q.s * r.s;\r\n}\r\n\r\nfunction b2MulRotS(q, r)\r\n{\r\n    return q.s * r.c + q.c * r.s;\r\n}\r\n\r\n/**\r\n * @function b2InvMulRot\r\n * @summary Multiplies the inverse of the first rotation with the second rotation.\r\n * @param {b2Rot} q - The first rotation to be inverted\r\n * @param {b2Rot} r - The second rotation to be multiplied\r\n * @returns {b2Rot} A new rotation representing q^-1 * r\r\n * @description\r\n * Computes the product of the inverse of rotation q with rotation r.\r\n * For rotations, the inverse multiplication is equivalent to using the transpose\r\n * of the rotation matrix.\r\n */\r\nfunction b2InvMulRot(q, r)\r\n{\r\n    return new b2Rot(\r\n        q.c * r.c + q.s * r.s,\r\n        q.c * r.s - q.s * r.c\r\n    );\r\n}\r\n\r\n/**\r\n * @function b2RelativeAngle\r\n * @summary Calculates the relative angle between two rotations.\r\n * @param {b2Rot} b - The first rotation\r\n * @param {b2Rot} a - The second rotation\r\n * @returns {number} The relative angle in radians between the two rotations\r\n * @description\r\n * Computes the angle between two rotations by using their sine and cosine components.\r\n * The result is the angle needed to rotate from rotation 'a' to rotation 'b'.\r\n */\r\nfunction b2RelativeAngle(b, a)\r\n{\r\n    const s = b.s * a.c - b.c * a.s;\r\n    const c = b.c * a.c + b.s * a.s;\r\n\r\n    return Math.atan2(s, c);\r\n}\r\n\r\n/**\r\n * @function b2UnwindAngle\r\n * @summary Normalizes an angle to be within the range [-\u03C0, \u03C0].\r\n * @param {number} angle - The input angle in radians to normalize.\r\n * @returns {number} The normalized angle in radians within the range [-\u03C0, \u03C0].\r\n * @description\r\n * This function takes an angle in radians and ensures it falls within the range [-\u03C0, \u03C0]\r\n * by adding or subtracting 2\u03C0 as needed. If the input angle is already within\r\n * the valid range, it is returned unchanged.\r\n */\r\nfunction b2UnwindAngle(angle)\r\n{\r\n    if (angle < -B2_PI)\r\n    {\r\n        return angle + 2 * B2_PI;\r\n    }\r\n    else if (angle > B2_PI)\r\n    {\r\n        return angle - 2 * B2_PI;\r\n    }\r\n\r\n    return angle;\r\n}\r\n\r\n/**\r\n * @function b2RotateVector\r\n * @summary Rotates a 2D vector by a given rotation\r\n * @param {b2Rot} q - A rotation object containing cosine (c) and sine (s) components\r\n * @param {b2Vec2} v - The vector to rotate\r\n * @returns {b2Vec2} A new vector representing the rotated result\r\n * @description\r\n * Applies a 2D rotation to a vector using the formula:\r\n * x' = c*x - s*y\r\n * y' = s*x + c*y\r\n * where (x,y) is the input vector and (c,s) represents the rotation\r\n */\r\nfunction b2RotateVector(q, v)\r\n{\r\n    return new b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);\r\n}\r\n\r\n/**\r\n * @function b2InvRotateVector\r\n * @summary Performs an inverse rotation of a vector using a rotation matrix\r\n * @param {b2Rot} q - A rotation matrix containing cosine (c) and sine (s) components\r\n * @param {b2Vec2} v - The vector to be inversely rotated\r\n * @returns {b2Vec2} A new vector representing the inverse rotation of v by q4\r\n * @description\r\n * Applies the inverse of the rotation defined by q4 to vector v.\r\n * The operation is equivalent to multiplying the vector by the transpose\r\n * of the rotation matrix represented by q4.\r\n */\r\nfunction b2InvRotateVector(q, v)\r\n{\r\n    return new b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);\r\n}\r\n\r\n/**\r\n * @function b2TransformPoint\r\n * @summary Transforms a point using a rigid body transform.\r\n * @param {b2Transform} t - A transform containing position (p) and rotation (q) components\r\n * @param {b2Vec2} p - The point to transform\r\n * @returns {b2Vec2} The transformed point\r\n * @description\r\n * Applies a rigid body transformation to a 2D point. The transformation consists of\r\n * a rotation followed by a translation. The rotation is applied using the rotation\r\n * matrix stored in t.q (cosine and sine components), and the translation is applied\r\n * using the position vector stored in t.p.\r\n */\r\nfunction b2TransformPoint(t, p)\r\n{\r\n    const x = (t.q.c * p.x - t.q.s * p.y) + t.p.x;\r\n    const y = (t.q.s * p.x + t.q.c * p.y) + t.p.y;\r\n\r\n    return new b2Vec2(x, y);\r\n}\r\n\r\nfunction b2TransformPointOut(t, p, out)\r\n{\r\n    const x = (t.q.c * p.x - t.q.s * p.y) + t.p.x;\r\n    const y = (t.q.s * p.x + t.q.c * p.y) + t.p.y;\r\n\r\n    // safe: i.e. out = t.p\r\n    out.x = x;\r\n    out.y = y;\r\n}\r\n\r\nfunction b2TransformPointOutXf(t, p, out)\r\n{\r\n    out.p.x = (t.q.c * p.x - t.q.s * p.y) + t.p.x;\r\n    out.p.y = (t.q.s * p.x + t.q.c * p.y) + t.p.y;\r\n    out.q.c = t.q.c;\r\n    out.q.s = t.q.s;\r\n}\r\n\r\n/**\r\n * Applies an inverse transform to a point.\r\n * @function b2InvTransformPoint\r\n * @param {b2Transform} t - A transform containing position (p) and rotation (q) components\r\n * @param {b2Vec2} p - The point to transform\r\n * @returns {b2Vec2} The inverse transformed point\r\n * @description\r\n * Computes the inverse transform of a point by first translating relative to the transform's\r\n * position, then applying the inverse rotation. The rotation inverse is computed using\r\n * the transpose of the rotation matrix.\r\n */\r\nfunction b2InvTransformPoint(t, p)\r\n{\r\n    const vx = p.x - t.p.x;\r\n    const vy = p.y - t.p.y;\r\n\r\n    return new b2Vec2(t.q.c * vx + t.q.s * vy, -t.q.s * vx + t.q.c * vy);\r\n}\r\n\r\n/**\r\n * @function b2MulTransforms\r\n * @summary Multiplies two transforms together to create a new transform.\r\n * @param {b2Transform} A - The first transform\r\n * @param {b2Transform} B - The second transform\r\n * @returns {b2Transform} A new transform C that represents the multiplication of A and B\r\n * @description\r\n * Combines two transforms by first multiplying their rotations (q components),\r\n * then rotating B's position vector by A's rotation and adding it to A's position.\r\n * The result represents the combined transformation of first applying B, then A.\r\n */\r\nfunction b2MulTransforms(A, B)\r\n{\r\n    const C = new b2Transform();\r\n    C.q = b2MulRot(A.q, B.q);\r\n    C.p = b2Add(b2RotateVector(A.q, B.p), A.p);\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * @function b2InvMulTransforms\r\n * @summary Computes the inverse multiplication of two transforms.\r\n * @param {b2Transform} A - The first transform\r\n * @param {b2Transform} B - The second transform\r\n * @returns {b2Transform} A new transform representing the inverse multiplication of A and B\r\n * @description\r\n * Calculates A^-1 * B, where A^-1 is the inverse of transform A.\r\n * The result combines both the rotational and translational components\r\n * of the transforms using their quaternion and position vectors.\r\n */\r\nfunction b2InvMulTransforms(A, B)\r\n{\r\n    const C = new b2Transform(new b2Vec2(), new b2Rot());\r\n\r\n    // C.q = b2InvMulRot(A.q, B.q);\r\n    // q.c * r.c + q.s * r.s, q.c * r.s - q.s * r.c\r\n    C.q.c = A.q.c * B.q.c + A.q.s * B.q.s;\r\n    C.q.s = A.q.c * B.q.s - A.q.s * B.q.c;\r\n\r\n    // C.p = b2InvRotateVector(A.q, b2Sub(B.p, A.p));\r\n    // q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y\r\n    const subX = B.p.x - A.p.x;\r\n    const subY = B.p.y - A.p.y;\r\n    C.p.x = A.q.c * subX + A.q.s * subY;\r\n    C.p.y = -A.q.s * subX + A.q.c * subY;\r\n\r\n    return C;\r\n}\r\n\r\nfunction b2InvMulTransformsOut(A, B, out)\r\n{\r\n    const C = out;\r\n\r\n    // C.q = b2InvMulRot(A.q, B.q);\r\n    // q.c * r.c + q.s * r.s, q.c * r.s - q.s * r.c\r\n    C.q.c = A.q.c * B.q.c + A.q.s * B.q.s;\r\n    C.q.s = A.q.c * B.q.s - A.q.s * B.q.c;\r\n\r\n    // C.p = b2InvRotateVector(A.q, b2Sub(B.p, A.p));\r\n    // q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y\r\n    const subX = B.p.x - A.p.x;\r\n    const subY = B.p.y - A.p.y;\r\n    C.p.x = A.q.c * subX + A.q.s * subY;\r\n    C.p.y = -A.q.s * subX + A.q.c * subY;\r\n}\r\n\r\n/**\r\n * @function b2MulMV\r\n * @summary Multiplies a 2x2 matrix by a 2D vector.\r\n * @param {b2Mat22} A - A 2x2 matrix with components cx and cy, each containing x and y values\r\n * @param {b2Vec2} v - A 2D vector with x and y components\r\n * @returns {b2Vec2} The resulting 2D vector from the matrix-vector multiplication\r\n * @description\r\n * Performs matrix-vector multiplication of the form Av, where A is a 2x2 matrix\r\n * and v is a 2D vector. The result is a new 2D vector.\r\n */\r\nfunction b2MulMV(A, v)\r\n{\r\n    return new b2Vec2(\r\n        A.cx.x * v.x + A.cy.x * v.y,\r\n        A.cx.y * v.x + A.cy.y * v.y\r\n    );\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a 2x2 matrix.\r\n * @function b2GetInverse22\r\n * @param {b2Mat22} A - The input 2x2 matrix to invert\r\n * @returns {b2Mat22} The inverse of matrix A. If the determinant is 0, returns a matrix with undefined values\r\n * @description\r\n * Computes the inverse of a 2x2 matrix using the formula:\r\n * For matrix [[a,b],[c,d]], inverse = (1/det) * [[d,-c],[-b,a]]\r\n * where det = ad-bc\r\n */\r\nfunction b2GetInverse22(A)\r\n{\r\n    const a = A.cx.x,\r\n        b = A.cy.x,\r\n        c = A.cx.y,\r\n        d = A.cy.y;\r\n    let det = a * d - b * c;\r\n\r\n    if (det !== 0)\r\n    {\r\n        det = 1 / det;\r\n    }\r\n\r\n    return new b2Mat22(\r\n        new b2Vec2(det * d, -det * c),\r\n        new b2Vec2(-det * b, det * a)\r\n    );\r\n}\r\n\r\n/**\r\n * @function b2Solve22\r\n * @summary Solves a 2x2 linear system of equations Ax = b using Cramer's rule.\r\n * @param {b2Mat22} A - A 2x2 matrix represented as two column vectors (cx, cy)\r\n * @param {b2Vec2} b - A 2D vector representing the right-hand side of the equation\r\n * @returns {b2Vec2} The solution vector x that satisfies Ax = b. Returns a zero vector if the system is singular (det = 0)\r\n * @description\r\n * Solves the system using the formula:\r\n * x = (1/det) * [a22 -a12] * [b.x]\r\n * [-a21  a11]   [b.y]\r\n * where det = a11*a22 - a12*a21\r\n */\r\nfunction b2Solve22(A, b)\r\n{\r\n    const a11 = A.cx.x,\r\n        a12 = A.cy.x,\r\n        a21 = A.cx.y,\r\n        a22 = A.cy.y;\r\n    let det = a11 * a22 - a12 * a21;\r\n\r\n    if (det !== 0)\r\n    {\r\n        det = 1 / det;\r\n    }\r\n\r\n    return new b2Vec2(\r\n        det * (a22 * b.x - a12 * b.y),\r\n        det * (a11 * b.y - a21 * b.x)\r\n    );\r\n}\r\n\r\n/**\r\n * @function b2AABB_Contains\r\n * @summary Determines if one Axis-Aligned Bounding Box (AABB) completely contains another.\r\n * @param {b2AABB} a - The containing AABB\r\n * @param {b2AABB} b - The AABB to test for containment\r\n * @returns {boolean} True if AABB 'a' completely contains AABB 'b', false otherwise\r\n * @description\r\n * Tests if AABB 'b' is completely contained within AABB 'a' by comparing their bounds.\r\n * An AABB contains another if its lower bounds are less than or equal to the other's lower bounds\r\n * and its upper bounds are greater than or equal to the other's upper bounds.\r\n */\r\nfunction b2AABB_Contains(a, b)\r\n{\r\n    return (\r\n        a.lowerBoundX <= b.lowerBoundX &&\r\n        a.lowerBoundY <= b.lowerBoundY &&\r\n        b.upperBoundX <= a.upperBoundX &&\r\n        b.upperBoundY <= a.upperBoundY\r\n    );\r\n}\r\n\r\n/**\r\n * @function b2AABB_Center\r\n * @summary Calculates the center point of an Axis-Aligned Bounding Box (AABB).\r\n * @param {b2AABB} a - The AABB object containing lowerBound and upperBound coordinates.\r\n * @returns {b2Vec2} A 2D vector representing the center point of the AABB.\r\n * @description\r\n * Computes the center point of an AABB by averaging its lower and upper bounds\r\n * in both X and Y dimensions.\r\n */\r\nfunction b2AABB_Center(a)\r\n{\r\n    return new b2Vec2(\r\n        0.5 * (a.lowerBoundX + a.upperBoundX),\r\n        0.5 * (a.lowerBoundY + a.upperBoundY)\r\n    );\r\n}\r\n\r\n/**\r\n * @summary Calculates the half-widths (extents) of an Axis-Aligned Bounding Box (AABB)\r\n * @function b2AABB_Extents\r\n * @param {b2AABB} a - The AABB to calculate extents for\r\n * @returns {b2Vec2} A vector containing the half-width and half-height of the AABB\r\n * @description\r\n * Computes the extents of an AABB by calculating half the difference between\r\n * its upper and lower bounds in both x and y dimensions.\r\n */\r\nfunction b2AABB_Extents(a)\r\n{\r\n    return new b2Vec2(\r\n        0.5 * (a.upperBoundX - a.lowerBoundX),\r\n        0.5 * (a.upperBoundY - a.lowerBoundY)\r\n    );\r\n}\r\n\r\n/**\r\n * @function b2AABB_Union\r\n * @summary Creates a new AABB that contains both input AABBs.\r\n * @param {b2AABB} a - The first axis-aligned bounding box\r\n * @param {b2AABB} b - The second axis-aligned bounding box\r\n * @returns {b2AABB} A new AABB that encompasses both input boxes\r\n * @description\r\n * Computes the union of two axis-aligned bounding boxes by creating a new AABB\r\n * with a lower bound at the minimum coordinates and an upper bound at the\r\n * maximum coordinates of both input boxes.\r\n */\r\nfunction b2AABB_Union(a, b)\r\n{\r\n    const c = new b2AABB();\r\n    c.lowerBoundX = Math.min(a.lowerBoundX, b.lowerBoundX);\r\n    c.lowerBoundY = Math.min(a.lowerBoundY, b.lowerBoundY);\r\n    c.upperBoundX = Math.max(a.upperBoundX, b.upperBoundX);\r\n    c.upperBoundY = Math.max(a.upperBoundY, b.upperBoundY);\r\n\r\n    return c;\r\n}\r\n\r\n/**\r\n * @summary Checks if a number is valid (finite and not NaN).\r\n * @function b2IsValid\r\n * @param {number} a - The number to validate.\r\n * @returns {boolean} True if the number is valid (finite and not NaN), false otherwise.\r\n * @description\r\n * This function performs a validation check on a number by ensuring it is both\r\n * finite and not NaN (Not a Number).\r\n */\r\nfunction b2IsValid(a)\r\n{\r\n    return isFinite(a) && !isNaN(a);\r\n}\r\n\r\n/**\r\n * Validates a b2Vec2 object by checking if it exists and its components are valid numbers.\r\n * @function b2Vec2_IsValid\r\n * @param {b2Vec2} v - The vector to validate, containing x and y components.\r\n * @returns {boolean} True if the vector exists and both x and y components are valid numbers.\r\n */\r\nfunction b2Vec2_IsValid(v)\r\n{\r\n    return v && b2IsValid(v.x) && b2IsValid(v.y);\r\n}\r\n\r\n/**\r\n * Validates a 2D rotation object.\r\n * @function b2Rot_IsValid\r\n * @param {b2Rot} q - A rotation object containing sine (s) and cosine (c) components\r\n * @returns {boolean} True if the rotation is valid, false otherwise\r\n * @description\r\n * Checks if a b2Rot object is valid by verifying:\r\n * 1. The object exists\r\n * 2. Both sine and cosine components contain valid numbers\r\n * 3. The rotation is properly normalized (s\u00B2 + c\u00B2 = 1)\r\n */\r\nfunction b2Rot_IsValid(q)\r\n{\r\n    return q && b2IsValid(q.s) && b2IsValid(q.c) && b2IsNormalized(q);\r\n}\r\n\r\n/**\r\n * Validates an Axis-Aligned Bounding Box (AABB)\r\n * @function b2AABB_IsValid\r\n * @param {b2AABB} aabb - The AABB to validate\r\n * @returns {boolean} True if the AABB exists and has valid dimensions and coordinates\r\n * @description\r\n * Checks if an AABB is valid by verifying:\r\n * 1. The AABB object exists\r\n * 2. The width (upperBoundX - lowerBoundX) is non-negative\r\n * 3. The height (upperBoundY - lowerBoundY) is non-negative\r\n * 4. All coordinate values are valid numbers\r\n */\r\nfunction b2AABB_IsValid(aabb)\r\n{\r\n    if (!aabb) { return false; }\r\n    const dx = aabb.upperBoundX - aabb.lowerBoundX;\r\n    const dy = aabb.upperBoundY - aabb.lowerBoundY;\r\n    const valid = dx >= 0 && dy >= 0;\r\n\r\n    return valid &&\r\n        b2IsValid(aabb.lowerBoundX) && b2IsValid(aabb.lowerBoundY) &&\r\n        b2IsValid(aabb.upperBoundX) && b2IsValid(aabb.upperBoundY);\r\n}\r\n\r\n/**\r\n * @function b2Normalize\r\n * @summary Normalizes a 2D vector to unit length.\r\n * @param {b2Vec2} v - The vector to normalize.\r\n * @returns {b2Vec2} Returns a new normalized b2Vec2 if successful.\r\n * If the vector length is less than epsilon, returns a zero vector (0,0).\r\n * @description\r\n * Normalizes the input vector by dividing its components by its length.\r\n * If the vector's length is greater than the epsilon value, the function\r\n * returns a new vector with the same direction but unit length.\r\n */\r\nfunction b2Normalize(v)\r\n{\r\n    if (!v) { console.assert(false); }  // why would this ever happen? make sure it doesn't...\r\n    const length = b2Length(v);\r\n\r\n    if (length > eps)\r\n    {\r\n        const invLength = 1 / length;\r\n\r\n        return new b2Vec2(v.x * invLength, v.y * invLength);\r\n    }\r\n\r\n    return new b2Vec2(0, 0);\r\n}\r\n\r\nfunction b2NormalizeXY(x, y)\r\n{\r\n    const length = Math.sqrt(x * x + y * y);\r\n\r\n    if (length > eps)\r\n    {\r\n        const invLength = 1 / length;\r\n\r\n        return new b2Vec2(x * invLength, y * invLength);\r\n    }\r\n\r\n    return new b2Vec2(0, 0);\r\n}\r\n\r\n/**\r\n * Normalizes a 2D vector and performs length validation.\r\n * @function b2NormalizeChecked\r\n * @param {b2Vec2} v - The vector to normalize.\r\n * @returns {b2Vec2} A new normalized vector with unit length.\r\n * @throws {Error} Throws an assertion error if the vector length is less than or equal to eps.\r\n */\r\nfunction b2NormalizeChecked(v)\r\n{\r\n    const length = b2Length(v);\r\n    console.assert(length > eps);\r\n    const invLength = 1 / length;\r\n\r\n    return new b2Vec2(v.x * invLength, v.y * invLength);\r\n}\r\n\r\nexport {\r\n    b2Vec2, b2Rot, b2Transform, b2Mat22, b2AABB,\r\n    b2MinFloat, b2MaxFloat, b2AbsFloat, b2ClampFloat,\r\n    b2MinInt, b2MaxInt, b2AbsInt, b2ClampInt,\r\n    b2Dot, b2Cross, b2CrossVS, b2CrossSV,\r\n    b2LeftPerp, b2RightPerp, b2Add, b2Sub,\r\n    b2Neg, b2Lerp, b2Mul, b2MulSV,\r\n    b2MulAdd, b2MulSub, b2Abs, b2Min,\r\n    b2Max, b2Clamp, b2Length, b2LengthXY, b2LengthSquared,\r\n    b2Distance, b2DistanceSquared, b2MakeRot,\r\n    b2NormalizeRot, b2InvMagRot,\r\n    b2IsNormalized, b2NLerp,\r\n    b2IntegrateRotation, b2IntegrateRotationOut,\r\n    b2ComputeAngularVelocity,\r\n    b2Rot_GetAngle, b2Rot_GetXAxis, b2Rot_GetYAxis,\r\n    b2MulRot, b2InvMulRot, b2MulRotC, b2MulRotS,\r\n    b2RelativeAngle, b2UnwindAngle,\r\n    b2RotateVector, b2InvRotateVector,\r\n    b2TransformPoint, b2TransformPointOut, b2TransformPointOutXf, b2InvTransformPoint,\r\n    b2MulTransforms,\r\n    b2InvMulTransforms, b2InvMulTransformsOut,\r\n    b2MulMV, b2GetInverse22, b2Solve22,\r\n    b2AABB_Contains, b2AABB_Center, b2AABB_Extents, b2AABB_Union,\r\n    b2IsValid, b2Vec2_IsValid, b2Rot_IsValid, b2AABB_IsValid,\r\n    b2Normalize, b2NormalizeXY, b2NormalizeChecked, b2GetLengthAndNormalize,\r\n    b2DotSub, b2MulAddOut\r\n};\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n/**\r\n * @class b2Version\r\n * @summary Version numbering scheme. See https://semver.org/\r\n * @property {number} major - Significant changes\r\n * @property {number} minor - Incremental changes\r\n * @property {number} revision - Bug fixes\r\n */\r\nexport class b2Version\r\n{\r\n    constructor(major = 0, minor = 0, revision = 0)\r\n    {\r\n        // / Significant changes\r\n        this.major = major;\r\n\r\n        // / Incremental changes\r\n        this.minor = minor;\r\n\r\n        // / Bug fixes\r\n        this.revision = revision;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Version } from './include/base_h.js';\r\n\r\n/**\r\n * @namespace Core\r\n */\r\n\r\nlet b2_lengthUnitsPerMeter = 1.0;\r\nconst B2_NULL_INDEX = -1;\r\n\r\nexport { B2_NULL_INDEX };\r\n\r\n/**\r\n * @summary Sets the length units per meter for Box2D physics calculations.\r\n * @function b2SetLengthUnitsPerMeter\r\n * @param {number} lengthUnits - The number of length units that represent one meter.\r\n * @returns {void}\r\n * @description\r\n * Sets the global scaling factor that defines how many length units in the physics\r\n * simulation correspond to one meter in the real world. This affects all subsequent\r\n * physics calculations in the Box2D engine.\r\n */\r\nexport function b2SetLengthUnitsPerMeter(lengthUnits)\r\n{\r\n    // B2_ASSERT(b2IsValid(lengthUnits) && lengthUnits > 0.0);\r\n    b2_lengthUnitsPerMeter = lengthUnits;\r\n}\r\n\r\n/**\r\n * @function b2GetLengthUnitsPerMeter\r\n * @summary Returns the global length units per meter scaling factor.\r\n * @returns {number} The number of length units per meter used in the physics simulation.\r\n * @description\r\n * Returns the value of b2_lengthUnitsPerMeter, which defines the conversion factor\r\n * between physics simulation units and real-world meters.\r\n */\r\nexport function b2GetLengthUnitsPerMeter()\r\n{\r\n    return b2_lengthUnitsPerMeter;\r\n}\r\n\r\n/**\r\n * Sets the assertion function handler for Box2D.\r\n * @function b2SetAssertFcn\r\n * @param {Function|null} assertFcn - The assertion function to handle Box2D assertions.\r\n * If null, assertions will be disabled.\r\n * @returns {void}\r\n * @description\r\n * This function sets the global assertion handler used by Box2D for runtime checks.\r\n * The assertion handler is called when a Box2D assertion fails.\r\n */\r\nexport function b2SetAssertFcn(assertFcn)\r\n{\r\n    console.warn(\"b2SetAssertFcn not supported\");\r\n}\r\n\r\n/**\r\n * @summary Returns the current version of Box2D\r\n * @function b2GetVersion\r\n * @returns {b2Version} A b2Version object containing major version 3, minor version 0, and revision 0\r\n * @description\r\n * This function creates and returns a new b2Version object initialized with Box2D version 3.0.0\r\n */\r\nexport function b2GetVersion()\r\n{\r\n    return new b2Version(3, 1, 0);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nexport { B2_NULL_INDEX, b2GetVersion, b2SetAssertFcn, b2SetLengthUnitsPerMeter, b2GetLengthUnitsPerMeter } from '../core_c.js';\r\n\r\nexport const b2_lengthUnitsPerMeter = 1.0;\r\n\r\n// Used to detect bad values. Positions greater than about 16km will have precision\r\n// problems, so 100km as a limit should be fine in all cases.\r\nexport const B2_HUGE= 100000.0 * b2_lengthUnitsPerMeter;\r\n\r\n// Maximum number of colors in the constraint graph. Constraints that cannot\r\n// find a color are added to the overflow set which are solved single-threaded.\r\nexport const b2_graphColorCount = 2;\r\n\r\n// A small length used as a collision and constraint tolerance. Usually it is\r\n// chosen to be numerically significant, but visually insignificant. In meters.\r\n// @warning modifying this can have a significant impact on stability\r\nexport const b2_linearSlop = 0.005 * b2_lengthUnitsPerMeter;\r\n\r\n// Maximum number of simultaneous worlds that can be allocated\r\nexport const B2_MAX_WORLDS = 16;\r\n\r\n// The maximum rotation of a body per time step. This limit is very large and is used\r\n// to prevent numerical problems. You shouldn't need to adjust this.\r\n// @warning increasing this to 0.5 * Math.PI or greater will break continuous collision.\r\nexport const B2_MAX_ROTATION = 0.25 * Math.PI;\r\n\r\n// @warning modifying this can have a significant impact on performance and stability\r\nexport const b2_speculativeDistance = 4.0 * b2_linearSlop;\r\n\r\n// This is used to fatten AABBs in the dynamic tree. This allows proxies\r\n// to move by a small amount without triggering a tree adjustment.\r\n// This is in meters.\r\n// @warning modifying this can have a significant impact on performance\r\nexport const b2_aabbMargin = 0.1 * b2_lengthUnitsPerMeter;\r\n\r\n// The time that a body must be still before it will go to sleep. In seconds.\r\nexport const b2_timeToSleep = 0.5;\r\n\r\n// Returns the number of elements of an array\r\nexport function B2_ARRAY_COUNT(A)\r\n{\r\n    return A.length;\r\n}\r\n\r\n//\r\n// Unsupported API features\r\n//\r\n\r\n/**\r\n * @summary Sets custom memory allocator functions for Box2D (Not supported in Phaser Box2D JS)\r\n * @function b2SetAllocator\r\n * @returns {void}\r\n * @description\r\n * This function is intended to set custom memory allocation and deallocation functions\r\n * for Box2D. However, in the Phaser Box2D JS implementation, this functionality\r\n * is not supported and will only generate a warning message.\r\n * @throws {Warning} Outputs a console warning indicating lack of support\r\n */\r\nexport function b2SetAllocator()\r\n{\r\n    console.warn(\"b2SetAllocator not supported\");\r\n}\r\n\r\n/**\r\n * @summary Returns the byte count for Box2D memory usage.\r\n * @function b2GetByteCount\r\n * @returns {void}\r\n * @description\r\n * This function is a stub that warns users that byte count tracking is not\r\n * supported in the JavaScript implementation of Box2D for Phaser.\r\n */\r\nexport function b2GetByteCount()\r\n{\r\n    console.warn(\"b2GetByteCount not supported\");\r\n}\r\n\r\n/**\r\n * @summary Creates a timer object for performance measurement.\r\n * @function b2CreateTimer\r\n * @returns {void} A timer object for measuring elapsed time.\r\n * @description\r\n * This function creates a timer object but is not supported in the Phaser Box2D JS implementation.\r\n * When called, it issues a console warning about lack of support.\r\n */\r\nexport function b2CreateTimer()\r\n{\r\n    console.warn(\"b2CreateTimer not supported\");\r\n}\r\n\r\n/**\r\n * @summary Gets system ticks for timing purposes\r\n * @function b2GetTicks\r\n * @returns {void} Returns 0 since this function not supported\r\n * @description\r\n * This is a stub function that exists for compatibility with Box2D but is not\r\n * implemented in the Phaser Box2D JS port. It logs a warning when called.\r\n * @throws {Warning} Logs a console warning that the function is not supported\r\n */\r\nexport function b2GetTicks()\r\n{\r\n    console.warn(\"b2GetTicks not supported\");\r\n}\r\n\r\n/**\r\n * @summary Gets the elapsed time in milliseconds.\r\n * @function b2GetMilliseconds\r\n * @returns {void} The elapsed time in milliseconds.\r\n * @description\r\n * This function is a stub that warns that millisecond timing is not supported\r\n * in the Phaser Box2D JS implementation.\r\n * @throws {Warning} Console warning indicating lack of support.\r\n */\r\nexport function b2GetMilliseconds()\r\n{\r\n    console.warn(\"b2GetMilliseconds not supported\");\r\n}\r\n\r\n/**\r\n * @summary Gets elapsed milliseconds from a b2Timer and resets it.\r\n * @function b2GetMillisecondsAndReset\r\n * @returns {void} The elapsed time in milliseconds\r\n * @description\r\n * This function returns the elapsed milliseconds from a Box2D timer object and resets it.\r\n * In the JavaScript implementation for Phaser Box2D, this functionality is not supported\r\n * and will trigger a warning.\r\n * @throws {Warning} Logs a console warning that this function is not supported\r\n */\r\nexport function b2GetMillisecondsAndReset()\r\n{\r\n    console.warn(\"b2GetMillisecondsAndReset not supported\");\r\n}\r\n\r\n/**\r\n * @summary Placeholder function for sleep functionality in Box2D JS\r\n * @function b2SleepMilliseconds\r\n * @param {number} ms - The number of milliseconds to sleep\r\n * @returns {void}\r\n * @description\r\n * This function is a stub that issues a warning message when called, as the sleep\r\n * functionality is not supported in the Phaser Box2D JS implementation.\r\n */\r\nexport function b2SleepMilliseconds(ms)\r\n{\r\n    console.warn(\"b2SleepMilliseconds not supported\");\r\n}\r\n\r\n/**\r\n * @summary Placeholder function for b2Yield functionality\r\n * @function b2Yield\r\n * @returns {void}\r\n * @description\r\n * This function serves as a placeholder for Box2D's b2Yield functionality, which is not supported\r\n * in the Phaser Box2D JS implementation. When called, it emits a warning to the console.\r\n */\r\nexport function b2Yield()\r\n{\r\n    console.warn(\"b2Yield not supported\");\r\n}\r\n\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n/**\r\n * @defgroup id Ids\r\n * These ids serve as handles to internal Box2D objects.\r\n * These should be considered opaque data and passed by value.\r\n * Include this header if you need the id types and not the whole Box2D API.\r\n * All ids are considered null if initialized to zero.\r\n *\r\n * For example in JavaScript:\r\n *\r\n * @code{.js}\r\n * let worldId = {};\r\n * @endcode\r\n *\r\n * This is considered null.\r\n *\r\n * @warning Do not use the internals of these ids. They are subject to change. Ids should be treated as opaque objects.\r\n * @warning You should use ids to access objects in Box2D. Do not access files within the src folder. Such usage is unsupported.\r\n */\r\n\r\n/**\r\n * @class b2WorldId\r\n * @summary World id references a world instance. This should be treated as an opaque handle.\r\n * @property {number} index1 - Index value stored as unsigned 16-bit integer\r\n * @property {number} revision - Revision value stored as unsigned 16-bit integer\r\n */\r\nexport class b2WorldId\r\n{\r\n    constructor(index = 0, revision = 0)\r\n    {\r\n        this.index1 = index;\r\n        this.revision = revision;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2BodyId\r\n * @summary Body id references a body instance. This should be treated as an opaque handle.\r\n * @property {number} index1 - Integer index value\r\n * @property {number} world0 - 16-bit world identifier\r\n * @property {number} revision - 16-bit revision number\r\n */\r\nexport class b2BodyId\r\n{\r\n    constructor(index = 0, world = 0, revision = 0)\r\n    {\r\n        this.index1 = index;\r\n        this.world0 = world;\r\n        this.revision = revision;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ShapeId\r\n * @summary Shape id references a shape instance. This should be treated as an opaque handle.\r\n * @property {number} index1 - Integer index value\r\n * @property {number} world0 - 16-bit unsigned integer value\r\n * @property {number} revision - 16-bit unsigned integer value\r\n */\r\nexport class b2ShapeId\r\n{\r\n    constructor(index = 0, world = 0, revision = 0)\r\n    {\r\n        this.index1 = index;\r\n        this.world0 = world;\r\n        this.revision = revision;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2JointId\r\n * @summary Joint id references a joint instance. This should be treated as an opaque handle.\r\n * @property {number} index1 - Integer index value\r\n * @property {number} world0 - 16-bit world identifier\r\n * @property {number} revision - 16-bit revision number\r\n */\r\nexport class b2JointId\r\n{\r\n    constructor(index = 0, world = 0, revision = 0)\r\n    {\r\n        this.index1 = index;\r\n        this.world0 = world;\r\n        this.revision = revision;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ChainId\r\n * @summary Chain id references a chain instances. This should be treated as an opaque handle.\r\n * @property {number} index1 - Integer index value\r\n * @property {number} world0 - 16-bit unsigned integer value\r\n * @property {number} revision - 16-bit unsigned integer value\r\n */\r\nexport class b2ChainId\r\n{\r\n    constructor(index = 0, world = 0, revision = 0)\r\n    {\r\n        this.index1 = index;\r\n        this.world0 = world;\r\n        this.revision = revision;\r\n    }\r\n}\r\n\r\n// Use these to make your identifiers null.\r\n// You may also use zero initialization to get null.\r\n// JS conversion NOTE: replace with new call in-situ, make sure c'tor sets all to 0\r\n// export const b2_nullWorldId = B2_ZERO_INIT;  // b2WorldId\r\n// export const b2_nullBodyId = B2_ZERO_INIT;   // b2BodyId\r\n// export const b2_nullShapeId = B2_ZERO_INIT;  // b2ShapeId\r\n// export const b2_nullJointId = B2_ZERO_INIT;  // b2JointId\r\n// export const b2_nullChainId = B2_ZERO_INIT;  // b2ChainId\r\n\r\n/**\r\n * @summary Checks if a contact ID is null/invalid\r\n * @function B2_IS_NULL\r\n * @param {Object} id - A contact ID object containing index1 property\r\n * @returns {boolean} Returns true if the contact ID is null (index1 === 0), false otherwise\r\n * @description\r\n * Tests if a contact ID represents a null/invalid contact by checking if its index1\r\n * property equals 0. In Box2D, an index1 value of 0 indicates a null contact ID.\r\n */\r\nexport function B2_IS_NULL(id)\r\n{\r\n    return id.index1 === 0;\r\n}\r\n\r\n/**\r\n * @summary Checks if a contact ID is non-null.\r\n * @function B2_IS_NON_NULL\r\n * @param {Object} id - A contact ID object containing an index1 property.\r\n * @returns {boolean} Returns true if the contact ID is non-null (index1 !== 0), false otherwise.\r\n * @description\r\n * Tests whether a contact ID represents a valid contact by checking if its index1\r\n * property is not equal to 0. A zero value for index1 indicates a null contact ID.\r\n */\r\nexport function B2_IS_NON_NULL(id)\r\n{\r\n    return id.index1 !== 0;\r\n}\r\n\r\n/**\r\n * @summary Compares two ID objects for equality.\r\n * @function B2_ID_EQUALS\r\n * @param {Object} id1 - First ID object containing index1, world0, and revision properties.\r\n * @param {Object} id2 - Second ID object containing index1, world0, and revision properties.\r\n * @returns {boolean} True if all corresponding properties between id1 and id2 are equal, false otherwise.\r\n * @description\r\n * Performs a strict equality comparison between corresponding properties of two ID objects.\r\n * Checks equality of index1, world0, and revision properties.\r\n */\r\nexport function B2_ID_EQUALS(id1, id2)\r\n{\r\n    return id1.index1 === id2.index1 && id1.world0 === id2.world0 && id1.revision === id2.revision;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Rot, b2Transform, b2Vec2 } from './math_functions_h.js';\r\n\r\nimport { B2_NULL_INDEX } from '../core_c.js';\r\n\r\n// Constants\r\nexport const B2_MAX_POLYGON_VERTICES = 8;\r\nexport const B2_DEFAULT_CATEGORY_BITS = 0x00000001;\r\nexport const B2_DEFAULT_MASK_BITS = 0xFFFFFFFF;\r\n\r\n// Classes\r\n\r\n/**\r\n * @class b2RayCastInput\r\n * @summary Low level ray cast input data\r\n * @property {b2Vec2} origin - Start point of the ray cast\r\n * @property {b2Vec2} translation - Translation of the ray cast\r\n * @property {number} maxFraction - The maximum fraction of the translation to consider, typically 1\r\n */\r\nexport class b2RayCastInput\r\n{\r\n    constructor()\r\n    {\r\n        this.origin = null;   // new b2Vec2(0,0);\r\n        this.translation = null;   // new b2Vec2(0,0);\r\n        this.maxFraction = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ShapeCastInput\r\n * @summary Low level shape cast input in generic form. This allows casting an arbitrary point cloud wrap with a radius. For example, a circle is a single point with a non-zero radius. A capsule is two points with a non-zero radius. A box is four points with a zero radius.\r\n * @property {b2Vec2[]} points - A point cloud to cast\r\n * @property {number} count - The number of points\r\n * @property {number} radius - The radius around the point cloud\r\n * @property {b2Vec2} translation - The translation of the shape cast\r\n * @property {number} maxFraction - The maximum fraction of the translation to consider, typically 1\r\n */\r\nexport class b2ShapeCastInput\r\n{\r\n    constructor()\r\n    {\r\n        this.points = [];   // Array(B2_MAX_POLYGON_VERTICES).fill().map(() => new b2Vec2(0, 0));\r\n        this.count = 0;\r\n        this.radius = 0;\r\n        this.translation = null;   // new b2Vec2(0,0);\r\n        this.maxFraction = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2CastOutput\r\n * @summary Low level ray cast or shape-cast output data\r\n * @property {b2Vec2} normal - The surface normal at the hit point\r\n * @property {b2Vec2} point - The surface hit point\r\n * @property {number} fraction - The fraction of the input translation at collision\r\n * @property {number} iterations - The number of iterations used\r\n * @property {boolean} hit - Did the cast hit?\r\n */\r\nexport class b2CastOutput\r\n{\r\n    constructor(normal = null, point = null)\r\n    {\r\n        this.normal = normal;   // new b2Vec2(0,0);\r\n        this.point = point;   // new b2Vec2(0,0);\r\n        this.fraction = 0;\r\n        this.iterations = 0;\r\n        this.hit = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2MassData\r\n * @summary This holds the mass data computed for a shape.\r\n * @property {number} mass - The mass of the shape, usually in kilograms.\r\n * @property {b2Vec2} center - The position of the shape's centroid relative to the shape's origin.\r\n * @property {number} rotationalInertia - The rotational inertia of the shape about the local origin.\r\n */\r\nexport class b2MassData\r\n{\r\n    constructor()\r\n    {\r\n        this.mass = 0;\r\n        this.center = null;   // new b2Vec2(0,0);\r\n        this.rotationalInertia = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Circle\r\n * @summary A solid circle\r\n * @property {b2Vec2} center - The local center\r\n * @property {number} radius - The radius\r\n */\r\nexport class b2Circle\r\n{\r\n    constructor(center = null, radius = 0)\r\n    {\r\n        this.center = center;\r\n\r\n        if (!this.center)\r\n        {\r\n            this.center = new b2Vec2(0,0);\r\n        }\r\n\r\n        this.radius = radius;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Capsule\r\n * @summary A solid capsule can be viewed as two semicircles connected by a rectangle.\r\n * @property {b2Vec2} center1 - Local center of the first semicircle\r\n * @property {b2Vec2} center2 - Local center of the second semicircle\r\n * @property {number} radius - The radius of the semicircles\r\n */\r\nexport class b2Capsule\r\n{\r\n    constructor()\r\n    {\r\n        this.center1 = null;\r\n        this.center2 = null;\r\n        this.radius = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Polygon\r\n * @summary A solid convex polygon. It is assumed that the interior of the polygon is to the left of each edge. Polygons have a maximum number of vertices equal to B2_MAX_POLYGON_VERTICES. In most cases you should not need many vertices for a convex polygon.\r\n * @warning DO NOT fill this out manually, instead use a helper function like b2MakePolygon or b2MakeBox.\r\n * @property {b2Vec2[]} vertices - The polygon vertices\r\n * @property {b2Vec2[]} normals - The outward normal vectors of the polygon sides\r\n * @property {b2Vec2} centroid - The centroid of the polygon\r\n * @property {number} radius - The external radius for rounded polygons\r\n * @property {number} count - The number of polygon vertices\r\n */\r\nexport class b2Polygon\r\n{\r\n    constructor(vertices)\r\n    {\r\n        if (vertices > 0)\r\n        {\r\n            this.vertices = new Array(vertices).fill().map(() => new b2Vec2(0,0));\r\n            this.normals = new Array(vertices).fill().map(() => new b2Vec2(0,0));\r\n        }\r\n        else\r\n        {\r\n            this.vertices = [];\r\n            this.normals = [];\r\n        }\r\n\r\n        this.centroid = null;\r\n        this.radius = 0;\r\n        this.count = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Segment\r\n * @summary A line segment with two-sided collision\r\n * @property {b2Vec2} point1 - The first point\r\n * @property {b2Vec2} point2 - The second point\r\n */\r\nexport class b2Segment\r\n{\r\n    constructor(point1 = null, point2 = null)\r\n    {\r\n        this.point1 = point1;\r\n        this.point2 = point2;\r\n    }\r\n}\r\n\r\nexport class b2ChainSegment\r\n{\r\n    constructor()\r\n    {\r\n        this.ghost1 = null; // new b2Vec2(0,0);\r\n        this.segment = null;    // new b2Segment();\r\n        this.ghost2 = null; // new b2Vec2(0,0);\r\n        this.chainId = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Hull\r\n * @summary A convex hull. Used to create convex polygons.\r\n * @warning Do not modify these values directly, instead use b2ComputeHull()\r\n * @property {b2Vec2[]} points - The final points of the hull\r\n * @property {number} count - The number of points\r\n */\r\nexport class b2Hull\r\n{\r\n    constructor()\r\n    {\r\n        this.points = [];   // new Array(B2_MAX_POLYGON_VERTICES).fill().map(() => new b2Vec2(0,0));\r\n        this.count = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2SegmentDistanceResult\r\n * @summary Result of computing the distance between two line segments\r\n * @property {b2Vec2} closest1 - The closest point on the first segment\r\n * @property {b2Vec2} closest2 - The closest point on the second segment\r\n * @property {number} fraction1 - The barycentric coordinate on the first segment\r\n * @property {number} fraction2 - The barycentric coordinate on the second segment\r\n * @property {number} distanceSquared - The squared distance between the closest points\r\n */\r\nexport class b2SegmentDistanceResult\r\n{\r\n    constructor()\r\n    {\r\n        this.closest1 = null;   // new b2Vec2(0,0);\r\n        this.closest2 = null;   // new b2Vec2(0,0);\r\n        this.fraction1 = 0;\r\n        this.fraction2 = 0;\r\n        this.distanceSquared = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2DistanceProxy\r\n * @summary A distance proxy used by the GJK algorithm. It encapsulates any shape.\r\n * @property {b2Vec2[]} points - The point cloud\r\n * @property {number} count - The number of points\r\n * @property {number} radius - The external radius of the point cloud\r\n */\r\nexport class b2DistanceProxy\r\n{\r\n    constructor(points = [], count = null, radius = 0)\r\n    {\r\n        this.points = points;\r\n        this.count = count;\r\n        this.radius = radius;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const points = [];\r\n\r\n        for (let i = 0, l = this.points.length; i < l; i++)\r\n        {\r\n            points.push(this.points[i]);\r\n        }\r\n\r\n        return new b2DistanceProxy(points, this.count, this.radius);\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2DistanceCache\r\n * @summary Used to warm start b2Distance. Set count to zero on first call or use zero initialization.\r\n * @property {number} count - The number of stored simplex points\r\n * @property {number[]} indexA - The cached simplex indices on shape A\r\n * @property {number[]} indexB - The cached simplex indices on shape B\r\n */\r\nexport class b2DistanceCache\r\n{\r\n    constructor()\r\n    {\r\n        this.count = 0;\r\n        this.indexA = [ 0,0,0 ];\r\n        this.indexB = [ 0,0,0 ];\r\n        \r\n    }\r\n    clone()\r\n    {\r\n        const cache = new b2DistanceCache();\r\n        cache.count = this.count;\r\n        cache.indexA = [ ...this.indexA ];\r\n        cache.indexB = [ ...this.indexB ];\r\n\r\n        return cache;\r\n    }\r\n}\r\n\r\n// export const b2_emptyDistanceCache = new b2DistanceCache();\r\n\r\n/**\r\n * @class b2DistanceInput\r\n * @summary Input for b2ShapeDistance\r\n * @property {b2DistanceProxy} proxyA - The proxy for shape A\r\n * @property {b2DistanceProxy} proxyB - The proxy for shape B\r\n * @property {b2Transform} transformA - The world transform for shape A\r\n * @property {b2Transform} transformB - The world transform for shape B\r\n * @property {boolean} useRadii - Should the proxy radius be considered?\r\n */\r\nexport class b2DistanceInput\r\n{\r\n    constructor()\r\n    {\r\n        this.proxyA = new b2DistanceProxy();\r\n        this.proxyB = new b2DistanceProxy();\r\n        this.transformA = new b2Transform(new b2Vec2(0,0), new b2Rot(0,0));\r\n        this.transformB = new b2Transform(new b2Vec2(0,0), new b2Rot(0,0));\r\n        this.useRadii = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2DistanceOutput\r\n * @summary Output for b2ShapeDistance\r\n * @property {b2Vec2} pointA - Closest point on shapeA\r\n * @property {b2Vec2} pointB - Closest point on shapeB\r\n * @property {number} distance - The final distance, zero if overlapped\r\n * @property {number} iterations - Number of GJK iterations used\r\n * @property {number} simplexCount - The number of simplexes stored in the simplex array\r\n */\r\nexport class b2DistanceOutput\r\n{\r\n    constructor()\r\n    {\r\n        this.pointA = new b2Vec2(0,0);\r\n        this.pointB = new b2Vec2(0,0);\r\n        this.distance = 0;\r\n        this.iterations = 0;\r\n        this.simplexCount = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2SimplexVertex\r\n * @summary Simplex vertex for debugging the GJK algorithm\r\n * @property {b2Vec2} wA - Support point in proxyA\r\n * @property {b2Vec2} wB - Support point in proxyB\r\n * @property {b2Vec2} w - wB - wA\r\n * @property {number} a - Barycentric coordinate for closest point\r\n * @property {number} indexA - wA index\r\n * @property {number} indexB - wB index\r\n */\r\nexport class b2SimplexVertex\r\n{\r\n    constructor()\r\n    {\r\n        this.wA = null;   // new b2Vec2(0,0);\r\n        this.wB = null;   // new b2Vec2(0,0);\r\n        this.w = null;   // new b2Vec2(0,0);\r\n        this.a = 0;\r\n        this.indexA = 0;\r\n        this.indexB = 0;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const sv = new b2SimplexVertex();\r\n        sv.wA = this.wA.clone();\r\n        sv.wB = this.wB.clone();\r\n        sv.w = this.w.clone();\r\n        sv.a = this.a;\r\n        sv.indexA = this.indexA;\r\n        sv.indexB = this.indexB;\r\n\r\n        return sv;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Simplex\r\n * @summary Simplex from the GJK algorithm\r\n * @property {b2SimplexVertex} v1 - Simplex vertex\r\n * @property {b2SimplexVertex} v2 - Simplex vertex\r\n * @property {b2SimplexVertex} v3 - Simplex vertex\r\n * @property {number} count - Number of valid vertices\r\n */\r\nexport class b2Simplex\r\n{\r\n    constructor()\r\n    {\r\n        this.v1 = new b2SimplexVertex();\r\n        this.v2 = new b2SimplexVertex();\r\n        this.v3 = new b2SimplexVertex();\r\n        this.count = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ShapeCastPairInput\r\n * @summary Input parameters for b2ShapeCast\r\n * @property {b2DistanceProxy} proxyA The proxy for shape A\r\n * @property {b2DistanceProxy} proxyB The proxy for shape B\r\n * @property {b2Transform} transformA The world transform for shape A\r\n * @property {b2Transform} transformB The world transform for shape B\r\n * @property {b2Vec2} translationB The translation of shape B\r\n * @property {number} maxFraction The fraction of the translation to consider, typically 1\r\n */\r\nexport class b2ShapeCastPairInput\r\n{\r\n    constructor()\r\n    {\r\n        this.proxyA = new b2DistanceProxy();\r\n        this.proxyB = new b2DistanceProxy();\r\n        this.transformA = new b2Transform(new b2Vec2(0,0), new b2Rot(0,0));\r\n        this.transformB = new b2Transform(new b2Vec2(0,0), new b2Rot(0,0));\r\n        this.translationB = new b2Vec2(0,0);\r\n        this.maxFraction = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Sweep\r\n * @summary Describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin, which may not coincide with the center of mass. However, to support dynamics we must interpolate the center of mass position.\r\n * @property {b2Vec2} localCenter - Local center of mass position\r\n * @property {b2Vec2} c1 - Starting center of mass world position\r\n * @property {b2Vec2} c2 - Ending center of mass world position\r\n * @property {b2Rot} q1 - Starting world rotation\r\n * @property {b2Rot} q2 - Ending world rotation\r\n */\r\nexport class b2Sweep\r\n{\r\n    constructor(c = null, v1 = null, v2 = null, r1 = null, r2 = null)\r\n    {\r\n        this.localCenter = c;\r\n        this.c1 = v1;\r\n        this.c2 = v2;\r\n        this.q1 = r1;\r\n        this.q2 = r2;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2Sweep(this.localCenter.clone(), this.c1.clone(), this.c2.clone(), this.q1.clone(), this.q2.clone());\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2TOIInput\r\n * @summary Input parameters for b2TimeOfImpact\r\n * @property {b2DistanceProxy} proxyA - The proxy for shape A\r\n * @property {b2DistanceProxy} proxyB - The proxy for shape B\r\n * @property {b2Sweep} sweepA - The movement of shape A\r\n * @property {b2Sweep} sweepB - The movement of shape B\r\n * @property {number} tMax - Defines the sweep interval [0, tMax]\r\n */\r\nexport class b2TOIInput\r\n{\r\n    constructor(proxyA = null, proxyB = null, sweepA = null, sweepB = null, tMax = 0)\r\n    {\r\n        this.proxyA = proxyA; // new b2DistanceProxy();\r\n        this.proxyB = proxyB; // new b2DistanceProxy();\r\n        this.sweepA = sweepA; // new b2Sweep();\r\n        this.sweepB = sweepB; // new b2Sweep();\r\n        this.tMax = tMax;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2TOIInput(this.proxyA.clone(), this.proxyB.clone(), this.sweepA.clone(), this.sweepB.clone(), this.tMax);\r\n    }\r\n}\r\n\r\nexport const b2TOIState = {\r\n    b2_toiStateUnknown: 0,\r\n    b2_toiStateFailed: 1,\r\n    b2_toiStateOverlapped: 2,\r\n    b2_toiStateHit: 3,\r\n    b2_toiStateSeparated: 4\r\n};\r\n\r\n/**\r\n * @class b2TOIOutput\r\n * @summary Output parameters for b2TimeOfImpact\r\n * @property {b2TOIState} state - The type of result\r\n * @property {number} t - The time of the collision\r\n */\r\nexport class b2TOIOutput\r\n{\r\n    constructor()\r\n    {\r\n        this.state = b2TOIState.b2_toiStateUnknown;\r\n        this.t = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ManifoldPoint\r\n * @summary A manifold point is a contact point belonging to a contact manifold. It holds details related to the geometry and dynamics of the contact points.\r\n * @property {b2Vec2} point - Location of the contact point in world space. Subject to precision loss at large coordinates. Should only be used for debugging.\r\n * @property {b2Vec2} anchorA - Location of the contact point relative to bodyA's origin in world space. When used internally to the Box2D solver, this is relative to the center of mass.\r\n * @property {b2Vec2} anchorB - Location of the contact point relative to bodyB's origin in world space. When used internally to the Box2D solver, this is relative to the center of mass.\r\n * @property {number} separation - The separation of the contact point, negative if penetrating\r\n * @property {number} normalImpulse - The impulse along the manifold normal vector\r\n * @property {number} tangentImpulse - The friction impulse\r\n * @property {number} maxNormalImpulse - The maximum normal impulse applied during sub-stepping\r\n * @property {number} normalVelocity - Relative normal velocity pre-solve. Used for hit events. If the normal impulse is zero then there was no hit. Negative means shapes are approaching.\r\n * @property {number} id - Uniquely identifies a contact point between two shapes\r\n * @property {boolean} persisted - Did this contact point exist the previous step?\r\n */\r\nexport class b2ManifoldPoint\r\n{\r\n    constructor()\r\n    {\r\n        this.pointX = 0;\r\n        this.pointY = 0;\r\n        this.anchorAX = 0;\r\n        this.anchorAY = 0;\r\n        this.anchorBX = 0;\r\n        this.anchorBY = 0;\r\n        this.separation = 0;\r\n        this.normalImpulse = 0;\r\n        this.tangentImpulse = 0;\r\n        this.maxNormalImpulse = 0;\r\n        this.normalVelocity = 0;\r\n        this.id = 0;\r\n        this.persisted = false;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const clone = new b2ManifoldPoint();\r\n        clone.pointX = this.pointX;\r\n        clone.pointY = this.pointY;\r\n        clone.anchorAX = this.anchorAX;\r\n        clone.anchorAY = this.anchorAY;\r\n        clone.anchorBX = this.anchorBX;\r\n        clone.anchorBY = this.anchorBY;\r\n        clone.separation = this.separation;\r\n        clone.normalImpulse = this.normalImpulse;\r\n        clone.tangentImpulse = this.tangentImpulse;\r\n        clone.maxNormalImpulse = this.maxNormalImpulse;\r\n        clone.normalVelocity = this.normalVelocity;\r\n        clone.id = this.id;\r\n        clone.persisted = this.persisted;\r\n\r\n        return clone;\r\n    }\r\n\r\n    clear()\r\n    {\r\n        this.pointX = 0;\r\n        this.pointY = 0;\r\n        this.anchorAX = 0;\r\n        this.anchorAY = 0;\r\n        this.anchorBX = 0;\r\n        this.anchorBY = 0;\r\n        this.separation = 0;\r\n        this.normalImpulse = 0;\r\n        this.tangentImpulse = 0;\r\n        this.maxNormalImpulse = 0;\r\n        this.normalVelocity = 0;\r\n        this.id = 0;\r\n        this.persisted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo(mp)\r\n    {\r\n        mp.pointX = this.pointX;\r\n        mp.pointY = this.pointY;\r\n        mp.anchorAX = this.anchorAX;\r\n        mp.anchorAY = this.anchorAY;\r\n        mp.anchorBX = this.anchorBX;\r\n        mp.anchorBY = this.anchorBY;\r\n        mp.separation = this.separation;\r\n        mp.normalImpulse = this.normalImpulse;\r\n        mp.tangentImpulse = this.tangentImpulse;\r\n        mp.maxNormalImpulse = this.maxNormalImpulse;\r\n        mp.normalVelocity = this.normalVelocity;\r\n        mp.id = this.id;\r\n        mp.persisted = this.persisted;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Manifold\r\n * @summary A contact manifold describes the contact points between colliding shapes\r\n * @property {b2ManifoldPoint[]} points - The manifold points, up to two are possible in 2D\r\n * @property {b2Vec2} normal - The unit normal vector in world space, points from shape A to bodyB\r\n * @property {number} pointCount - The number of contacts points, will be 0, 1, or 2\r\n */\r\nexport class b2Manifold\r\n{\r\n    constructor(p1 = new b2ManifoldPoint(), p2 = new b2ManifoldPoint())\r\n    {\r\n        this.points = [ p1, p2 ];\r\n        this.normalX = this.normalY = 0;\r\n        this.pointCount = 0;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const clone = new b2Manifold();\r\n\r\n        this.copyTo(clone);\r\n\r\n        return clone;\r\n    }\r\n\r\n    clear()\r\n    {\r\n        if (this.points[0])\r\n        {\r\n            this.points[0].clear();\r\n        }\r\n\r\n        if (this.points[1])\r\n        {\r\n            this.points[1].clear();\r\n        }\r\n\r\n        this.normalX = this.normalY = 0;\r\n        this.pointCount = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo(manifold)\r\n    {\r\n        this.points[0].copyTo(manifold.points[0]);\r\n        this.points[1].copyTo(manifold.points[1]);\r\n        manifold.normalX = this.normalX;\r\n        manifold.normalY = this.normalY;\r\n        manifold.pointCount = this.pointCount;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2TreeNode\r\n * @summary A node in the dynamic tree. This is private data placed here for performance reasons.\r\n * @property {b2AABB} aabb - The node bounding box\r\n * @property {number} categoryBits - Category bits for collision filtering\r\n * @property {number} parent - The node parent index (allocated node)\r\n * @property {number} next - The node freelist next index (free node)\r\n * @property {number} child1 - Child 1 index (internal node)\r\n * @property {number} child2 - Child 2 index (internal node)\r\n * @property {number} userData - User data (leaf node)\r\n * @property {number} height - Node height\r\n * @property {number} flags - Node flags\r\n */\r\nexport class b2TreeNode\r\n{\r\n    constructor()\r\n    {\r\n        this.aabb = null;\r\n        this.categoryBits = 0;\r\n\r\n        // NOTE: removed the C union of parent and next\r\n        this.parent_next = B2_NULL_INDEX;\r\n        this.child1 = B2_NULL_INDEX;\r\n        this.child2 = B2_NULL_INDEX;\r\n        this.userData = 0;\r\n        this.height = -1;\r\n        this.enlarged = false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * These are performance results returned by dynamic tree queries.\r\n * @typedef {Object} b2TreeStats\r\n * @property {number} nodeVisits - Number of internal nodes visited during the query.\r\n * @property {number} leafVisits - Number of leaf nodes visited during the query.\r\n */\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n/**\r\n * @namespace Table\r\n */\r\n\r\n// use a map instead of an object: Map can use bigint as a key where object will convert it to a string first\r\n// WARNING: map has property 'size' instead of the C original 'count' and does not have 'capacity'\r\n// TODO: remove this utterly in the future, it's just an array wrapper in JS\r\n\r\nexport function b2CreateSet()\r\n{\r\n    return new Map();\r\n}\r\n\r\nexport function b2DestroySet(set)\r\n{\r\n    set.clear();\r\n}\r\n\r\nexport function b2ClearSet(set)\r\n{\r\n    set.clear();\r\n}\r\n\r\nexport function b2ContainsKey(set, key)\r\n{\r\n    return set.has(key);\r\n}\r\n\r\nexport function b2AddKey(set, key)\r\n{\r\n    if (set.has(key))\r\n    {\r\n        return true;\r\n    }\r\n    set.set(key, 1);\r\n\r\n    return false;\r\n}\r\n\r\nexport function b2RemoveKey(set, key)\r\n{\r\n    return set.delete(key);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nexport const B2_SHAPE_PAIR_KEY = (K1, K2) => K1 < K2 ? BigInt(K1) << 32n | BigInt(K2) : BigInt(K2) << 32n | BigInt(K1);\r\n\r\nexport {\r\n\r\n    // b2SetItem,\r\n    b2CreateSet,\r\n    b2DestroySet,\r\n    b2ClearSet,\r\n    b2AddKey,\r\n    b2RemoveKey,\r\n    b2ContainsKey\r\n} from '../table_c.js';\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n/**\r\n * @namespace StackAllocator\r\n*/\r\n\r\n// TODO: remove this utterly in the future, it's just an array wrapper in JS\r\n\r\nexport class b2StackAllocator\r\n{\r\n    constructor()\r\n    {\r\n        this.data = null;\r\n        this.entries = null;\r\n        \r\n    }\r\n}\r\n\r\nclass b2StackEntry\r\n{\r\n    constructor()\r\n    {\r\n        this.data = null;\r\n        this.name = null;\r\n        this.size = 0;\r\n        \r\n    }\r\n}\r\n\r\nexport function b2CreateStackAllocator(capacity)\r\n{\r\n    const allocator = new b2StackAllocator();\r\n    allocator.data = [];\r\n    allocator.entries = [];\r\n\r\n    return allocator;\r\n}\r\n\r\nexport function b2DestroyStackAllocator(allocator)\r\n{\r\n    allocator.data = null;\r\n    allocator.entries = null;\r\n}\r\n\r\nexport function b2AllocateStackItem(alloc, size, name, ctor = null)\r\n{\r\n    console.assert(size >= 0);\r\n    const entry = new b2StackEntry();\r\n    entry.size = size;\r\n    entry.name = name;\r\n    entry.data = [];\r\n\r\n    for (let i = 0; i < size; i++)\r\n    {\r\n        if (ctor)\r\n        { entry.data.push(ctor()); }\r\n        else\r\n        { entry.data.push(null); }\r\n    }\r\n    alloc.entries.push(entry);\r\n\r\n    return entry.data;\r\n}\r\n\r\nexport function b2FreeStackItem(alloc, mem)\r\n{\r\n    const entryCount = alloc.entries.length;\r\n    console.assert(entryCount > 0);\r\n    const entry = alloc.entries[entryCount - 1];\r\n    console.assert(entry.data == mem);\r\n    console.assert(entry.size >= 0);\r\n    alloc.entries.pop();\r\n}\r\n\r\nexport function b2GrowStack(alloc)\r\n{\r\n}\r\n\r\nexport function b2GetStackCapacity(alloc)\r\n{\r\n    return Number.MAX_SAFE_INTEGER;\r\n}\r\n\r\nexport function b2GetStackAllocation(alloc)\r\n{\r\n    return alloc.entries.length;\r\n}\r\n\r\nexport function b2GetMaxStackAllocation(alloc)\r\n{\r\n    return Number.MAX_SAFE_INTEGER;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n\r\n/**\r\n * @namespace Allocate\r\n*/\r\n\r\n// In JS we don't need to allocate space for the array or grow it because it can't become 'full'\r\n// however the initCallback is useful for ensuring that class object constructors get called\r\n\r\nexport function b2Alloc(size, initCallback = null)\r\n{\r\n    const ptr = [];\r\n\r\n    if (initCallback)\r\n    {\r\n        for (let i = 0; i < size; i++)\r\n        { ptr[i] = initCallback(); }\r\n    }\r\n\r\n    return ptr;\r\n}\r\n\r\nexport function b2Grow(mem, newSize, initCallback = null)\r\n{\r\n    const oldSize = mem.length;\r\n\r\n    if (initCallback)\r\n    {\r\n        for (let i = oldSize; i < newSize; i++)\r\n        { mem[i] = initCallback(); }\r\n    }\r\n\r\n    return mem;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2BodyDef, b2BodyType, b2ChainDef, b2Filter, b2QueryFilter, b2ShapeDef, b2WorldDef } from './include/types_h.js';\r\nimport { b2Rot, b2Vec2 } from './include/math_functions_h.js';\r\n\r\nimport { b2_lengthUnitsPerMeter } from './include/core_h.js';\r\n\r\n/**\r\n * @namespace Types\r\n */\r\n\r\nexport const b2Validation = false;\r\n\r\nexport const b2Assert = function(condition, message, forceCheck = false)\r\n{\r\n    if (b2Validation || forceCheck)\r\n    {\r\n        if (!condition)\r\n        {\r\n            const error = new Error(message);\r\n            error.stack = error.stack.split('\\n').slice(1)[0];\r\n            console.assert(false, error);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a default world definition with pre-configured physics simulation parameters.\r\n * @function b2DefaultWorldDef\r\n * @returns {b2WorldDef} A world definition object with the following properties:\r\n * - gravity: {b2Vec2} Set to (0, -10)\r\n * - hitEventThreshold: {number} Set to 1 meter\r\n * - restitutionThreshold: {number} Set to 10 meters\r\n * - contactPushoutVelocity: {number} Set to 5 meters\r\n * - contactHertz: {number} Set to 30\r\n * - contactDampingRatio: {number} Set to 10\r\n * - jointHertz: {number} Set to 60\r\n * - jointDampingRatio: {number} Set to 5\r\n * - maximumLinearVelocity: {number} Set to 400 meters\r\n * - enableSleep: {boolean} Set to true\r\n * - enableContinuous: {boolean} Set to true\r\n * @description\r\n * Initializes a new b2WorldDef with default values suitable for standard physics simulations.\r\n * All distance-based values are scaled by b2_lengthUnitsPerMeter2.\r\n */\r\nexport function b2DefaultWorldDef()\r\n{\r\n    const def = new b2WorldDef();\r\n    def.gravity = new b2Vec2(0.0, -10.0);\r\n    def.hitEventThreshold = 1.0 * b2_lengthUnitsPerMeter;\r\n    def.restitutionThreshold = 10.0 * b2_lengthUnitsPerMeter;\r\n    def.contactPushoutVelocity = 5.0 * b2_lengthUnitsPerMeter;\r\n    def.contactHertz = 30.0;\r\n    def.contactDampingRatio = 10.0;\r\n    def.jointHertz = 60.0;\r\n    def.jointDampingRatio = 5.0;\r\n    def.maximumLinearVelocity = 400.0 * b2_lengthUnitsPerMeter;\r\n    def.enableSleep = true;\r\n    def.enableContinuous = true;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a new b2BodyDef with default values.\r\n * @function b2DefaultBodyDef\r\n * @returns {b2BodyDef} A body definition object with the following default properties:\r\n * - type: b2_staticBody\r\n * - position: (0,0)\r\n * - rotation: (cos=1, sin=0)\r\n * - linearVelocity: (0,0)\r\n * - angularVelocity: 0\r\n * - linearDamping: 0\r\n * - angularDamping: 0\r\n * - gravityScale: 1\r\n * - sleepThreshold: 0.05 * b2_lengthUnitsPerMeter2\r\n * - userData: null\r\n * - enableSleep: true\r\n * - isAwake: true\r\n * - fixedRotation: false\r\n * - isBullet: false\r\n * - isEnabled: true\r\n * - updateBodyMass: true\r\n * - allowFastRotation: false\r\n */\r\nexport function b2DefaultBodyDef()\r\n{\r\n    const def = new b2BodyDef();\r\n    def.type = b2BodyType.b2_staticBody;\r\n    def.position = new b2Vec2(0, 0);\r\n    def.rotation = new b2Rot(1, 0);\r\n    def.linearVelocity = new b2Vec2(0, 0);\r\n    def.angularVelocity = 0;\r\n    def.linearDamping = 0;\r\n    def.angularDamping = 0;\r\n    def.gravityScale = 1.0;\r\n    def.sleepThreshold = 0.05 * b2_lengthUnitsPerMeter;\r\n    def.userData = null;\r\n    def.enableSleep = true;\r\n    def.isAwake = true;\r\n    def.fixedRotation = false;\r\n    def.isBullet = false;\r\n    def.isEnabled = true;\r\n    def.updateBodyMass = true;\r\n    def.allowFastRotation = false;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * @summary Creates a default collision filter with standard values.\r\n * @function b2DefaultFilter\r\n * @returns {b2Filter} A filter object with categoryBits=1, maskBits=4294967295 (0xFFFFFFFF), and groupIndex=0\r\n * @description\r\n * Creates and returns a new b2Filter object initialized with default values for collision filtering.\r\n * The categoryBits determine what collision category this object belongs to,\r\n * the maskBits determine what categories this object can collide with,\r\n * and the groupIndex determines collision groups (negative values mean never collide,\r\n * positive values mean always collide with same group).\r\n */\r\nexport function b2DefaultFilter()\r\n{\r\n    const filter = new b2Filter();\r\n    filter.categoryBits = 0x00000001;\r\n    filter.maskBits = 0xffffffff;\r\n    filter.groupIndex = 0;\r\n\r\n    return filter;\r\n}\r\n\r\n/**\r\n * Creates a default query filter with standard settings.\r\n * @function b2DefaultQueryFilter\r\n * @returns {b2QueryFilter} A query filter object with categoryBits set to 1 and\r\n * maskBits set to 4294967295 (0xFFFFFFFF).\r\n * @description\r\n * This function instantiates a new b2QueryFilter with default collision filtering\r\n * settings. The categoryBits value of 1 represents the default category, while\r\n * the maskBits value of 4294967295 allows collision with all categories.\r\n */\r\nexport function b2DefaultQueryFilter()\r\n{\r\n    const filter = new b2QueryFilter();\r\n    filter.categoryBits = 0x00000001;\r\n    filter.maskBits = 0xffffffff;\r\n\r\n    return filter;\r\n}\r\n\r\n/**\r\n * Creates a default shape definition with standard physics properties.\r\n * @function b2DefaultShapeDef\r\n * @returns {b2ShapeDef} A shape definition object with the following default values:\r\n * - friction: 0.6\r\n * - density: 1\r\n * - restitution: 0.1\r\n * - filter: default collision filter\r\n * - enableSensorEvents: true\r\n * - enableContactEvents: true\r\n * @description\r\n * This function initializes a new b2ShapeDef object with commonly used physics\r\n * properties. The shape definition can be used to create various types of\r\n * physics shapes in Box2D.\r\n */\r\nexport function b2DefaultShapeDef()\r\n{\r\n    const def = new b2ShapeDef();\r\n    def.friction = 0.6;\r\n    def.density = 1.0;\r\n    def.restitution = 0.1;\r\n    def.filter = b2DefaultFilter();\r\n    def.enableSensorEvents = true;\r\n    def.enableContactEvents = true;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a new b2ChainDef with default values.\r\n * @function b2DefaultChainDef\r\n * @returns {b2ChainDef} A chain definition object with:\r\n * - friction set to 0.6\r\n * - default filter settings\r\n * - all other properties at their default values\r\n * @description\r\n * Initializes a new chain definition with common default values.\r\n * The chain shape represents a series of connected line segments.\r\n */\r\nexport function b2DefaultChainDef()\r\n{\r\n    const def = new b2ChainDef();\r\n    def.friction = 0.6;\r\n    def.filter = b2DefaultFilter();\r\n\r\n    return def;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2AABB, b2Rot, b2Vec2 } from './math_functions_h.js';\r\n\r\nexport {\r\n\r\n    // debugging\r\n    b2Validation,\r\n\r\n    b2DefaultWorldDef, b2DefaultBodyDef, b2DefaultFilter, b2DefaultQueryFilter, b2DefaultShapeDef, b2DefaultChainDef,\r\n} from '../types_c.js';\r\n\r\nexport const b2BodyType = {\r\n    b2_staticBody: 0,\r\n    b2_kinematicBody: 1,\r\n    b2_dynamicBody: 2,\r\n    b2_bodyTypeCount: 3\r\n};\r\n\r\nexport const b2ShapeType = {\r\n    b2_circleShape: 0,\r\n    b2_capsuleShape: 1,\r\n    b2_segmentShape: 2,\r\n    b2_polygonShape: 3,\r\n    b2_chainSegmentShape: 4,\r\n    b2_shapeTypeCount: 5\r\n};\r\n\r\nexport const b2JointType = {\r\n    b2_distanceJoint: 0,\r\n    b2_motorJoint: 1,\r\n    b2_mouseJoint: 2,\r\n    b2_prismaticJoint: 3,\r\n    b2_revoluteJoint: 4,\r\n    b2_weldJoint: 5,\r\n    b2_wheelJoint: 6,\r\n    b2_unknown: -1\r\n};\r\n\r\n/**\r\n * Result from b2World_RayCastClosest\r\n * @class b2RayResult\r\n * @property {b2ShapeId} shapeId - The shape that was hit\r\n * @property {b2Vec2} point - The hit point\r\n * @property {b2Vec2} normal - The hit normal\r\n * @property {number} fraction - The hit fraction along the ray\r\n * @property {number} nodeVisits - Number of tree nodes visited\r\n * @property {number} leafVisits - Number of tree leaves visited\r\n * @property {boolean} hit - Whether the ray hit anything\r\n */\r\nexport class b2RayResult\r\n{\r\n    constructor()\r\n    {\r\n        this.shapeId = null;\r\n        this.point = new b2Vec2(0, 0);\r\n        this.normal = new b2Vec2(0, 0);\r\n        this.fraction = 0;\r\n        this.hit = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2WorldDef\r\n * @summary World definition used to create a simulation world. Must be initialized using b2DefaultWorldDef().\r\n * @property {b2Vec2} gravity - Gravity vector. Box2D has no up-vector defined.\r\n * @property {number} restitutionThreshold - Restitution velocity threshold, usually in m/s. Collisions above this speed have restitution applied (will bounce).\r\n * @property {number} contactPushoutVelocity - This parameter controls how fast overlap is resolved and has units of meters per second\r\n * @property {number} hitEventThreshold - Threshold velocity for hit events. Usually meters per second.\r\n * @property {number} contactHertz - Contact stiffness. Cycles per second.\r\n * @property {number} contactDampingRatio - Contact bounciness. Non-dimensional.\r\n * @property {number} jointHertz - Joint stiffness. Cycles per second.\r\n * @property {number} jointDampingRatio - Joint bounciness. Non-dimensional.\r\n * @property {number} maximumLinearVelocity - Maximum linear velocity. Usually meters per second.\r\n * @property {b2MixingRule} frictionMixingRule - Mixing rule for friction. Default is b2_mixGeometricMean.\r\n * @property {b2MixingRule} restitutionMixingRule - Mixing rule for restitution. Default is b2_mixMaximum.\r\n * @property {boolean} enableSleep - Can bodies go to sleep to improve performance\r\n * @property {boolean} enableContinuous - Enable continuous collision\r\n * @property {number} workerCount - Number of workers to use with the provided task system.\r\n * @property {Function} enqueueTask - Function to spawn tasks\r\n * @property {Function} finishTask - Function to finish a task\r\n * @property {*} userTaskContext - User context that is provided to enqueueTask and finishTask\r\n * @property {*} userData - User data\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2WorldDef\r\n{\r\n    constructor()\r\n    {\r\n        this.gravity = new b2Vec2(0, 0);\r\n        this.restitutionThreshold = 0;\r\n        this.contactPushoutVelocity = 0;\r\n        this.hitEventThreshold = 0;\r\n        this.contactHertz = 0;\r\n        this.contactDampingRatio = 0;\r\n        this.jointHertz = 0;\r\n        this.jointDampingRatio = 0;\r\n        this.maximumLinearVelocity = 0;\r\n        this.enableSleep = false;\r\n        this.enableContinuous = true;\r\n        this.workerCount = 0;\r\n\r\n        // this.userTaskContext = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2BodyDef\r\n * @summary Definition used to construct a rigid body\r\n * @property {b2BodyType} type - The body type: static, kinematic, or dynamic\r\n * @property {b2Vec2} position - The initial world position of the body\r\n * @property {b2Rot} rotation - The initial world rotation of the body\r\n * @property {b2Vec2} linearVelocity - The initial linear velocity in meters per second\r\n * @property {number} angularVelocity - The initial angular velocity in radians per second\r\n * @property {number} linearDamping - Linear damping to reduce linear velocity\r\n * @property {number} angularDamping - Angular damping to reduce angular velocity\r\n * @property {number} gravityScale - Scale factor applied to gravity for this body\r\n * @property {number} sleepThreshold - Sleep velocity threshold, default 0.05 m/s\r\n * @property {*} userData - Application specific body data\r\n * @property {boolean} enableSleep - Whether this body can fall asleep\r\n * @property {boolean} isAwake - Whether body starts awake or sleeping\r\n * @property {boolean} fixedRotation - Whether to prevent rotation\r\n * @property {boolean} isBullet - Whether to use continuous collision detection\r\n * @property {boolean} isEnabled - Whether body can move and collide\r\n * @property {boolean} allowFastRotation - Whether to bypass rotation speed limits\r\n * @property {number} internalValue - Internal validation flag\r\n */\r\nexport class b2BodyDef\r\n{\r\n    constructor()\r\n    {\r\n        this.type = b2BodyType.b2_staticBody;\r\n        this.position = new b2Vec2(0, 0);\r\n        this.rotation = new b2Rot(1, 0);\r\n        this.linearVelocity = new b2Vec2(0, 0);\r\n        this.angularVelocity = 0;\r\n        this.linearDamping = 0;\r\n        this.angularDamping = 0;\r\n        this.gravityScale = 0;\r\n        this.sleepThreshold = 0;\r\n        this.userData = null;\r\n        this.enableSleep = false;\r\n        this.isAwake = false;\r\n        this.fixedRotation = false;\r\n        this.isBullet = false;\r\n        this.isEnabled = false;\r\n        this.updateBodyMass = false;\r\n        this.allowFastRotation = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ShapeDef\r\n * @summary Used to create a shape. This is a temporary object used to bundle shape creation parameters.\r\n * You may use the same shape definition to create multiple shapes.\r\n * Must be initialized using b2DefaultShapeDef().\r\n * @property {*} userData - Use this to store application specific shape data\r\n * @property {number} friction - The Coulomb (dry) friction coefficient, usually in the range [0,1]\r\n * @property {number} restitution - The restitution (bounce) usually in the range [0,1]\r\n * @property {number} density - The density, usually in kg/m^2\r\n * @property {b2Filter} filter - Collision filtering data\r\n * @property {number} customColor - Custom debug draw color\r\n * @property {boolean} isSensor - A sensor shape generates overlap events but never generates a collision response\r\n * @property {boolean} enableSensorEvents - Enable sensor events for this shape. Only applies to kinematic and dynamic bodies\r\n * @property {boolean} enableContactEvents - Enable contact events for this shape. Only applies to kinematic and dynamic bodies\r\n * @property {boolean} enableHitEvents - Enable hit events for this shape. Only applies to kinematic and dynamic bodies\r\n * @property {boolean} enablePreSolveEvents - Enable pre-solve contact events for this shape. Only applies to dynamic bodies\r\n * @property {boolean} invokeContactCreation - Override static body behavior to force contact creation\r\n * @property {boolean} updateBodyMass - Should the body update mass properties when shape is created\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET\r\n */\r\nexport class b2ShapeDef\r\n{\r\n    constructor()\r\n    {\r\n        this.userData = null;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n        this.density = 0;\r\n        this.filter = new b2Filter();\r\n        this.customColor = b2HexColor.b2_colorAqua; // .b2_colorAliceBlue;\r\n\r\n        // / Sensors do not collide with other sensors and do not have continuous collision.\r\n        // / Instead use a ray or shape cast for those scenarios.\r\n        this.isSensor = false;\r\n\r\n        // / Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.\r\n        this.enableSensorEvents = false;\r\n\r\n        // / Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.\r\n        this.enableContactEvents = false;\r\n\r\n        // / Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.\r\n        this.enableHitEvents = false;\r\n\r\n        // / Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive\r\n        // /\tand must be carefully handled due to threading. Ignored for sensors.\r\n        // / PJB NOTE: threading concerns do not apply to the JS translation.\r\n        this.enablePreSolveEvents = false;\r\n\r\n        // / Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides\r\n        // /\tthat behavior and causes contact creation. This significantly slows down static body creation which can be important\r\n        // /\twhen there are many static shapes.\r\n        // / This is implicitly always true for sensors.\r\n        this.forceContactCreation = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ChainDef\r\n * @summary Definition for creating a chain of line segments. Designed for static bodies with one-sided collision detection.\r\n * @property {void} userData - Use this to store application specific shape data\r\n * @property {b2Vec2[]} points - Array of at least 4 points defining the chain segments\r\n * @property {number} count - The point count, must be 4 or more\r\n * @property {number} friction - The friction coefficient, usually in the range [0,1]\r\n * @property {number} restitution - The restitution (elasticity) usually in the range [0,1]\r\n * @property {b2Filter} filter - Contact filtering data\r\n * @property {number} customColor - Custom debug draw color\r\n * @property {boolean} isLoop - Indicates a closed chain formed by connecting first and last points\r\n * @property {number} internalValue - Used internally to detect valid definition. DO NOT SET\r\n */\r\nexport class b2ChainDef\r\n{\r\n    constructor()\r\n    {\r\n        this.userData = null;\r\n        this.points = null;\r\n        this.count = 0;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n        this.filter = new b2Filter();\r\n        this.isLoop = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2DistanceJointDef\r\n * @summary Distance joint definition that connects two bodies with a specified distance between anchor points\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} localAnchorA - The local anchor point relative to bodyA's origin\r\n * @property {b2Vec2} localAnchorB - The local anchor point relative to bodyB's origin\r\n * @property {number} length - The rest length of this joint. Clamped to a stable minimum value.\r\n * @property {boolean} enableSpring - Enable the distance constraint to behave like a spring. If false then the distance joint will be rigid, overriding the limit and motor.\r\n * @property {number} hertz - The spring linear stiffness Hertz, cycles per second\r\n * @property {number} dampingRatio - The spring linear damping ratio, non-dimensional\r\n * @property {boolean} enableLimit - Enable/disable the joint limit\r\n * @property {number} minLength - Minimum length. Clamped to a stable minimum value.\r\n * @property {number} maxLength - Maximum length. Must be greater than or equal to the minimum length.\r\n * @property {boolean} enableMotor - Enable/disable the joint motor\r\n * @property {number} maxMotorForce - The maximum motor force, usually in newtons\r\n * @property {number} motorSpeed - The desired motor speed, usually in meters per second\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n * @description This requires defining an anchor point on both bodies and the non-zero distance of the distance joint. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when saving and loading a game.\r\n */\r\nexport class b2DistanceJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.localAnchorA = new b2Vec2(0, 0);\r\n        this.localAnchorB = new b2Vec2(0, 0);\r\n        this.length = 0;\r\n        this.enableSpring = false;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.enableLimit = false;\r\n        this.minLength = 0;\r\n        this.maxLength = 0;\r\n        this.enableMotor = false;\r\n        this.maxMotorForce = 0;\r\n        this.motorSpeed = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2MotorJointDef\r\n * @summary A motor joint controls relative motion between two bodies, typically used to control a dynamic body relative to ground\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} linearOffset - Position of bodyB minus the position of bodyA, in bodyA's frame\r\n * @property {number} angularOffset - The bodyB angle minus bodyA angle in radians\r\n * @property {number} maxForce - The maximum motor force in newtons\r\n * @property {number} maxTorque - The maximum motor torque in newton-meters\r\n * @property {number} correctionFactor - Position correction factor in the range [0,1]\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2MotorJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.linearOffset = new b2Vec2(0, 0);\r\n        this.angularOffset = 0;\r\n        this.maxForce = 0;\r\n        this.maxTorque = 0;\r\n        this.correctionFactor = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2MouseJointDef\r\n * @summary Definition for a mouse joint that makes a point on a body track a world point\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} target - The initial target point in world space\r\n * @property {number} hertz - Stiffness in hertz\r\n * @property {number} dampingRatio - Damping ratio, non-dimensional\r\n * @property {number} maxForce - Maximum force, typically in newtons\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2MouseJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.target = new b2Vec2(0, 0);\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.maxForce = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2PrismaticJointDef\r\n * @summary Prismatic joint definition that constrains motion along a defined axis\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} localAnchorA - The local anchor point relative to bodyA's origin\r\n * @property {b2Vec2} localAnchorB - The local anchor point relative to bodyB's origin\r\n * @property {b2Vec2} localAxisA - The local translation unit axis in bodyA\r\n * @property {number} referenceAngle - The constrained angle between the bodies: bodyB_angle - bodyA_angle\r\n * @property {boolean} enableSpring - Enable a linear spring along the prismatic joint axis\r\n * @property {number} hertz - The spring stiffness Hertz, cycles per second\r\n * @property {number} dampingRatio - The spring damping ratio, non-dimensional\r\n * @property {boolean} enableLimit - Enable/disable the joint limit\r\n * @property {number} lowerTranslation - The lower translation limit\r\n * @property {number} upperTranslation - The upper translation limit\r\n * @property {boolean} enableMotor - Enable/disable the joint motor\r\n * @property {number} maxMotorForce - The maximum motor force, typically in newtons\r\n * @property {number} motorSpeed - The desired motor speed, typically in meters per second\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2PrismaticJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.localAnchorA = new b2Vec2(0, 0);\r\n        this.localAnchorB = new b2Vec2(0, 0);\r\n        this.localAxisA = new b2Vec2(0, 0);\r\n        this.referenceAngle = 0;\r\n        this.enableSpring = false;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.enableLimit = false;\r\n        this.lowerTranslation = 0;\r\n        this.upperTranslation = 0;\r\n        this.enableMotor = false;\r\n        this.maxMotorForce = 0;\r\n        this.motorSpeed = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2RevoluteJointDef\r\n * @summary Revolute joint definition that specifies how two bodies are joined at an anchor point\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} localAnchorA - The local anchor point relative to bodyA's origin\r\n * @property {b2Vec2} localAnchorB - The local anchor point relative to bodyB's origin\r\n * @property {number} referenceAngle - The bodyB angle minus bodyA angle in the reference state (radians)\r\n * @property {boolean} enableSpring - Enable a rotational spring on the revolute hinge axis\r\n * @property {number} hertz - The spring stiffness Hertz, cycles per second\r\n * @property {number} dampingRatio - The spring damping ratio, non-dimensional\r\n * @property {boolean} enableLimit - A flag to enable joint limits\r\n * @property {number} lowerAngle - The lower angle for the joint limit in radians\r\n * @property {number} upperAngle - The upper angle for the joint limit in radians\r\n * @property {boolean} enableMotor - A flag to enable the joint motor\r\n * @property {number} maxMotorTorque - The maximum motor torque, typically in newton-meters\r\n * @property {number} motorSpeed - The desired motor speed in radians per second\r\n * @property {number} drawSize - Scale the debug draw\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2RevoluteJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.localAnchorA = new b2Vec2(0, 0);\r\n        this.localAnchorB = new b2Vec2(0, 0);\r\n        this.referenceAngle = 0;\r\n        this.enableSpring = false;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.enableLimit = false;\r\n        this.lowerAngle = 0;\r\n        this.upperAngle = 0;\r\n        this.enableMotor = false;\r\n        this.maxMotorTorque = 0;\r\n        this.motorSpeed = 0;\r\n        this.drawSize = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2WeldJointDef\r\n * @summary Weld joint definition that connects two bodies rigidly with optional spring properties\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} localAnchorA - The local anchor point relative to bodyA's origin\r\n * @property {b2Vec2} localAnchorB - The local anchor point relative to bodyB's origin\r\n * @property {number} referenceAngle - The bodyB angle minus bodyA angle in the reference state (radians)\r\n * @property {number} linearHertz - Linear stiffness expressed as Hertz (cycles per second). Use zero for maximum stiffness.\r\n * @property {number} angularHertz - Angular stiffness as Hertz (cycles per second). Use zero for maximum stiffness.\r\n * @property {number} linearDampingRatio - Linear damping ratio, non-dimensional. Use 1 for critical damping.\r\n * @property {number} angularDampingRatio - Linear damping ratio, non-dimensional. Use 1 for critical damping.\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2WeldJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.localAnchorA = new b2Vec2(0, 0);\r\n        this.localAnchorB = new b2Vec2(0, 0);\r\n        this.referenceAngle = 0;\r\n        this.linearHertz = 0;\r\n        this.angularHertz = 0;\r\n        this.linearDampingRatio = 0;\r\n        this.angularDampingRatio = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2WheelJointDef\r\n * @summary Wheel joint definition that defines a line of motion using an axis and anchor points\r\n * @property {b2BodyId} bodyIdA - The first attached body\r\n * @property {b2BodyId} bodyIdB - The second attached body\r\n * @property {b2Vec2} localAnchorA - The local anchor point relative to bodyA's origin\r\n * @property {b2Vec2} localAnchorB - The local anchor point relative to bodyB's origin\r\n * @property {b2Vec2} localAxisA - The local translation unit axis in bodyA\r\n * @property {boolean} enableSpring - Enable a linear spring along the local axis\r\n * @property {number} hertz - Spring stiffness in Hertz\r\n * @property {number} dampingRatio - Spring damping ratio, non-dimensional\r\n * @property {boolean} enableLimit - Enable/disable the joint linear limit\r\n * @property {number} lowerTranslation - The lower translation limit\r\n * @property {number} upperTranslation - The upper translation limit\r\n * @property {boolean} enableMotor - Enable/disable the joint rotational motor\r\n * @property {number} maxMotorTorque - The maximum motor torque, typically in newton-meters\r\n * @property {number} motorSpeed - The desired motor speed in radians per second\r\n * @property {boolean} collideConnected - Set this flag to true if the attached bodies should collide\r\n * @property {*} userData - User data pointer\r\n * @property {number} internalValue - Used internally to detect a valid definition. DO NOT SET.\r\n */\r\nexport class b2WheelJointDef\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyIdA = null;\r\n        this.bodyIdB = null;\r\n        this.localAnchorA = new b2Vec2(0, 0);\r\n        this.localAnchorB = new b2Vec2(0, 0);\r\n        this.localAxisA = new b2Vec2(0, 0);\r\n        this.enableSpring = false;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.enableLimit = false;\r\n        this.lowerTranslation = 0;\r\n        this.upperTranslation = 0;\r\n        this.enableMotor = false;\r\n        this.maxMotorTorque = 0;\r\n        this.motorSpeed = 0;\r\n        this.collideConnected = false;\r\n        this.userData = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2SensorBeginTouchEvent\r\n * @summary A begin touch event is generated when a shape starts to overlap a sensor shape.\r\n * @property {b2ShapeId} sensorShapeId - The id of the sensor shape\r\n * @property {b2ShapeId} visitorShapeId - The id of the dynamic shape that began touching the sensor shape\r\n */\r\nexport class b2SensorBeginTouchEvent\r\n{\r\n    constructor()\r\n    {\r\n        this.sensorShapeId = null;\r\n        this.visitorShapeId = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2SensorEndTouchEvent\r\n * @summary An end touch event is generated when a shape stops overlapping a sensor shape.\r\n * @property {b2ShapeId} sensorShapeId - The id of the sensor shape\r\n * @property {b2ShapeId} visitorShapeId - The id of the dynamic shape that stopped touching the sensor shape\r\n */\r\nexport class b2SensorEndTouchEvent\r\n{\r\n    constructor()\r\n    {\r\n        this.sensorShapeId = null;\r\n        this.visitorShapeId = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2SensorEvents\r\n * @summary Buffered sensor events from the Box2D world available after time step completion\r\n * @property {b2SensorBeginTouchEvent[]} beginEvents - Array of sensor begin touch events\r\n * @property {b2SensorEndTouchEvent[]} endEvents - Array of sensor end touch events\r\n * @property {number} beginCount - The number of begin touch events\r\n * @property {number} endCount - The number of end touch events\r\n */\r\nexport class b2SensorEvents\r\n{\r\n    constructor()\r\n    {\r\n        this.beginEvents = null;\r\n        this.endEvents = null;\r\n        this.beginCount = 0;\r\n        this.endCount = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ContactBeginTouchEvent\r\n * @summary A begin touch event is generated when two shapes begin touching.\r\n * @property {b2ShapeId} shapeIdA - Id of the first shape\r\n * @property {b2ShapeId} shapeIdB - Id of the second shape\r\n * @property {b2Manifold} manifold - The initial contact manifold\r\n */\r\nexport class b2ContactBeginTouchEvent\r\n{\r\n    constructor()\r\n    {\r\n        this.shapeIdA = null;\r\n        this.shapeIdB = null;\r\n        this.manifold = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ContactEndTouchEvent\r\n * @summary An end touch event is generated when two shapes stop touching.\r\n * @property {b2ShapeId} shapeIdA - Id of the first shape\r\n * @property {b2ShapeId} shapeIdB - Id of the second shape\r\n */\r\nexport class b2ContactEndTouchEvent\r\n{\r\n    constructor(a = null, b = null)\r\n    {\r\n        this.shapeIdA = a;\r\n        this.shapeIdB = b;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ContactHitEvent\r\n * @summary A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.\r\n * @property {b2ShapeId} shapeIdA - Id of the first shape\r\n * @property {b2ShapeId} shapeIdB - Id of the second shape\r\n * @property {b2Vec2} point - Point where the shapes hit\r\n * @property {b2Vec2} normal - Normal vector pointing from shape A to shape B\r\n * @property {number} approachSpeed - The speed the shapes are approaching. Always positive. Typically in meters per second.\r\n */\r\nexport class b2ContactHitEvent\r\n{\r\n    constructor()\r\n    {\r\n        this.shapeIdA = null;\r\n        this.shapeIdB = null;\r\n        this.pointX = 0;\r\n        this.pointY = 0;\r\n        this.normalX = 0;\r\n        this.normalY = 0;\r\n        this.approachSpeed = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ContactEvents\r\n * @summary Contact events buffered in the Box2D world available after time step completion\r\n * @property {b2ContactBeginTouchEvent[]} beginEvents - Array of begin touch events\r\n * @property {b2ContactEndTouchEvent[]} endEvents - Array of end touch events\r\n * @property {b2ContactHitEvent[]} hitEvents - Array of hit events\r\n * @property {number} beginCount - Number of begin touch events\r\n * @property {number} endCount - Number of end touch events\r\n * @property {number} hitCount - Number of hit events\r\n */\r\nexport class b2ContactEvents\r\n{\r\n    constructor()\r\n    {\r\n        this.beginEvents = null;\r\n        this.endEvents = null;\r\n        this.hitEvents = null;\r\n        this.beginCount = 0;\r\n        this.endCount = 0;\r\n        this.hitCount = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2BodyMoveEvent\r\n * @summary Body move events triggered during physics simulation. Provides efficient batch updates for moved bodies and sleep state changes.\r\n * @property {b2Transform} transform - The new transform of the moved body\r\n * @property {b2BodyId} bodyId - The identifier of the moved body\r\n * @property {void} userData - User data associated with the body\r\n * @property {boolean} fellAsleep - Indicates if the body transitioned to sleep state\r\n */\r\nexport class b2BodyMoveEvent\r\n{\r\n    constructor()\r\n    {\r\n        this.transform = null;\r\n        this.bodyId = null;\r\n        this.userData = null;\r\n        this.fellAsleep = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2BodyEvents\r\n * @summary Body events buffered in the Box2D world, available after time step completion\r\n * @property {b2BodyMoveEvent[]} moveEvents - Array of move events\r\n * @property {number} moveCount - Number of move events\r\n */\r\nexport class b2BodyEvents\r\n{\r\n    constructor()\r\n    {\r\n        this.moveEvents = null;\r\n        this.moveCount = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2ContactData\r\n * @summary The contact data for two shapes. By convention the manifold normal points from shape A to shape B.\r\n * @see b2Shape_GetContactData()\r\n * @see b2Body_GetContactData()\r\n * @property {b2ShapeId} shapeIdA - The identifier for the first shape\r\n * @property {b2ShapeId} shapeIdB - The identifier for the second shape\r\n * @property {b2Manifold} manifold - The contact manifold between the shapes\r\n */\r\nexport class b2ContactData\r\n{\r\n    constructor()\r\n    {\r\n        this.shapeIdA = null;\r\n        this.shapeIdB = null;\r\n        this.manifold = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Prototype for a contact filter callback.\r\n * This is called when a contact pair is considered for collision. This allows you to\r\n * perform custom logic to prevent collision between shapes. This is only called if\r\n * one of the two shapes has custom filtering enabled.\r\n *\r\n * **Notes:**\r\n * - This function must be thread-safe.\r\n * - This is only called if one of the two shapes has enabled custom filtering.\r\n * - This is called only for awake dynamic bodies.\r\n *\r\n * @warning Do not attempt to modify the world inside this callback.\r\n * @see b2ShapeDef\r\n * @ingroup world\r\n * @callback b2CustomFilterFcn\r\n * @param {b2ShapeId} shapeIdA - The first shape ID.\r\n * @param {b2ShapeId} shapeIdB - The second shape ID.\r\n * @param {any} context - User-defined context.\r\n * @returns {boolean} False to disable the collision.\r\n */\r\n\r\n/**\r\n * Prototype for a pre-solve callback.\r\n * This is called after a contact is updated. This allows you to inspect a\r\n * contact before it goes to the solver. If you are careful, you can modify the\r\n * contact manifold (e.g., modify the normal).\r\n *\r\n * **Notes:**\r\n * - This function must be thread-safe.\r\n * - This is only called if the shape has enabled pre-solve events.\r\n * - This is called only for awake dynamic bodies.\r\n * - This is not called for sensors.\r\n * - The supplied manifold has impulse values from the previous step.\r\n *\r\n * @warning Do not attempt to modify the world inside this callback.\r\n * @ingroup world\r\n * @callback b2PreSolveFcn\r\n * @param {b2ShapeId} shapeIdA - The first shape ID.\r\n * @param {b2ShapeId} shapeIdB - The second shape ID.\r\n * @param {b2Manifold} manifold - The contact manifold.\r\n * @param {any} context - User-defined context.\r\n * @returns {boolean} False to disable the contact this step.\r\n */\r\n\r\n/**\r\n * Prototype callback for overlap queries.\r\n * Called for each shape found in the query.\r\n *\r\n * @see b2World_OverlapABB\r\n * @ingroup world\r\n * @callback b2OverlapResultFcn\r\n * @param {b2ShapeId} shapeId - The shape ID found in the query.\r\n * @param {any} context - User-defined context.\r\n * @returns {boolean} False to terminate the query.\r\n */\r\n\r\n/**\r\n * Prototype callback for ray casts.\r\n * Called for each shape found in the query. You control how the ray cast proceeds by returning a float:\r\n *\r\n * - `-1`: Ignore this shape and continue.\r\n * - `0`: Terminate the ray cast.\r\n * - `fraction`: Clip the ray to this point.\r\n * - `1`: Don't clip the ray and continue.\r\n *\r\n * @see b2World_CastRay\r\n * @ingroup world\r\n * @callback b2CastResultFcn\r\n * @param {b2ShapeId} shapeId - The shape hit by the ray.\r\n * @param {b2Vec2} point - The point of initial intersection.\r\n * @param {b2Vec2} normal - The normal vector at the point of intersection.\r\n * @param {number} fraction - The fraction along the ray at the point of intersection.\r\n * @param {any} context - User-defined context.\r\n * @returns {number} - `-1` to filter, `0` to terminate, `fraction` to clip the ray for closest hit, `1` to continue.\r\n */\r\n\r\n\r\n/// These colors are used for debug draw and mostly match the named SVG colors.\r\n/// See https://www.rapidtables.com/web/color/index.html\r\n/// https://johndecember.com/html/spec/colorsvg.html\r\n/// https://upload.wikimedia.org/wikipedia/commons/2/2b/SVG_Recognized_color_keyword_names.svg\r\nexport const b2HexColor = {\r\n    b2_colorAliceBlue: 0xf0f8ff,\r\n    b2_colorAntiqueWhite: 0xfaebd7,\r\n    b2_colorAqua: 0x00ffff,\r\n    b2_colorAquamarine: 0x7fffd4,\r\n    b2_colorAzure: 0xf0ffff,\r\n    b2_colorBeige: 0xf5f5dc,\r\n    b2_colorBisque: 0xffe4c4,\r\n    b2_colorBlack: 0x000001,                // non-zero!\r\n    b2_colorBlanchedAlmond: 0xffebcd,\r\n    b2_colorBlue: 0x0000ff,\r\n    b2_colorBlueViolet: 0x8a2be2,\r\n    b2_colorBrown: 0xa52a2a,\r\n    b2_colorBurlywood: 0xdeb887,\r\n    b2_colorCadetBlue: 0x5f9ea0,\r\n    b2_colorChartreuse: 0x7fff00,\r\n    b2_colorChocolate: 0xd2691e,\r\n    b2_colorCoral: 0xff7f50,\r\n    b2_colorCornflowerBlue: 0x6495ed,\r\n    b2_colorCornsilk: 0xfff8dc,\r\n    b2_colorCrimson: 0xdc143c,\r\n    b2_colorCyan: 0x00ffff,\r\n    b2_colorDarkBlue: 0x00008b,\r\n    b2_colorDarkCyan: 0x008b8b,\r\n    b2_colorDarkGoldenrod: 0xb8860b,\r\n    b2_colorDarkGray: 0xa9a9a9,\r\n    b2_colorDarkGreen: 0x006400,\r\n    b2_colorDarkKhaki: 0xbdb76b,\r\n    b2_colorDarkMagenta: 0x8b008b,\r\n    b2_colorDarkOliveGreen: 0x556b2f,\r\n    b2_colorDarkOrange: 0xff8c00,\r\n    b2_colorDarkOrchid: 0x9932cc,\r\n    b2_colorDarkRed: 0x8b0000,\r\n    b2_colorDarkSalmon: 0xe9967a,\r\n    b2_colorDarkSeaGreen: 0x8fbc8f,\r\n    b2_colorDarkSlateBlue: 0x483d8b,\r\n    b2_colorDarkSlateGray: 0x2f4f4f,\r\n    b2_colorDarkTurquoise: 0x00ced1,\r\n    b2_colorDarkViolet: 0x9400d3,\r\n    b2_colorDeepPink: 0xff1493,\r\n    b2_colorDeepSkyBlue: 0x00bfff,\r\n    b2_colorDimGray: 0x696969,\r\n    b2_colorDodgerBlue: 0x1e90ff,\r\n    b2_colorFirebrick: 0xb22222,\r\n    b2_colorFloralWhite: 0xfffaf0,\r\n    b2_colorForestGreen: 0x228b22,\r\n    b2_colorFuchsia: 0xff00ff,\r\n    b2_colorGainsboro: 0xdcdcdc,\r\n    b2_colorGhostWhite: 0xf8f8ff,\r\n    b2_colorGold: 0xffd700,\r\n    b2_colorGoldenrod: 0xdaa520,\r\n    b2_colorGray: 0xbebebe,\r\n    b2_colorGray1: 0x1a1a1a,\r\n    b2_colorGray2: 0x333333,\r\n    b2_colorGray3: 0x4d4d4d,\r\n    b2_colorGray4: 0x666666,\r\n    b2_colorGray5: 0x7f7f7f,\r\n    b2_colorGray6: 0x999999,\r\n    b2_colorGray7: 0xb3b3b3,\r\n    b2_colorGray8: 0xcccccc,\r\n    b2_colorGray9: 0xe5e5e5,\r\n    b2_colorGreen: 0x00ff00,\r\n    b2_colorGreenYellow: 0xadff2f,\r\n    b2_colorHoneydew: 0xf0fff0,\r\n    b2_colorHotPink: 0xff69b4,\r\n    b2_colorIndianRed: 0xcd5c5c,\r\n    b2_colorIndigo: 0x4b0082,\r\n    b2_colorIvory: 0xfffff0,\r\n    b2_colorKhaki: 0xf0e68c,\r\n    b2_colorLavender: 0xe6e6fa,\r\n    b2_colorLavenderBlush: 0xfff0f5,\r\n    b2_colorLawnGreen: 0x7cfc00,\r\n    b2_colorLemonChiffon: 0xfffacd,\r\n    b2_colorLightBlue: 0xadd8e6,\r\n    b2_colorLightCoral: 0xf08080,\r\n    b2_colorLightCyan: 0xe0ffff,\r\n    b2_colorLightGoldenrod: 0xeedd82,\r\n    b2_colorLightGoldenrodYellow: 0xfafad2,\r\n    b2_colorLightGray: 0xd3d3d3,\r\n    b2_colorLightGreen: 0x90ee90,\r\n    b2_colorLightPink: 0xffb6c1,\r\n    b2_colorLightSalmon: 0xffa07a,\r\n    b2_colorLightSeaGreen: 0x20b2aa,\r\n    b2_colorLightSkyBlue: 0x87cefa,\r\n    b2_colorLightSlateBlue: 0x8470ff,\r\n    b2_colorLightSlateGray: 0x778899,\r\n    b2_colorLightSteelBlue: 0xb0c4de,\r\n    b2_colorLightYellow: 0xffffe0,\r\n    b2_colorLime: 0x00ff00,\r\n    b2_colorLimeGreen: 0x32cd32,\r\n    b2_colorLinen: 0xfaf0e6,\r\n    b2_colorMagenta: 0xff00ff,\r\n    b2_colorMaroon: 0xb03060,\r\n    b2_colorMediumAquamarine: 0x66cdaa,\r\n    b2_colorMediumBlue: 0x0000cd,\r\n    b2_colorMediumOrchid: 0xba55d3,\r\n    b2_colorMediumPurple: 0x9370db,\r\n    b2_colorMediumSeaGreen: 0x3cb371,\r\n    b2_colorMediumSlateBlue: 0x7b68ee,\r\n    b2_colorMediumSpringGreen: 0x00fa9a,\r\n    b2_colorMediumTurquoise: 0x48d1cc,\r\n    b2_colorMediumVioletRed: 0xc71585,\r\n    b2_colorMidnightBlue: 0x191970,\r\n    b2_colorMintCream: 0xf5fffa,\r\n    b2_colorMistyRose: 0xffe4e1,\r\n    b2_colorMoccasin: 0xffe4b5,\r\n    b2_colorNavajoWhite: 0xffdead,\r\n    b2_colorNavy: 0x000080,\r\n    b2_colorNavyBlue: 0x000080,\r\n    b2_colorOldLace: 0xfdf5e6,\r\n    b2_colorOlive: 0x808000,\r\n    b2_colorOliveDrab: 0x6b8e23,\r\n    b2_colorOrange: 0xffa500,\r\n    b2_colorOrangeRed: 0xff4500,\r\n    b2_colorOrchid: 0xda70d6,\r\n    b2_colorPaleGoldenrod: 0xeee8aa,\r\n    b2_colorPaleGreen: 0x98fb98,\r\n    b2_colorPaleTurquoise: 0xafeeee,\r\n    b2_colorPaleVioletRed: 0xdb7093,\r\n    b2_colorPapayaWhip: 0xffefd5,\r\n    b2_colorPeachPuff: 0xffdab9,\r\n    b2_colorPeru: 0xcd853f,\r\n    b2_colorPink: 0xffc0cb,\r\n    b2_colorPlum: 0xdda0dd,\r\n    b2_colorPowderBlue: 0xb0e0e6,\r\n    b2_colorPurple: 0xa020f0,\r\n    b2_colorRebeccaPurple: 0x663399,\r\n    b2_colorRed: 0xff0000,\r\n    b2_colorRosyBrown: 0xbc8f8f,\r\n    b2_colorRoyalBlue: 0x4169e1,\r\n    b2_colorSaddleBrown: 0x8b4513,\r\n    b2_colorSalmon: 0xfa8072,\r\n    b2_colorSandyBrown: 0xf4a460,\r\n    b2_colorSeaGreen: 0x2e8b57,\r\n    b2_colorSeashell: 0xfff5ee,\r\n    b2_colorSienna: 0xa0522d,\r\n    b2_colorSilver: 0xc0c0c0,\r\n    b2_colorSkyBlue: 0x87ceeb,\r\n    b2_colorSlateBlue: 0x6a5acd,\r\n    b2_colorSlateGray: 0x708090,\r\n    b2_colorSnow: 0xfffafa,\r\n    b2_colorSpringGreen: 0x00ff7f,\r\n    b2_colorSteelBlue: 0x4682b4,\r\n    b2_colorTan: 0xd2b48c,\r\n    b2_colorTeal: 0x008080,\r\n    b2_colorThistle: 0xd8bfd8,\r\n    b2_colorTomato: 0xff6347,\r\n    b2_colorTurquoise: 0x40e0d0,\r\n    b2_colorViolet: 0xee82ee,\r\n    b2_colorVioletRed: 0xd02090,\r\n    b2_colorWheat: 0xf5deb3,\r\n    b2_colorWhite: 0xffffff,\r\n    b2_colorWhiteSmoke: 0xf5f5f5,\r\n    b2_colorYellow: 0xffff00,\r\n    b2_colorYellowGreen: 0x9acd32,\r\n    b2_colorBox2DRed: 0xdc3132,\r\n    b2_colorBox2DBlue: 0x30aebf,\r\n    b2_colorBox2DGreen: 0x8cc924,\r\n    b2_colorBox2DYellow: 0xffee8c\r\n};\r\n\r\n/**\r\n * @class b2DebugDraw\r\n * @summary Callbacks and options for debug rendering of a Box2D world\r\n * @property {function(b2Vec2, string, *): void} DrawString - Draw a string\r\n * @property {b2AABB} drawingBounds - Bounds to use if restricting drawing to a rectangular region\r\n * @property {boolean} useDrawingBounds - Option to restrict drawing to a rectangular region. May suffer from unstable depth sorting\r\n * @property {boolean} drawShapes - Option to draw shapes\r\n * @property {boolean} drawJoints - Option to draw joints\r\n * @property {boolean} drawJointExtras - Option to draw additional information for joints\r\n * @property {boolean} drawAABBs - Option to draw the bounding boxes for shapes\r\n * @property {boolean} drawMass - Option to draw the mass and center of mass of dynamic bodies\r\n * @property {boolean} drawContacts - Option to draw contact points\r\n * @property {boolean} drawGraphColors - Option to visualize the graph coloring used for contacts and joints\r\n * @property {boolean} drawContactNormals - Option to draw contact normals\r\n * @property {boolean} drawContactImpulses - Option to draw contact normal impulses\r\n * @property {boolean} drawFrictionImpulses - Option to draw contact friction impulses\r\n * @property {*} context - User context that is passed as an argument to drawing callback functions\r\n */\r\nexport class b2DebugDraw\r\n{\r\n    constructor()\r\n    {\r\n        this.DrawPolygon = null;\r\n        this.DrawImagePolygon = null;\r\n        this.DrawSolidPolygon = null;\r\n        this.DrawCircle = null;\r\n        this.DrawImageCircle = null;\r\n        this.DrawSolidCircle = null;\r\n        this.DrawCapsule = null;\r\n        this.DrawImageCapsule = null;\r\n        this.DrawSolidCapsule = null;\r\n        this.DrawSegment = null;\r\n        this.DrawTransform = null;\r\n        this.DrawPoint = null;\r\n        this.DrawString = null;\r\n        this.SetPosition = null;\r\n        this.drawingBounds = new b2AABB();\r\n        this.useDrawingBounds = false;          // PJB: not fully implemented in debug_draw.js\r\n        this.positionOffset = new b2Vec2();\r\n        this.drawShapes = true;\r\n        this.drawJoints = false;\r\n        this.drawAABBs = false;\r\n        this.drawMass = false;\r\n        this.drawContacts = false;\r\n        this.drawGraphColors = false;\r\n        this.drawContactNormals = false;\r\n        this.drawContactImpulses = false;\r\n        this.drawFrictionImpulses = false;\r\n        this.context = null;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2Filter\r\n * @summary Used to filter collision on shapes. Affects shape-vs-shape collision and shape-versus-query collision.\r\n * @property {number} categoryBits - The collision category bits. Normally you would just set one bit.\r\n * The category bits should represent your application object types.\r\n * @property {number} maskBits - The collision mask bits. States the categories that this shape would\r\n * accept for collision.\r\n * @property {number} groupIndex - Collision groups allow a certain group of objects to never collide\r\n * (negative) or always collide (positive). Zero has no effect. Non-zero group filtering always wins\r\n * against the mask bits.\r\n */\r\nexport class b2Filter\r\n{\r\n    constructor()\r\n    {\r\n        this.categoryBits = 0x0001;\r\n        this.maskBits = 0xFFFF;\r\n        this.groupIndex = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @class b2QueryFilter\r\n * @summary Filter used to control collision detection between queries and shapes\r\n * @property {number} categoryBits - The collision category bits of this query. Normally you would just set one bit.\r\n * @property {number} maskBits - The collision mask bits. This states the shape categories that this query would accept for collision.\r\n */\r\nexport class b2QueryFilter\r\n{\r\n    constructor()\r\n    {\r\n        this.categoryBits = 0xFFFF;\r\n        this.maskBits = 0xFFFF;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Validation } from './include/types_h.js';\r\n\r\n/**\r\n * @namespace IDPool\r\n */\r\n\r\nexport class b2IdPool\r\n{\r\n    constructor(name)\r\n    {\r\n        this.name = name;\r\n        this.freeArray = [];\r\n        this.nextIndex = 0;\r\n    }\r\n}\r\n\r\nexport function b2GetIdCapacity(pool)\r\n{\r\n    return pool.nextIndex;\r\n}\r\n\r\nexport function b2CreateIdPool(name = 'pool')\r\n{\r\n    return new b2IdPool(name);\r\n}\r\n\r\nexport function b2DestroyIdPool(pool)\r\n{\r\n    pool.freeArray = null;\r\n    pool.nextIndex = 0;\r\n}\r\n\r\nexport function b2AllocId(pool)\r\n{\r\n    if (pool.freeArray.length > 0)\r\n    {\r\n        return pool.freeArray.pop();\r\n    }\r\n\r\n    const id = pool.nextIndex;\r\n    pool.nextIndex++;\r\n\r\n    return id;\r\n}\r\n\r\nexport function b2FreeId(pool, id)\r\n{\r\n    if (id === pool.nextIndex - 1)\r\n    {\r\n        pool.nextIndex--;\r\n\r\n        return;\r\n    }\r\n\r\n    pool.freeArray.push(id);\r\n}\r\n\r\nexport function b2GetIdCount(pool)\r\n{\r\n    return pool.nextIndex - pool.freeArray.length;\r\n}\r\n\r\nexport function b2ValidateFreeId(pool, id)\r\n{\r\n    if (!b2Validation) { return; }\r\n\r\n    const freeCount = pool.freeArray.length;\r\n\r\n    if (id == pool.nextIndex)\r\n    { return; }\r\n    \r\n    for (let i = 0; i < freeCount; ++i)\r\n    {\r\n        if (pool.freeArray[i] == id)\r\n        {\r\n            return;\r\n        }\r\n    }\r\n\r\n    console.warn(\"pool \" + pool.constructor.name + \" has no free Id \" + id);\r\n    console.warn(pool.freeArray);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    B2_MAX_POLYGON_VERTICES,\r\n    b2CastOutput,\r\n    b2DistanceCache,\r\n    b2DistanceInput,\r\n    b2DistanceOutput,\r\n    b2DistanceProxy,\r\n    b2SegmentDistanceResult,\r\n    b2Simplex,\r\n    b2SimplexVertex,\r\n    b2Sweep,\r\n    b2TOIOutput,\r\n    b2TOIState\r\n} from './include/collision_h.js';\r\nimport {\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2CrossVS,\r\n    b2Distance,\r\n    b2Dot,\r\n    b2InvMulTransforms,\r\n    b2InvRotateVector,\r\n    b2IsNormalized,\r\n    b2LeftPerp,\r\n    b2Length,\r\n    b2MulSV,\r\n    b2Neg,\r\n    b2Normalize,\r\n    b2NormalizeRot,\r\n    b2RightPerp,\r\n    b2Rot,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2Vec2,\r\n    eps,\r\n    epsSqr\r\n} from './include/math_functions_h.js';\r\n\r\nimport { b2_linearSlop } from './include/core_h.js';\r\n\r\n/**\r\n * @namespace Distance\r\n */\r\n\r\n/**\r\n * @import {b2ShapeCastPairInput, b2TOIInput} from './include/collision_h'\r\n */\r\n\r\n/**\r\n * @function b2GetSweepTransform\r\n * @summary Computes an interpolated transform at a specified time during a sweep motion.\r\n * @param {b2Sweep} sweep - A sweep object containing initial (c1, q1) and final (c2, q2)\r\n * positions and rotations, along with a local center offset.\r\n * @param {number} time - Interpolation factor between 0 and 1, where 0 represents the initial\r\n * state and 1 represents the final state.\r\n * @returns {b2Transform} A transform object containing the interpolated position (p) and\r\n * rotation (q) at the specified time.\r\n * @description\r\n * Calculates an intermediate transform by linearly interpolating between two states\r\n * defined in a sweep motion. The resulting transform accounts for both translation\r\n * and rotation, adjusted by the local center offset.\r\n */\r\nexport function b2GetSweepTransform(sweep, time)\r\n{\r\n    const xf = new b2Transform();\r\n    xf.p = b2Add(b2MulSV(1.0 - time, sweep.c1), b2MulSV(time, sweep.c2));\r\n\r\n    const q = new b2Rot((1.0 - time) * sweep.q1.c + time * sweep.q2.c,\r\n        (1.0 - time) * sweep.q1.s + time * sweep.q2.s);\r\n\r\n    xf.q = b2NormalizeRot(q);\r\n    \r\n    xf.p = b2Sub(xf.p, b2RotateVector(xf.q, sweep.localCenter));\r\n\r\n    return xf;\r\n}\r\n\r\n/**\r\n * @function b2SegmentDistance\r\n * @description\r\n * Calculates the minimum distance between two line segments defined by their endpoints.\r\n * @param {number} p1X - X coordinate of the first point of segment 1\r\n * @param {number} p1Y - Y coordinate of the first point of segment 1\r\n * @param {number} q1X - X coordinate of the second point of segment 1\r\n * @param {number} q1Y - Y coordinate of the second point of segment 1\r\n * @param {number} p2X - X coordinate of the first point of segment 2\r\n * @param {number} p2Y - Y coordinate of the first point of segment 2\r\n * @param {number} q2X - X coordinate of the second point of segment 2\r\n * @param {number} q2Y - Y coordinate of the second point of segment 2\r\n * @returns {b2SegmentDistanceResult} An object containing:\r\n * - fraction1: {number} Parameter along segment 1 for closest point (0-1)\r\n * - fraction2: {number} Parameter along segment 2 for closest point (0-1)\r\n * - distanceSquared: {number} Square of the minimum distance between segments\r\n */\r\nconst sdResult = new b2SegmentDistanceResult();\r\n\r\nexport function b2SegmentDistance(p1X, p1Y, q1X, q1Y, p2X, p2Y, q2X, q2Y)\r\n{\r\n    let fraction1 = 0;\r\n    let fraction2 = 0;\r\n\r\n    const d1X = q1X - p1X;\r\n    const d1Y = q1Y - p1Y;\r\n    const d2X = q2X - p2X;\r\n    const d2Y = q2Y - p2Y;\r\n    const rX = p1X - p2X;\r\n    const rY = p1Y - p2Y;\r\n    const dd1 = d1X * d1X + d1Y * d1Y;\r\n    const dd2 = d2X * d2X + d2Y * d2Y;\r\n    const rd2 = rX * d2X + rY * d2Y;\r\n    const rd1 = rX * d1X + rY * d1Y;\r\n\r\n    if (dd1 < epsSqr || dd2 < epsSqr)\r\n    {\r\n        if (dd1 >= epsSqr)\r\n        {\r\n            fraction1 = b2ClampFloat(-rd1 / dd1, 0.0, 1.0);\r\n            fraction2 = 0.0;\r\n        }\r\n        else if (dd2 >= epsSqr)\r\n        {\r\n            fraction1 = 0.0;\r\n            fraction2 = b2ClampFloat(rd2 / dd2, 0.0, 1.0);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const d12 = d1X * d2X + d1Y * d2Y;\r\n        const denom = dd1 * dd2 - d12 * d12;\r\n\r\n        let f1 = 0.0;\r\n\r\n        if (denom !== 0.0)\r\n        {\r\n            f1 = b2ClampFloat((d12 * rd2 - rd1 * dd2) / denom, 0.0, 1.0);\r\n        }\r\n\r\n        let f2 = (d12 * f1 + rd2) / dd2;\r\n\r\n        if (f2 < 0.0)\r\n        {\r\n            f2 = 0.0;\r\n            f1 = b2ClampFloat(-rd1 / dd1, 0.0, 1.0);\r\n        }\r\n        else if (f2 > 1.0)\r\n        {\r\n            f2 = 1.0;\r\n            f1 = b2ClampFloat((d12 - rd1) / dd1, 0.0, 1.0);\r\n        }\r\n\r\n        fraction1 = f1;\r\n        fraction2 = f2;\r\n    }\r\n\r\n    const closest1X = p1X + fraction1 * d1X;\r\n    const closest1Y = p1Y + fraction1 * d1Y;\r\n    const closest2X = p2X + fraction2 * d2X;\r\n    const closest2Y = p2Y + fraction2 * d2Y;\r\n    \r\n    const dX = closest1X - closest2X;\r\n    const dY = closest1Y - closest2Y;\r\n    const distanceSquared = dX * dX + dY * dY;\r\n\r\n    sdResult.closest1 = sdResult.closest2 = null;\r\n    sdResult.fraction1 = fraction1;\r\n    sdResult.fraction2 = fraction2;\r\n    sdResult.distanceSquared = distanceSquared;\r\n\r\n    return sdResult;\r\n}\r\n\r\n/**\r\n * @function b2MakeProxy\r\n * @summary Creates a distance proxy from a set of vertices\r\n * @param {b2Vec2[]} vertices - Array of 2D vectors representing the vertices\r\n * @param {number} count - Number of vertices to process (max B2_MAX_POLYGON_VERTICES)\r\n * @param {number} radius - Radius value for the proxy\r\n * @returns {b2DistanceProxy} A new distance proxy containing the processed vertices\r\n * @throws {Error} Throws assertion error if count exceeds B2_MAX_POLYGON_VERTICES\r\n */\r\nexport function b2MakeProxy(vertices, count, radius)\r\n{\r\n    console.assert(count <= B2_MAX_POLYGON_VERTICES);\r\n    \r\n    count = Math.min(count, B2_MAX_POLYGON_VERTICES);\r\n    \r\n    const proxy = new b2DistanceProxy();\r\n    proxy.points = [];\r\n    proxy.count = count;\r\n    proxy.radius = radius;\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        proxy.points[i] = vertices[i].clone();\r\n    }\r\n\r\n    return proxy;\r\n}\r\n\r\nfunction b2Weight2(a1, w1, a2, w2)\r\n{\r\n    return new b2Vec2(a1 * w1.x + a2 * w2.x, a1 * w1.y + a2 * w2.y);\r\n}\r\n\r\nfunction b2Weight3(a1, w1, a2, w2, a3, w3)\r\n{\r\n    return new b2Vec2(a1 * w1.x + a2 * w2.x + a3 * w3.x, a1 * w1.y + a2 * w2.y + a3 * w3.y);\r\n}\r\n\r\nfunction b2FindSupport(proxy, direction)\r\n{\r\n    let bestIndex = 0;\r\n    let bestValue = b2Dot(proxy.points[0], direction);\r\n\r\n    for (let i = 1; i < proxy.count; ++i)\r\n    {\r\n        const value = b2Dot(proxy.points[i], direction);\r\n\r\n        if (value > bestValue)\r\n        {\r\n            bestIndex = i;\r\n            bestValue = value;\r\n        }\r\n    }\r\n\r\n    return bestIndex;\r\n}\r\n\r\nfunction b2MakeSimplexFromCache(cache, proxyA, transformA, proxyB, transformB)\r\n{\r\n    const s = new b2Simplex();\r\n    s.count = cache.count;\r\n\r\n    const vertices = [ s.v1, s.v2, s.v3 ];\r\n\r\n    for (let i = 0; i < s.count; ++i)\r\n    {\r\n        const v = vertices[i];\r\n        v.indexA = cache.indexA[i];\r\n        v.indexB = cache.indexB[i];\r\n        const wALocal = proxyA.points[v.indexA];\r\n        const wBLocal = proxyB.points[v.indexB];\r\n        v.wA = b2TransformPoint(transformA, wALocal);\r\n        v.wB = b2TransformPoint(transformB, wBLocal);\r\n        v.w = b2Sub(v.wB, v.wA);\r\n        v.a = -1.0;\r\n    }\r\n\r\n    if (s.count === 0)\r\n    {\r\n        const v = vertices[0];\r\n        v.indexA = 0;\r\n        v.indexB = 0;\r\n        const wALocal = proxyA.points[0];\r\n        const wBLocal = proxyB.points[0];\r\n        v.wA = b2TransformPoint(transformA, wALocal);\r\n        v.wB = b2TransformPoint(transformB, wBLocal);\r\n        v.w = b2Sub(v.wB, v.wA);\r\n        v.a = 1.0;\r\n        s.count = 1;\r\n    }\r\n\r\n    return s;\r\n}\r\n\r\nfunction b2MakeSimplexCache(cache, simplex)\r\n{\r\n    cache.count = simplex.count;\r\n    const vertices = [ simplex.v1, simplex.v2, simplex.v3 ];\r\n\r\n    for (let i = 0; i < simplex.count; ++i)\r\n    {\r\n        cache.indexA[i] = vertices[i].indexA;\r\n        cache.indexB[i] = vertices[i].indexB;\r\n    }\r\n}\r\n\r\nfunction b2ComputeSimplexSearchDirection(simplex)\r\n{\r\n    switch (simplex.count)\r\n    {\r\n        case 1:\r\n            return b2Neg(simplex.v1.w);\r\n\r\n        case 2:\r\n            const e12 = b2Sub(simplex.v2.w, simplex.v1.w);\r\n            const sgn = b2Cross(e12, b2Neg(simplex.v1.w));\r\n\r\n            if (sgn > 0.0)\r\n            {\r\n                return b2LeftPerp(e12);\r\n            }\r\n            else\r\n            {\r\n                return b2RightPerp(e12);\r\n            }\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new b2Vec2(0, 0);\r\n    }\r\n}\r\n\r\nfunction b2ComputeSimplexClosestPoint(s)\r\n{\r\n    switch (s.count)\r\n    {\r\n        case 0:\r\n            console.assert(false);\r\n\r\n            return new b2Vec2(0, 0);\r\n\r\n        case 1:\r\n            return s.v1.w;\r\n\r\n        case 2:\r\n            return b2Weight2(s.v1.a, s.v1.w, s.v2.a, s.v2.w);\r\n\r\n        case 3:\r\n            return new b2Vec2(0, 0);\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new b2Vec2(0, 0);\r\n    }\r\n}\r\n\r\nfunction b2ComputeSimplexWitnessPoints(a, b, s)\r\n{\r\n    switch (s.count)\r\n    {\r\n        case 0:\r\n            console.assert(false);\r\n\r\n            break;\r\n\r\n        case 1:\r\n            a.x = s.v1.wA.x;\r\n            a.y = s.v1.wA.y;\r\n            b.x = s.v1.wB.x;\r\n            b.y = s.v1.wB.y;\r\n\r\n            break;\r\n\r\n        case 2:\r\n            a.x = b2Weight2(s.v1.a, s.v1.wA, s.v2.a, s.v2.wA).x;\r\n            a.y = b2Weight2(s.v1.a, s.v1.wA, s.v2.a, s.v2.wA).y;\r\n            b.x = b2Weight2(s.v1.a, s.v1.wB, s.v2.a, s.v2.wB).x;\r\n            b.y = b2Weight2(s.v1.a, s.v1.wB, s.v2.a, s.v2.wB).y;\r\n\r\n            break;\r\n\r\n        case 3:\r\n            a.x = b2Weight3(s.v1.a, s.v1.wA, s.v2.a, s.v2.wA, s.v3.a, s.v3.wA).x;\r\n            a.y = b2Weight3(s.v1.a, s.v1.wA, s.v2.a, s.v2.wA, s.v3.a, s.v3.wA).y;\r\n            b.x = a.x;\r\n            b.y = a.y;\r\n\r\n            break;\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            break;\r\n    }\r\n}\r\n\r\nfunction b2SolveSimplex2(s)\r\n{\r\n    const w1 = s.v1.w;\r\n    const w2 = s.v2.w;\r\n    const e12 = b2Sub(w2, w1);\r\n\r\n    const d12_2 = -b2Dot(w1, e12);\r\n\r\n    if (d12_2 <= 0.0)\r\n    {\r\n        s.v1.a = 1.0;\r\n        s.count = 1;\r\n\r\n        return;\r\n    }\r\n\r\n    const d12_1 = b2Dot(w2, e12);\r\n\r\n    if (d12_1 <= 0.0)\r\n    {\r\n        s.v2.a = 1.0;\r\n        s.count = 1;\r\n        s.v1 = s.v2;\r\n\r\n        return;\r\n    }\r\n\r\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\r\n    s.v1.a = d12_1 * inv_d12;\r\n    s.v2.a = d12_2 * inv_d12;\r\n    s.count = 2;\r\n}\r\n\r\nfunction b2SolveSimplex3(s)\r\n{\r\n    const w1 = s.v1.w;\r\n    const w2 = s.v2.w;\r\n    const w3 = s.v3.w;\r\n\r\n    const e12 = b2Sub(w2, w1);\r\n    const w1e12 = b2Dot(w1, e12);\r\n    const w2e12 = b2Dot(w2, e12);\r\n    const d12_1 = w2e12;\r\n    const d12_2 = -w1e12;\r\n\r\n    const e13 = b2Sub(w3, w1);\r\n    const w1e13 = b2Dot(w1, e13);\r\n    const w3e13 = b2Dot(w3, e13);\r\n    const d13_1 = w3e13;\r\n    const d13_2 = -w1e13;\r\n\r\n    const e23 = b2Sub(w3, w2);\r\n    const w2e23 = b2Dot(w2, e23);\r\n    const w3e23 = b2Dot(w3, e23);\r\n    const d23_1 = w3e23;\r\n    const d23_2 = -w2e23;\r\n\r\n    const n123 = b2Cross(e12, e13);\r\n\r\n    const d123_1 = n123 * b2Cross(w2, w3);\r\n    const d123_2 = n123 * b2Cross(w3, w1);\r\n    const d123_3 = n123 * b2Cross(w1, w2);\r\n\r\n    if (d12_2 <= 0.0 && d13_2 <= 0.0)\r\n    {\r\n        s.v1.a = 1.0;\r\n        s.count = 1;\r\n\r\n        return;\r\n    }\r\n\r\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0)\r\n    {\r\n        const inv_d12 = 1.0 / (d12_1 + d12_2);\r\n        s.v1.a = d12_1 * inv_d12;\r\n        s.v2.a = d12_2 * inv_d12;\r\n        s.count = 2;\r\n\r\n        return;\r\n    }\r\n\r\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0)\r\n    {\r\n        const inv_d13 = 1.0 / (d13_1 + d13_2);\r\n        s.v1.a = d13_1 * inv_d13;\r\n        s.v3.a = d13_2 * inv_d13;\r\n        s.count = 2;\r\n        s.v2 = s.v3.clone();\r\n\r\n        return;\r\n    }\r\n\r\n    if (d12_1 <= 0.0 && d23_2 <= 0.0)\r\n    {\r\n        s.v2.a = 1.0;\r\n        s.count = 1;\r\n        s.v1 = s.v2.clone();\r\n\r\n        return;\r\n    }\r\n\r\n    if (d13_1 <= 0.0 && d23_1 <= 0.0)\r\n    {\r\n        s.v3.a = 1.0;\r\n        s.count = 1;\r\n        s.v1 = s.v3.clone();\r\n\r\n        return;\r\n    }\r\n\r\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0)\r\n    {\r\n        const inv_d23 = 1.0 / (d23_1 + d23_2);\r\n        s.v2.a = d23_1 * inv_d23;\r\n        s.v3.a = d23_2 * inv_d23;\r\n        s.count = 2;\r\n        s.v1 = s.v3.clone();\r\n\r\n        return;\r\n    }\r\n\r\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\r\n    s.v1.a = d123_1 * inv_d123;\r\n    s.v2.a = d123_2 * inv_d123;\r\n    s.v3.a = d123_3 * inv_d123;\r\n    s.count = 3;\r\n}\r\n\r\nconst p0 = new b2Vec2();\r\n\r\n/**\r\n * @function b2ShapeDistance\r\n * @description\r\n * Computes the distance between two convex shapes using the GJK (Gilbert-Johnson-Keerthi) algorithm.\r\n * @param {b2DistanceCache} cache - Cache object to store and retrieve simplex data between calls\r\n * @param {b2DistanceInput} input - Input parameters containing:\r\n * - proxyA: First shape proxy\r\n * - proxyB: Second shape proxy\r\n * - transformA: Transform for first shape\r\n * - transformB: Transform for second shape\r\n * - useRadii: Boolean flag for including shape radii in calculation\r\n * @param {b2Simplex[]} simplexes - Optional array to store simplex history\r\n * @param {number} simplexCapacity - Maximum number of simplexes to store\r\n * @returns {b2DistanceOutput} Output containing:\r\n * - pointA: Closest point on shape A\r\n * - pointB: Closest point on shape B\r\n * - distance: Distance between the shapes\r\n * - iterations: Number of iterations performed\r\n * - simplexCount: Number of simplexes stored\r\n */\r\nexport function b2ShapeDistance(cache, input, simplexes, simplexCapacity)\r\n{\r\n    const output = new b2DistanceOutput();\r\n\r\n    const proxyA = input.proxyA;\r\n    const proxyB = input.proxyB;\r\n\r\n    const transformA = input.transformA;\r\n    const transformB = input.transformB;\r\n\r\n    const simplex = b2MakeSimplexFromCache(cache, proxyA, transformA, proxyB, transformB);\r\n\r\n    let simplexIndex = 0;\r\n\r\n    if (simplexes !== null && simplexIndex < simplexCapacity)\r\n    {\r\n        simplexes[simplexIndex] = simplex;\r\n        simplexIndex += 1;\r\n    }\r\n\r\n    const vertices = [ simplex.v1, simplex.v2, simplex.v3 ];\r\n    const k_maxIters = 20;\r\n\r\n    const saveA = [ 0, 0, 0 ];\r\n    const saveB = [ 0, 0, 0 ];\r\n\r\n    console.assert(simplex.v2 !== simplex.v3);\r\n\r\n    let iter = 0;\r\n\r\n    while (iter < k_maxIters)\r\n    {\r\n        const saveCount = simplex.count;\r\n\r\n        for (let i = 0; i < saveCount; ++i)\r\n        {\r\n            saveA[i] = vertices[i].indexA;\r\n            saveB[i] = vertices[i].indexB;\r\n        }\r\n\r\n        switch (simplex.count)\r\n        {\r\n            case 1:\r\n                break;\r\n\r\n            case 2:\r\n                b2SolveSimplex2(simplex);\r\n\r\n                break;\r\n\r\n            case 3:\r\n                b2SolveSimplex3(simplex);\r\n\r\n                break;\r\n\r\n            default:\r\n                console.assert(false);\r\n\r\n                break;\r\n        }\r\n\r\n        if (simplex.count === 3)\r\n        {\r\n            break;\r\n        }\r\n\r\n        if (simplexes !== null && simplexIndex < simplexCapacity)\r\n        {\r\n            simplexes[simplexIndex] = simplex;\r\n            simplexIndex += 1;\r\n        }\r\n\r\n        const d = b2ComputeSimplexSearchDirection(simplex);\r\n\r\n        if (b2Dot(d, d) < eps * eps)\r\n        {\r\n            break;\r\n        }\r\n\r\n        const vertex = vertices[simplex.count];\r\n        vertex.indexA = b2FindSupport(proxyA, b2InvRotateVector(transformA.q, b2Neg(d)));\r\n        vertex.wA = b2TransformPoint(transformA, proxyA.points[vertex.indexA]);\r\n        vertex.indexB = b2FindSupport(proxyB, b2InvRotateVector(transformB.q, d));\r\n        vertex.wB = b2TransformPoint(transformB, proxyB.points[vertex.indexB]);\r\n        vertex.w = b2Sub(vertex.wB, vertex.wA);\r\n\r\n        ++iter;\r\n\r\n        let duplicate = false;\r\n\r\n        for (let i = 0; i < saveCount; ++i)\r\n        {\r\n            if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i])\r\n            {\r\n                duplicate = true;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (duplicate)\r\n        {\r\n            break;\r\n        }\r\n\r\n        ++simplex.count;\r\n    }\r\n\r\n    if (simplexes !== null && simplexIndex < simplexCapacity)\r\n    {\r\n        simplexes[simplexIndex] = simplex;\r\n        simplexIndex += 1;\r\n    }\r\n\r\n    b2ComputeSimplexWitnessPoints(output.pointA, output.pointB, simplex);\r\n    output.distance = b2Distance(output.pointA, output.pointB);\r\n    output.iterations = iter;\r\n    output.simplexCount = simplexIndex;\r\n\r\n    b2MakeSimplexCache(cache, simplex);\r\n\r\n    if (input.useRadii)\r\n    {\r\n        if (output.distance < eps)\r\n        {\r\n            p0.x = 0.5 * (output.pointA.x + output.pointB.x);\r\n            p0.y = 0.5 * (output.pointA.y + output.pointB.y);\r\n            output.pointA.x = p0.x;\r\n            output.pointA.y = p0.y;\r\n            output.pointB.x = p0.x;\r\n            output.pointB.y = p0.y;\r\n            output.distance = 0.0;\r\n        }\r\n        else\r\n        {\r\n            const rA = proxyA.radius;\r\n            const rB = proxyB.radius;\r\n            output.distance = Math.max(0.0, output.distance - rA - rB);\r\n            const normal = b2Normalize(b2Sub(output.pointB, output.pointA));\r\n            const offsetAX = rA * normal.x;\r\n            const offsetAY = rA * normal.y;\r\n            const offsetBX = rB * normal.x;\r\n            const offsetBY = rB * normal.y;\r\n            output.pointA.x += offsetAX;\r\n            output.pointA.y += offsetAY;\r\n            output.pointB.x -= offsetBX;\r\n            output.pointB.y -= offsetBY;\r\n        }\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\nconst rayPoint = new b2Vec2(0, 0);\r\nconst rayNormal = new b2Vec2(0, 1);\r\n\r\n/**\r\n * @function b2ShapeCast\r\n * @summary Performs a shape cast between two convex shapes to detect collision.\r\n * @param {b2ShapeCastPairInput} input - Contains:\r\n * proxyA - First shape proxy\r\n * proxyB - Second shape proxy\r\n * transformA - Transform of first shape\r\n * transformB - Transform of second shape\r\n * translationB - Translation vector for second shape\r\n * maxFraction - Maximum fraction of motion to check\r\n * @returns {b2CastOutput} Contains:\r\n * fraction - Time of impact fraction [0,maxFraction]\r\n * point - Point of impact\r\n * normal - Surface normal at impact\r\n * iterations - Number of iterations used\r\n * hit - Whether a collision was detected\r\n * @description\r\n * Uses an iterative algorithm to determine if and when two convex shapes will collide\r\n * during a linear motion. Shape B is translated while shape A remains stationary.\r\n * The algorithm uses support points and simplexes to determine the closest points\r\n * between the shapes.\r\n */\r\nexport function b2ShapeCast(input)\r\n{\r\n    const output = new b2CastOutput(rayNormal, rayPoint);\r\n    output.fraction = input.maxFraction;\r\n\r\n    const proxyA = input.proxyA;\r\n\r\n    const xfA = input.transformA;\r\n    const xfB = input.transformB;\r\n    const xf = b2InvMulTransforms(xfA, xfB);\r\n\r\n    const proxyB = new b2DistanceProxy();\r\n    proxyB.count = input.proxyB.count;\r\n    proxyB.radius = input.proxyB.radius;\r\n    proxyB.points = [];\r\n\r\n    for (let i = 0; i < proxyB.count; ++i)\r\n    {\r\n        proxyB.points[i] = b2TransformPoint(xf, input.proxyB.points[i]);\r\n    }\r\n\r\n    const radius = proxyA.radius + proxyB.radius;\r\n\r\n    const r = b2RotateVector(xf.q, input.translationB);\r\n    let lambda = 0.0;\r\n    const maxFraction = input.maxFraction;\r\n\r\n    const simplex = new b2Simplex();\r\n    simplex.count = 0;\r\n    simplex.v1 = new b2SimplexVertex();\r\n    simplex.v2 = new b2SimplexVertex();\r\n    simplex.v3 = new b2SimplexVertex();\r\n\r\n    const vertices = [ simplex.v1, simplex.v2, simplex.v3 ];\r\n\r\n    let indexA = b2FindSupport(proxyA, b2Neg(r));\r\n    let wA = proxyA.points[indexA];\r\n    let indexB = b2FindSupport(proxyB, r);\r\n    let wB = proxyB.points[indexB];\r\n    let v = b2Sub(wA, wB);\r\n\r\n    const linearSlop = 0.005;\r\n    const sigma = Math.max(linearSlop, radius - linearSlop);\r\n\r\n    const k_maxIters = 20;\r\n    let iter = 0;\r\n\r\n    while (iter < k_maxIters && b2Length(v) > sigma + 0.5 * linearSlop)\r\n    {\r\n        console.assert(simplex.count < 3);\r\n\r\n        output.iterations += 1;\r\n\r\n        indexA = b2FindSupport(proxyA, b2Neg(v));\r\n        wA = proxyA.points[indexA];\r\n        indexB = b2FindSupport(proxyB, v);\r\n        wB = proxyB.points[indexB];\r\n        const p = b2Sub(wA, wB);\r\n\r\n        v = b2Normalize(v);\r\n\r\n        const vp = b2Dot(v, p);\r\n        const vr = b2Dot(v, r);\r\n\r\n        if (vp - sigma > lambda * vr)\r\n        {\r\n            if (vr <= 0.0)\r\n            {\r\n                return output;\r\n            }\r\n\r\n            lambda = (vp - sigma) / vr;\r\n\r\n            if (lambda > maxFraction)\r\n            {\r\n                return output;\r\n            }\r\n\r\n            simplex.count = 0;\r\n        }\r\n\r\n        const vertex = vertices[simplex.count];\r\n        vertex.indexA = indexB;\r\n        vertex.wA = new b2Vec2(wB.x + lambda * r.x, wB.y + lambda * r.y);\r\n        vertex.indexB = indexA;\r\n        vertex.wB = wA.clone();\r\n        vertex.w = b2Sub(vertex.wB, vertex.wA);\r\n        vertex.a = 1.0;\r\n        simplex.count += 1;\r\n\r\n        switch (simplex.count)\r\n        {\r\n            case 1:\r\n                break;\r\n\r\n            case 2:\r\n                b2SolveSimplex2(simplex);\r\n\r\n                break;\r\n\r\n            case 3:\r\n                b2SolveSimplex3(simplex);\r\n\r\n                break;\r\n\r\n            default:\r\n                console.assert(false);\r\n        }\r\n\r\n        if (simplex.count === 3)\r\n        {\r\n            return output;\r\n        }\r\n\r\n        v = b2ComputeSimplexClosestPoint(simplex);\r\n\r\n        ++iter;\r\n    }\r\n\r\n    if (iter === 0 || lambda === 0.0)\r\n    {\r\n        return output;\r\n    }\r\n\r\n    const pointA = new b2Vec2();\r\n    const pointB = new b2Vec2();\r\n    b2ComputeSimplexWitnessPoints(pointB, pointA, simplex);\r\n\r\n    const n = b2Normalize(b2Neg(v));\r\n    const point = new b2Vec2(pointA.x + proxyA.radius * n.x, pointA.y + proxyA.radius * n.y);\r\n\r\n    output.point = b2TransformPoint(xfA, point);\r\n    output.normal = b2RotateVector(xfA.q, n);\r\n    output.fraction = lambda;\r\n    output.iterations = iter;\r\n    output.hit = true;\r\n\r\n    return output;\r\n}\r\n\r\n// #define B2_TOI_DEBUG 0\r\n\r\n// Warning: writing to these globals significantly slows multithreading performance\r\n/*\r\n#if B2_TOI_DEBUG\r\nfloat b2_toiTime, b2_toiMaxTime;\r\nint b2_toiCalls, b2_toiIters, b2_toiMaxIters;\r\nint b2_toiRootIters, b2_toiMaxRootIters;\r\n#endif\r\n*/\r\n\r\nconst b2SeparationType = {\r\n    b2_pointsType: 0,\r\n    b2_faceAType: 1,\r\n    b2_faceBType: 2\r\n};\r\n\r\nclass b2SeparationFunction\r\n{\r\n    constructor()\r\n    {\r\n        this.proxyA = null;\r\n        this.proxyB = null;\r\n        this.sweepA = null;\r\n        this.sweepB = null;\r\n        this.localPoint = new b2Vec2();\r\n        this.axis = new b2Vec2();\r\n        this.type = 0;\r\n    }\r\n}\r\n\r\nexport function b2MakeSeparationFunction(cache, proxyA, sweepA, proxyB, sweepB, t1)\r\n{\r\n    const f = new b2SeparationFunction();\r\n    f.proxyA = proxyA;\r\n    f.proxyB = proxyB;\r\n    const count = cache.count;\r\n    console.assert(0 < count && count < 3);\r\n\r\n    f.sweepA = new b2Sweep();\r\n    Object.assign(f.sweepA, sweepA);\r\n    f.sweepB = new b2Sweep();\r\n    Object.assign(f.sweepB, sweepB);\r\n    f.localPoint = new b2Vec2();\r\n    f.axis = new b2Vec2();\r\n    f.type = 0;\r\n\r\n    const xfA = b2GetSweepTransform(sweepA, t1);\r\n    const xfB = b2GetSweepTransform(sweepB, t1);\r\n\r\n    if (count === 1)\r\n    {\r\n        f.type = b2SeparationType.b2_pointsType;\r\n        const localPointA = proxyA.points[cache.indexA[0]];\r\n        const localPointB = proxyB.points[cache.indexB[0]];\r\n        const pointA = b2TransformPoint(xfA, localPointA);\r\n        const pointB = b2TransformPoint(xfB, localPointB);\r\n        f.axis = b2Normalize(b2Sub(pointB, pointA));\r\n        f.localPoint = new b2Vec2();\r\n\r\n        return f;\r\n    }\r\n\r\n    if (cache.indexA[0] === cache.indexA[1])\r\n    {\r\n        // Two points on B and one on A.\r\n        f.type = b2SeparationType.b2_faceBType;\r\n        const localPointB1 = proxyB.points[cache.indexB[0]];\r\n        const localPointB2 = proxyB.points[cache.indexB[1]];\r\n\r\n        f.axis = b2CrossVS(b2Sub(localPointB2, localPointB1), 1.0);\r\n        f.axis = b2Normalize(f.axis);\r\n        const normal = b2RotateVector(xfB.q, f.axis);\r\n\r\n        f.localPoint = new b2Vec2(0.5 * (localPointB1.x + localPointB2.x), 0.5 * (localPointB1.y + localPointB2.y));\r\n        const pointB = b2TransformPoint(xfB, f.localPoint);\r\n\r\n        const localPointA = proxyA.points[cache.indexA[0]];\r\n        const pointA = b2TransformPoint(xfA, localPointA);\r\n\r\n        const s = b2Dot(b2Sub(pointA, pointB), normal);\r\n\r\n        if (s < 0.0)\r\n        {\r\n            f.axis = b2Neg(f.axis);\r\n        }\r\n\r\n        return f;\r\n    }\r\n\r\n    // Two points on A and one or two points on B.\r\n    f.type = b2SeparationType.b2_faceAType;\r\n    const localPointA1 = proxyA.points[cache.indexA[0]];\r\n    const localPointA2 = proxyA.points[cache.indexA[1]];\r\n\r\n    f.axis = b2CrossVS(b2Sub(localPointA2, localPointA1), 1.0);\r\n    f.axis = b2Normalize(f.axis);\r\n    const normal = b2RotateVector(xfA.q, f.axis);\r\n\r\n    f.localPoint = new b2Vec2(0.5 * (localPointA1.x + localPointA2.x), 0.5 * (localPointA1.y + localPointA2.y));\r\n    const pointA = b2TransformPoint(xfA, f.localPoint);\r\n\r\n    const localPointB = proxyB.points[cache.indexB[0]];\r\n    const pointB = b2TransformPoint(xfB, localPointB);\r\n\r\n    const s = b2Dot(b2Sub(pointB, pointA), normal);\r\n\r\n    if (s < 0.0)\r\n    {\r\n        f.axis = b2Neg(f.axis);\r\n    }\r\n\r\n    return f;\r\n}\r\n\r\nclass MinSeparationReturn\r\n{\r\n    constructor(indexA, indexB, separation)\r\n    {\r\n        this.indexA = indexA;\r\n        this.indexB = indexB;\r\n        this.separation = separation;\r\n        \r\n    }\r\n}\r\n\r\nexport function b2FindMinSeparation(f, t)\r\n{\r\n    const xfA = b2GetSweepTransform(f.sweepA, t);\r\n    const xfB = b2GetSweepTransform(f.sweepB, t);\r\n\r\n    switch (f.type)\r\n    {\r\n        case b2SeparationType.b2_pointsType:\r\n        {\r\n            const axisA = b2InvRotateVector(xfA.q, f.axis);\r\n            const axisB = b2InvRotateVector(xfB.q, b2Neg(f.axis));\r\n\r\n            const indexA = b2FindSupport(f.proxyA, axisA);\r\n            const indexB = b2FindSupport(f.proxyB, axisB);\r\n\r\n            const localPointA = f.proxyA.points[indexA];\r\n            const localPointB = f.proxyB.points[indexB];\r\n\r\n            const pointA = b2TransformPoint(xfA, localPointA);\r\n            const pointB = b2TransformPoint(xfB, localPointB);\r\n\r\n            const separation = b2Dot(b2Sub(pointB, pointA), f.axis);\r\n\r\n            return new MinSeparationReturn(indexA, indexB, separation);\r\n        }\r\n\r\n        case b2SeparationType.b2_faceAType:\r\n        {\r\n            const normal = b2RotateVector(xfA.q, f.axis);\r\n            const pointA = b2TransformPoint(xfA, f.localPoint);\r\n\r\n            const axisB = b2InvRotateVector(xfB.q, b2Neg(normal));\r\n\r\n            const indexA = -1;\r\n            const indexB = b2FindSupport(f.proxyB, axisB);\r\n\r\n            const localPointB = f.proxyB.points[indexB];\r\n            const pointB = b2TransformPoint(xfB, localPointB);\r\n\r\n            const separation = b2Dot(b2Sub(pointB, pointA), normal);\r\n\r\n            return new MinSeparationReturn(indexA, indexB, separation);\r\n        }\r\n\r\n        case b2SeparationType.b2_faceBType:\r\n        {\r\n            const normal = b2RotateVector(xfB.q, f.axis);\r\n            const pointB = b2TransformPoint(xfB, f.localPoint);\r\n\r\n            const axisA = b2InvRotateVector(xfA.q, b2Neg(normal));\r\n\r\n            const indexB = -1;\r\n            const indexA = b2FindSupport(f.proxyA, axisA);\r\n\r\n            const localPointA = f.proxyA.points[indexA];\r\n            const pointA = b2TransformPoint(xfA, localPointA);\r\n\r\n            const separation = b2Dot(b2Sub(pointA, pointB), normal);\r\n\r\n            return new MinSeparationReturn(indexA, indexB, separation);\r\n        }\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new MinSeparationReturn(-1, -1, 0.0);\r\n    }\r\n}\r\n\r\nexport function b2EvaluateSeparation(f, indexA, indexB, t)\r\n{\r\n    const xfA = b2GetSweepTransform(f.sweepA, t);\r\n    const xfB = b2GetSweepTransform(f.sweepB, t);\r\n\r\n    switch (f.type)\r\n    {\r\n        case b2SeparationType.b2_pointsType:\r\n        {\r\n            const localPointA = f.proxyA.points[indexA];\r\n            const localPointB = f.proxyB.points[indexB];\r\n            const pointA = b2TransformPoint(xfA, localPointA);\r\n            const pointB = b2TransformPoint(xfB, localPointB);\r\n            const separation = b2Dot(b2Sub(pointB, pointA), f.axis);\r\n\r\n            return separation;\r\n        }\r\n\r\n        case b2SeparationType.b2_faceAType:\r\n        {\r\n            const normal = b2RotateVector(xfA.q, f.axis);\r\n            const pointA = b2TransformPoint(xfA, f.localPoint);\r\n            const localPointB = f.proxyB.points[indexB];\r\n            const pointB = b2TransformPoint(xfB, localPointB);\r\n            const separation = b2Dot(b2Sub(pointB, pointA), normal);\r\n\r\n            return separation;\r\n        }\r\n\r\n        case b2SeparationType.b2_faceBType:\r\n        {\r\n            const normal = b2RotateVector(xfB.q, f.axis);\r\n            const pointB = b2TransformPoint(xfB, f.localPoint);\r\n            const localPointA = f.proxyA.points[indexA];\r\n            const pointA = b2TransformPoint(xfA, localPointA);\r\n            const separation = b2Dot(b2Sub(pointA, pointB), normal);\r\n\r\n            return separation;\r\n        }\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2TimeOfImpact\r\n * @summary Computes the time of impact between two moving shapes. CCD is handled via the local separating axis method. This seeks progression by computing the largest time at which separation is maintained.\r\n * @param {b2TOIInput} input - Input parameters containing:\r\n * - proxyA: First shape proxy\r\n * - proxyB: Second shape proxy\r\n * - sweepA: Motion sweep for first shape\r\n * - sweepB: Motion sweep for second shape\r\n * - tMax: Maximum time interval\r\n * @returns {b2TOIOutput} Output containing:\r\n * - state: The termination state (Unknown, Failed, Overlapped, Hit, Separated)\r\n * - t: Time of impact (between 0 and tMax)\r\n * @description\r\n * Computes when two moving shapes first collide during their motion sweeps.\r\n * Uses conservative advancement and binary search to find the first time of impact\r\n * or determine that no impact occurs during the time interval.\r\n * @throws {Error} Throws assertion error if input sweeps are not normalized\r\n */\r\nexport function b2TimeOfImpact(input)\r\n{\r\n    const output = new b2TOIOutput();\r\n    output.state = b2TOIState.b2_toiStateUnknown;\r\n    output.t = input.tMax;\r\n\r\n    const proxyA = input.proxyA;\r\n    const proxyB = input.proxyB;\r\n\r\n    const sweepA = input.sweepA;\r\n    const sweepB = input.sweepB;\r\n    console.assert( b2IsNormalized( sweepA.q1 ) && b2IsNormalized( sweepA.q2 ), `sweepA not normalized q1:${sweepA.q1.s*sweepA.q1.s+sweepA.q1.c*sweepA.q1.c} q2:${sweepA.q2.s*sweepA.q2.s+sweepA.q2.c*sweepA.q2.c}` );\r\n    console.assert( b2IsNormalized( sweepB.q1 ) && b2IsNormalized( sweepB.q2 ), `sweepB not normalized q1:${sweepB.q1.s*sweepB.q1.s+sweepB.q1.c*sweepB.q1.c} q2:${sweepB.q2.s*sweepB.q2.s+sweepB.q2.c*sweepB.q2.c}` );\r\n\r\n    const tMax = input.tMax;\r\n\r\n    const totalRadius = proxyA.radius + proxyB.radius;\r\n    const target = Math.max(b2_linearSlop, totalRadius - b2_linearSlop);\r\n    const tolerance = 0.25 * b2_linearSlop;\r\n    console.assert( target > tolerance );\r\n\r\n    let t1 = 0.0;\r\n    const k_maxIterations = 20;\r\n    let iter = 0;\r\n\r\n    // Prepare input for distance query.\r\n    const cache = new b2DistanceCache();\r\n    const distanceInput = new b2DistanceInput();\r\n    distanceInput.proxyA = input.proxyA;\r\n    distanceInput.proxyB = input.proxyB;\r\n    distanceInput.useRadii = false;\r\n\r\n    // The outer loop progressively attempts to compute new separating axes.\r\n    // This loop terminates when an axis is repeated (no progress is made).\r\n    for (;;)\r\n    {\r\n        const xfA = b2GetSweepTransform(sweepA, t1);\r\n        const xfB = b2GetSweepTransform(sweepB, t1);\r\n\r\n        // Get the distance between shapes. We can also use the results\r\n        // to get a separating axis.\r\n        distanceInput.transformA = xfA;\r\n        distanceInput.transformB = xfB;\r\n        const distanceOutput = b2ShapeDistance(cache, distanceInput, null, 0);\r\n\r\n        // If the shapes are overlapped, we give up on continuous collision.\r\n        if (distanceOutput.distance <= 0.0)\r\n        {\r\n            // Failure!\r\n            // console.warn(\"SAT gives up on CCD \" + distanceOutput.distance);\r\n            output.state = b2TOIState.b2_toiStateOverlapped;\r\n            output.t = 0.0;\r\n\r\n            break;\r\n        }\r\n\r\n        if (distanceOutput.distance < target + tolerance)\r\n        {\r\n            // Victory!\r\n            output.state = b2TOIState.b2_toiStateHit;\r\n            output.t = t1;\r\n\r\n            break;\r\n        }\r\n\r\n        // Initialize the separating axis.\r\n        const fcn = b2MakeSeparationFunction(cache, proxyA, sweepA, proxyB, sweepB, t1);\r\n\r\n        // Compute the TOI on the separating axis. We do this by successively\r\n        // resolving the deepest point. This loop is bounded by the number of vertices.\r\n        let done = false;\r\n        let t2 = tMax;\r\n        let pushBackIter = 0;\r\n\r\n        for (;;)\r\n        {\r\n            // Find the deepest point at t2. Store the witness point indices.\r\n            const ret = b2FindMinSeparation(fcn, t2);\r\n            let s2 = ret.separation;\r\n            const indexA = ret.indexA;\r\n            const indexB = ret.indexB;\r\n\r\n            // Is the final configuration separated?\r\n            if (s2 > target + tolerance)\r\n            {\r\n                // Victory!\r\n                output.state = b2TOIState.b2_toiStateSeparated;\r\n                output.t = tMax;\r\n                done = true;\r\n\r\n                break;\r\n            }\r\n\r\n            // Has the separation reached tolerance?\r\n            if (s2 > target - tolerance)\r\n            {\r\n                // Advance the sweeps\r\n                t1 = t2;\r\n\r\n                break;\r\n            }\r\n\r\n            // Compute the initial separation of the witness points.\r\n            let s1 = b2EvaluateSeparation(fcn, indexA, indexB, t1);\r\n\r\n            // Check for initial overlap. This might happen if the root finder\r\n            // runs out of iterations.\r\n            if (s1 < target - tolerance)\r\n            {\r\n                output.state = b2TOIState.b2_toiStateFailed;\r\n                output.t = t1;\r\n                done = true;\r\n\r\n                break;\r\n            }\r\n\r\n            // Check for touching\r\n            if (s1 <= target + tolerance)\r\n            {\r\n                // Victory! t1 should hold the TOI (could be 0.0).\r\n                output.state = b2TOIState.b2_toiStateHit;\r\n                output.t = t1;\r\n                done = true;\r\n\r\n                break;\r\n            }\r\n\r\n            // Compute 1D root of: f(x) - target = 0\r\n            let rootIterCount = 0;\r\n            let a1 = t1,\r\n                a2 = t2;\r\n\r\n            for (;;)\r\n            {\r\n                // Use a mix of the secant rule and bisection.\r\n                let t;\r\n\r\n                if (rootIterCount & 1)\r\n                {\r\n                    // Secant rule to improve convergence.\r\n                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\r\n                }\r\n                else\r\n                {\r\n                    // Bisection to guarantee progress.\r\n                    t = 0.5 * (a1 + a2);\r\n                }\r\n\r\n                ++rootIterCount;\r\n\r\n                const s = b2EvaluateSeparation(fcn, indexA, indexB, t);\r\n\r\n                if (Math.abs(s - target) < tolerance)\r\n                {\r\n                    // t2 holds a tentative value for t1\r\n                    t2 = t;\r\n\r\n                    break;\r\n                }\r\n\r\n                // Ensure we continue to bracket the root.\r\n                if (s > target)\r\n                {\r\n                    a1 = t;\r\n                    s1 = s;\r\n                }\r\n                else\r\n                {\r\n                    a2 = t;\r\n                    s2 = s;\r\n                }\r\n\r\n                if (rootIterCount == 50)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            ++pushBackIter;\r\n\r\n            if (pushBackIter == B2_MAX_POLYGON_VERTICES)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        ++iter;\r\n\r\n        if (done)\r\n        {\r\n            break;\r\n        }\r\n\r\n        if (iter == k_maxIterations)\r\n        {\r\n            // Root finder got stuck. Semi-victory.\r\n            output.state = b2TOIState.b2_toiStateFailed;\r\n            output.t = t1;\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    return output;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_MAX_POLYGON_VERTICES, b2Hull } from './include/collision_h.js';\r\nimport { b2AABB, b2AABB_Center, b2Cross, b2DistanceSquared, b2Normalize, b2Sub } from './include/math_functions_h.js';\r\n\r\nimport { b2Validation } from './include/types_h.js';\r\nimport { b2_linearSlop } from './include/core_h.js';\r\n\r\n/**\r\n * @namespace Hull\r\n */\r\n\r\n/**\r\n * @import {b2Vec2} from './include/math_functions_h.js'\r\n */\r\n\r\n// quickhull recursion\r\nfunction b2RecurseHull(p1, p2, ps, count)\r\n{\r\n    const hull = new b2Hull();\r\n\r\n    if (count === 0)\r\n    {\r\n        return hull;\r\n    }\r\n\r\n    // create an edge vector pointing from p1 to p2\r\n    const e = b2Normalize(b2Sub(p2, p1));\r\n\r\n    // discard points left of e and find point furthest to the right of e\r\n    const rightPoints = [];\r\n    let rightCount = 0;\r\n\r\n    let bestIndex = 0;\r\n    let bestDistance = b2Cross(b2Sub(ps[bestIndex], p1), e);\r\n\r\n    if (bestDistance > 0.0)\r\n    {\r\n        rightPoints[rightCount++] = ps[bestIndex];\r\n    }\r\n\r\n    for (let i = 1; i < count; ++i)\r\n    {\r\n        const distance = b2Cross(b2Sub(ps[i], p1), e);\r\n\r\n        if (distance > bestDistance)\r\n        {\r\n            bestIndex = i;\r\n            bestDistance = distance;\r\n        }\r\n\r\n        if (distance > 0.0)\r\n        {\r\n            rightPoints[rightCount++] = ps[i];\r\n        }\r\n    }\r\n\r\n    if (bestDistance < 2.0 * b2_linearSlop)\r\n    {\r\n        return hull;\r\n    }\r\n\r\n    const bestPoint = ps[bestIndex];\r\n\r\n    // compute hull to the right of p1-bestPoint\r\n    const hull1 = b2RecurseHull(p1, bestPoint, rightPoints, rightCount);\r\n\r\n    // compute hull to the right of bestPoint-p2\r\n    const hull2 = b2RecurseHull(bestPoint, p2, rightPoints, rightCount);\r\n\r\n    // stitch together hulls\r\n    for (let i = 0; i < hull1.count; ++i)\r\n    {\r\n        hull.points[hull.count++] = hull1.points[i];\r\n    }\r\n\r\n    hull.points[hull.count++] = bestPoint;\r\n\r\n    for (let i = 0; i < hull2.count; ++i)\r\n    {\r\n        hull.points[hull.count++] = hull2.points[i];\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\nexport function b2IsPolygonCCW(points, count)\r\n{\r\n    let area = 0;\r\n\r\n    for (let i = 0; i < count; i++)\r\n    {\r\n        const j = (i + 1) % count;\r\n        area += (points[j].x - points[i].x) * (points[j].y + points[i].y);\r\n    }\r\n\r\n    return area < 0;\r\n}\r\n\r\nexport function b2ReverseWinding(points, count)\r\n{\r\n    for (let i = 0; i < count / 2; i++)\r\n    {\r\n        const temp = points[i];\r\n        points[i] = points[count - 1 - i];\r\n        points[count - 1 - i] = temp;\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n// quickhull algorithm\r\n// - merges vertices based on b2_linearSlop\r\n// - removes collinear points using b2_linearSlop\r\n// - returns an empty hull if it fails\r\n\r\n/**\r\n * @function b2ComputeHull\r\n * @param {b2Vec2[]} points - Array of 2D points to compute hull from\r\n * @param {number} count - Number of points in the array\r\n * @returns {b2Hull} A hull object containing the computed convex hull vertices\r\n * @description\r\n * Computes the convex hull of a set of 2D points. The function:\r\n * - Filters duplicate points within a tolerance\r\n * - Finds extreme points to establish initial hull edges\r\n * - Recursively adds points to build the complete hull\r\n * - Removes collinear/near-collinear points from final hull\r\n * @throws {Error} If count < 3 or count > B2_MAX_POLYGON_VERTICES\r\n */\r\nexport function b2ComputeHull(points, count)\r\n{\r\n    const hull = new b2Hull();\r\n\r\n    if (count < 3 || count > B2_MAX_POLYGON_VERTICES)\r\n    {\r\n        // check your data\r\n        console.assert(false, \"WARNING: not enough points in the hull.\");\r\n\r\n        return hull;\r\n    }\r\n\r\n    // count = Math.min(count, B2_MAX_POLYGON_VERTICES);\r\n\r\n    const aabb = new b2AABB(Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    // Perform aggressive point welding. First point always remains.\r\n    // Also compute the bounding box for later.\r\n    const ps = [];\r\n    let n = 0;\r\n    const tolSqr = 16.0 * b2_linearSlop * b2_linearSlop;\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        // aabb.lowerBound = b2Min(aabb.lowerBound, points[i]);\r\n        aabb.lowerBoundX = Math.min(aabb.lowerBoundX, points[i].x);\r\n        aabb.lowerBoundY = Math.min(aabb.lowerBoundY, points[i].y);\r\n\r\n        // aabb.upperBound = b2Max(aabb.upperBound, points[i]);\r\n        aabb.upperBoundX = Math.max(aabb.upperBoundX, points[i].x);\r\n        aabb.upperBoundY = Math.max(aabb.upperBoundY, points[i].y);\r\n\r\n        const vi = points[i];\r\n\r\n        let unique = true;\r\n\r\n        for (let j = 0; j < i; ++j)\r\n        {\r\n            const vj = points[j];\r\n\r\n            const distSqr = b2DistanceSquared(vi, vj);\r\n\r\n            if (distSqr < tolSqr)\r\n            {\r\n                unique = false;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (unique)\r\n        {\r\n            ps[n++] = vi;\r\n        }\r\n    }\r\n\r\n    if (n < 3)\r\n    {\r\n        // too many points very close together, check your data and check your scale\r\n        return hull;\r\n    }\r\n\r\n    // Find an extreme point as the first point on the hull\r\n    const c = b2AABB_Center(aabb);\r\n    let f1 = 0;\r\n    let dsq1 = b2DistanceSquared(c, ps[f1]);\r\n\r\n    for (let i = 1; i < n; ++i)\r\n    {\r\n        const dsq = b2DistanceSquared(c, ps[i]);\r\n\r\n        if (dsq > dsq1)\r\n        {\r\n            f1 = i;\r\n            dsq1 = dsq;\r\n        }\r\n    }\r\n\r\n    // remove p1 from working set\r\n    const p1 = ps[f1];\r\n    ps[f1] = ps[n - 1];\r\n    n = n - 1;\r\n\r\n    let f2 = 0;\r\n    let dsq2 = b2DistanceSquared(p1, ps[f2]);\r\n\r\n    for (let i = 1; i < n; ++i)\r\n    {\r\n        const dsq = b2DistanceSquared(p1, ps[i]);\r\n\r\n        if (dsq > dsq2)\r\n        {\r\n            f2 = i;\r\n            dsq2 = dsq;\r\n        }\r\n    }\r\n\r\n    // remove p2 from working set\r\n    const p2 = ps[f2];\r\n    ps[f2] = ps[n - 1];\r\n    n = n - 1;\r\n\r\n    // split the points into points that are left and right of the line p1-p2.\r\n    const rightPoints = [];\r\n    let rightCount = 0;\r\n\r\n    const leftPoints = [];\r\n    let leftCount = 0;\r\n\r\n    const e = b2Normalize(b2Sub(p2, p1));\r\n\r\n    for (let i = 0; i < n; ++i)\r\n    {\r\n        const d = b2Cross(b2Sub(ps[i], p1), e);\r\n\r\n        // slop used here to skip points that are very close to the line p1-p2\r\n        if (d >= 2.0 * b2_linearSlop)\r\n        {\r\n            rightPoints[rightCount++] = ps[i];\r\n        }\r\n        else if (d <= -2.0 * b2_linearSlop)\r\n        {\r\n            leftPoints[leftCount++] = ps[i];\r\n        }\r\n    }\r\n\r\n    // compute hulls on right and left\r\n    const hull1 = b2RecurseHull(p1, p2, rightPoints, rightCount);\r\n    const hull2 = b2RecurseHull(p2, p1, leftPoints, leftCount);\r\n\r\n    if (hull1.count === 0 && hull2.count === 0)\r\n    {\r\n        // all points collinear\r\n        return hull;\r\n    }\r\n\r\n    // stitch hulls together, preserving CCW winding order\r\n    hull.points[hull.count++] = p1;\r\n\r\n    for (let i = 0; i < hull1.count; ++i)\r\n    {\r\n        hull.points[hull.count++] = hull1.points[i];\r\n    }\r\n\r\n    hull.points[hull.count++] = p2;\r\n\r\n    for (let i = 0; i < hull2.count; ++i)\r\n    {\r\n        hull.points[hull.count++] = hull2.points[i];\r\n    }\r\n\r\n    console.assert(hull.count <= B2_MAX_POLYGON_VERTICES);\r\n\r\n    // merge collinear\r\n    let searching = true;\r\n\r\n    while (searching && hull.count > 2)\r\n    {\r\n        searching = false;\r\n\r\n        for (let i = 0; i < hull.count; ++i)\r\n        {\r\n            const i1 = i;\r\n            const i2 = (i + 1) % hull.count;\r\n            const i3 = (i + 2) % hull.count;\r\n\r\n            const s1 = hull.points[i1];\r\n            const s2 = hull.points[i2];\r\n            const s3 = hull.points[i3];\r\n\r\n            // unit edge vector for s1-s3\r\n            const r = b2Normalize(b2Sub(s3, s1));\r\n\r\n            const distance = b2Cross(b2Sub(s2, s1), r);\r\n\r\n            if (distance <= 2.0 * b2_linearSlop)\r\n            {\r\n                // remove midpoint from hull\r\n                for (let j = i2; j < hull.count - 1; ++j)\r\n                {\r\n                    hull.points[j] = hull.points[j + 1];\r\n                }\r\n                hull.count -= 1;\r\n\r\n                // continue searching for collinear points\r\n                searching = true;\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (hull.count < 3)\r\n    {\r\n        // too many points collinear, shouldn't be reached since this was validated above\r\n        hull.count = 0;\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * @function b2ValidateHull\r\n * @description\r\n * Validates that a hull meets the requirements for a valid convex polygon:\r\n * - Has between 3 and B2_MAX_POLYGON_VERTICES points\r\n * - Points are in counter-clockwise order\r\n * - All points are behind the edges\r\n * - No collinear points within b2_linearSlop tolerance\r\n * @param {b2Hull} hull - The hull to validate, containing points array and count\r\n * @returns {boolean} True if the hull is valid, false otherwise\r\n * @throws {Warning} Console warnings are issued explaining validation failures\r\n */\r\nexport function b2ValidateHull(hull)\r\n{\r\n    if (!b2Validation)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (hull.count < 3 || B2_MAX_POLYGON_VERTICES < hull.count)\r\n    {\r\n        console.warn(\"WARNING: hull does not have enough points.\");\r\n\r\n        return false;\r\n    }\r\n\r\n    // hull must have CCW winding order for points\r\n    if (!b2IsPolygonCCW(hull.points, hull.count))\r\n    {\r\n        console.warn(\"WARNING: hull does not have CCW winding.\");\r\n\r\n        return false;\r\n    }\r\n\r\n    // test that every point is behind every edge\r\n    for (let i = 0; i < hull.count; ++i)\r\n    {\r\n        // create an edge vector\r\n        const i1 = i;\r\n        const i2 = i < hull.count - 1 ? i1 + 1 : 0;\r\n        const p = hull.points[i1];\r\n        const e = b2Normalize(b2Sub(hull.points[i2], p));\r\n\r\n        for (let j = 0; j < hull.count; ++j)\r\n        {\r\n            // skip points that subtend the current edge\r\n            if (j === i1 || j === i2)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const distance = b2Cross(b2Sub(hull.points[j], p), e);\r\n\r\n            if (distance >= 0.0)\r\n            {\r\n                console.warn(\"WARNING: hull points are not behind edges (?)\");\r\n\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // test for collinear points\r\n    for (let i = 0; i < hull.count; ++i)\r\n    {\r\n        const i1 = i;\r\n        const i2 = (i + 1) % hull.count;\r\n        const i3 = (i + 2) % hull.count;\r\n\r\n        const p1 = hull.points[i1];\r\n        const p2 = hull.points[i2];\r\n        const p3 = hull.points[i3];\r\n\r\n        const e = b2Normalize(b2Sub(p3, p1));\r\n\r\n        const distance = b2Cross(b2Sub(p2, p1), e);\r\n\r\n        if (distance <= b2_linearSlop)\r\n        {\r\n            // p1-p2-p3 are collinear\r\n            console.warn(\"WARNING: hull has collinear points.\");\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_MAX_POLYGON_VERTICES, b2Capsule, b2CastOutput, b2Circle, b2DistanceCache, b2DistanceInput, b2MassData, b2Polygon, b2ShapeCastPairInput } from './include/collision_h.js';\r\nimport {\r\n    b2AABB,\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2CrossVS,\r\n    b2DistanceSquared,\r\n    b2Dot,\r\n    b2GetLengthAndNormalize,\r\n    b2IsValid,\r\n    b2Length,\r\n    b2Lerp,\r\n    b2Max,\r\n    b2Min,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2Neg,\r\n    b2Normalize,\r\n    b2RightPerp,\r\n    b2Rot,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2Vec2,\r\n    b2Vec2_IsValid,\r\n    eps\r\n} from './include/math_functions_h.js';\r\nimport { b2MakeProxy, b2ShapeCast, b2ShapeDistance } from './include/distance_h.js';\r\n\r\nimport { B2_HUGE } from './include/core_h.js';\r\nimport { b2ValidateHull } from './include/hull_h.js';\r\n\r\n/**\r\n * @namespace Geometry\r\n */\r\n\r\n/**\r\n * @import {b2Hull, b2RayCastInput, b2Segment, b2ShapeCastInput} from './include/collision_h.js'\r\n */\r\n\r\n/**\r\n * Validates a ray cast input structure.\r\n * @function b2IsValidRay\r\n * @param {b2RayCastInput} input - The ray cast input to validate, containing:\r\n * - origin: b2Vec2 - Starting point of the ray\r\n * - translation: b2Vec2 - Direction and length of the ray\r\n * - maxFraction: number - Maximum fraction of translation to check\r\n * @returns {boolean} True if the ray cast input is valid, false otherwise.\r\n * @description\r\n * Checks if a ray cast input is valid by verifying:\r\n * - The origin vector is valid\r\n * - The translation vector is valid\r\n * - The maxFraction is a valid number\r\n * - The maxFraction is between 0 and B2_HUGE(exclusive)\r\n */\r\nexport function b2IsValidRay(input)\r\n{\r\n    const isValid = b2Vec2_IsValid(input.origin) && b2Vec2_IsValid(input.translation) && b2IsValid(input.maxFraction) &&\r\n                  0.0 <= input.maxFraction && input.maxFraction < B2_HUGE;\r\n\r\n    return isValid;\r\n}\r\n\r\nfunction b2ComputePolygonCentroid(vertices, count)\r\n{\r\n    let center = new b2Vec2(0.0, 0.0);\r\n    let area = 0.0;\r\n\r\n    // Get a reference point for forming triangles.\r\n    // Use the first vertex to reduce round-off errors.\r\n    const origin = vertices[0];\r\n\r\n    const inv3 = 1.0 / 3.0;\r\n\r\n    for (let i = 1; i < count - 1; ++i)\r\n    {\r\n        // Triangle edges\r\n        const e1 = b2Sub(vertices[i], origin);\r\n        const e2 = b2Sub(vertices[i + 1], origin);\r\n        const a = 0.5 * b2Cross(e1, e2);\r\n\r\n        // Area weighted centroid\r\n        center = b2MulAdd(center, a * inv3, b2Add(e1, e2));\r\n        area += a;\r\n    }\r\n\r\n    // Centroid\r\n    console.assert(area > eps);\r\n    const invArea = 1.0 / area;\r\n    center.x *= invArea;\r\n    center.y *= invArea;\r\n\r\n    // Restore offset\r\n    center = b2Add(origin, center);\r\n\r\n    return center;\r\n}\r\n\r\n// default to forceCheck: true - turn this off at your own peril, it validates the hull\r\n/**\r\n * @function b2MakePolygon\r\n * @summary Creates a polygon shape from a hull with rounded corners.\r\n * @param {b2Hull} hull - A convex hull structure containing points that define the polygon vertices\r\n * @param {number} radius - The radius used to round the corners of the polygon\r\n * @param {boolean} [forceCheck=true] - Whether to enforce hull validation\r\n * @returns {b2Polygon} A new polygon shape with computed vertices, normals, and centroid\r\n * @throws {Error} Throws an assertion error if the hull is invalid\r\n * @description\r\n * Creates a b2Polygon from a convex hull. If the hull has fewer than 3 points, returns a\r\n * square shape. The function computes the polygon's vertices, edge normals, and centroid.\r\n * Each edge normal is a unit vector perpendicular to the corresponding edge.\r\n */\r\nexport function b2MakePolygon(hull, radius, forceCheck = true)\r\n{\r\n    if (forceCheck && !b2ValidateHull(hull))\r\n    {\r\n        console.warn(\"Invalid hull.\");\r\n\r\n        return null;\r\n    }\r\n\r\n    if (hull.count < 3)\r\n    {\r\n        // Handle a bad hull when assertions are disabled\r\n        return b2MakeSquare(0.5);\r\n    }\r\n\r\n    const shape = new b2Polygon();\r\n    shape.count = hull.count;\r\n    shape.radius = radius;\r\n\r\n    // Copy vertices\r\n    for (let i = 0; i < shape.count; ++i)\r\n    {\r\n        shape.vertices[i] = hull.points[i];\r\n    }\r\n\r\n    // Compute normals. Ensure the edges have non-zero length.\r\n    for (let i = 0; i < shape.count; ++i)\r\n    {\r\n        const i1 = i;\r\n        const i2 = i + 1 < shape.count ? i + 1 : 0;\r\n        const edge = b2Sub(shape.vertices[i2], shape.vertices[i1]);\r\n        console.assert(b2Dot(edge, edge) > eps * eps);\r\n        shape.normals[i] = b2Normalize(b2CrossVS(edge, 1.0));\r\n    }\r\n\r\n    shape.centroid = b2ComputePolygonCentroid(shape.vertices, shape.count);\r\n\r\n    return shape;\r\n}\r\n\r\n// default to forceCheck: true - turn this off at your own peril, it validates the hull\r\n/**\r\n * @function b2MakeOffsetPolygon\r\n * @description Creates a polygon shape from a hull with specified radius and transform\r\n * @param {b2Hull} hull - The input hull to create the polygon from\r\n * @param {number} radius - The radius to offset the polygon vertices\r\n * @param {b2Transform} transform - Transform to apply to the hull points\r\n * @param {boolean} [forceCheck=true] - Whether to force validation check of the hull\r\n * @returns {b2Polygon} A new polygon shape with transformed vertices, computed normals and centroid\r\n * @throws {Error} Throws assertion error if hull validation fails\r\n * @note Returns a square polygon of size 0.5 if hull has less than 3 points\r\n */\r\nexport function b2MakeOffsetPolygon(hull, radius, transform, forceCheck = true)\r\n{\r\n    console.assert(forceCheck && b2ValidateHull(hull), \"Invalid hull.\");\r\n\r\n    if (hull.count < 3)\r\n    {\r\n        // Handle a bad hull when assertions are disabled\r\n        return b2MakeSquare(0.5);\r\n    }\r\n\r\n    const shape = new b2Polygon();\r\n    shape.count = hull.count;\r\n    shape.radius = radius;\r\n\r\n    // Copy vertices\r\n    for (let i = 0; i < shape.count; ++i)\r\n    {\r\n        shape.vertices[i] = b2TransformPoint(transform, hull.points[i]);\r\n    }\r\n\r\n    // Compute normals. Ensure the edges have non-zero length.\r\n    for (let i = 0; i < shape.count; ++i)\r\n    {\r\n        const i1 = i;\r\n        const i2 = i + 1 < shape.count ? i + 1 : 0;\r\n        const edge = b2Sub(shape.vertices[i2], shape.vertices[i1]);\r\n        console.assert(b2Dot(edge, edge) > eps * eps);\r\n        shape.normals[i] = b2Normalize(b2CrossVS(edge, 1.0));\r\n    }\r\n\r\n    shape.centroid = b2ComputePolygonCentroid(shape.vertices, shape.count);\r\n\r\n    return shape;\r\n}\r\n\r\n/**\r\n * Creates a square polygon with equal width and height.\r\n * @function b2MakeSquare\r\n * @param {number} h - The half-width and half-height of the square.\r\n * @returns {b2Polygon} A polygon object representing a square centered at the origin.\r\n * @description\r\n * Creates a square polygon by calling b2MakeBox with equal dimensions.\r\n * The square is centered at the origin with sides of length 2h.\r\n */\r\nexport function b2MakeSquare(h)\r\n{\r\n    return b2MakeBox(h, h);\r\n}\r\n\r\n/**\r\n * @function b2MakeBox\r\n * @description\r\n * Creates a rectangular polygon shape centered at the origin with specified half-widths.\r\n * The vertices are arranged counter-clockwise starting from the bottom-left corner.\r\n * The shape includes pre-computed normals for each edge.\r\n * @param {number} hx - Half-width of the box in the x-direction (must be positive)\r\n * @param {number} hy - Half-height of the box in the y-direction (must be positive)\r\n * @returns {b2Polygon} A polygon shape representing a rectangle with:\r\n * - 4 vertices at (-hx,-hy), (hx,-hy), (hx,hy), (-hx,hy)\r\n * - 4 normals pointing outward from each edge\r\n * - radius of 0\r\n * - centroid at (0,0)\r\n * @throws {Error} Throws an assertion error if hx or hy are not valid positive numbers\r\n */\r\nexport function b2MakeBox(hx, hy)\r\n{\r\n    console.assert(b2IsValid(hx) && hx > 0.0);\r\n    console.assert(b2IsValid(hy) && hy > 0.0);\r\n\r\n    const shape = new b2Polygon();\r\n    shape.count = 4;\r\n    shape.vertices[0] = new b2Vec2(-hx, -hy);\r\n    shape.vertices[1] = new b2Vec2(hx, -hy);\r\n    shape.vertices[2] = new b2Vec2(hx, hy);\r\n    shape.vertices[3] = new b2Vec2(-hx, hy);\r\n    shape.normals[0] = new b2Vec2(0.0, -1.0);\r\n    shape.normals[1] = new b2Vec2(1.0, 0.0);\r\n    shape.normals[2] = new b2Vec2(0.0, 1.0);\r\n    shape.normals[3] = new b2Vec2(-1.0, 0.0);\r\n    shape.radius = 0.0;\r\n    shape.centroid = new b2Vec2(0,0);\r\n\r\n    return shape;\r\n}\r\n\r\n/**\r\n * Creates a rounded box shape by generating a box with specified dimensions and corner radius.\r\n * @function b2MakeRoundedBox\r\n * @param {number} hx - Half-width of the box along the x-axis\r\n * @param {number} hy - Half-height of the box along the y-axis\r\n * @param {number} radius - Radius of the rounded corners\r\n * @returns {b2Polygon} A polygon shape representing a rounded box\r\n */\r\nexport function b2MakeRoundedBox(hx, hy, radius)\r\n{\r\n    const shape = b2MakeBox(hx, hy);\r\n    shape.radius = radius;\r\n\r\n    return shape;\r\n}\r\n\r\n/**\r\n * Creates a rectangular polygon shape with specified dimensions, position, and rotation.\r\n * @function b2MakeOffsetBox\r\n * @param {number} hx - Half-width of the box along the x-axis\r\n * @param {number} hy - Half-height of the box along the y-axis\r\n * @param {b2Vec2} center - The center position of the box\r\n * @param {b2Rot} rotation - The 2D rotation of the box\r\n * @returns {b2Polygon} A polygon shape representing the box with 4 vertices and normals\r\n * @description\r\n * Creates a b2Polygon representing a rectangle with the given dimensions. The box is centered\r\n * at the specified position and rotated by the given angle. The resulting polygon includes\r\n * 4 vertices, 4 normals, and has its centroid set to the center position.\r\n */\r\nexport function b2MakeOffsetBox(hx, hy, center, rotation)\r\n{\r\n    const xf = new b2Transform();\r\n    xf.p = center;\r\n    xf.q = rotation;\r\n\r\n    const shape = new b2Polygon();\r\n    shape.count = 4;\r\n    shape.vertices[0] = b2TransformPoint(xf, new b2Vec2(-hx, -hy));\r\n    shape.vertices[1] = b2TransformPoint(xf, new b2Vec2(hx, -hy));\r\n    shape.vertices[2] = b2TransformPoint(xf, new b2Vec2(hx, hy));\r\n    shape.vertices[3] = b2TransformPoint(xf, new b2Vec2(-hx, hy));\r\n    shape.normals[0] = b2RotateVector(xf.q, new b2Vec2(0.0, -1.0));\r\n    shape.normals[1] = b2RotateVector(xf.q, new b2Vec2(1.0, 0.0));\r\n    shape.normals[2] = b2RotateVector(xf.q, new b2Vec2(0.0, 1.0));\r\n    shape.normals[3] = b2RotateVector(xf.q, new b2Vec2(-1.0, 0.0));\r\n    shape.radius = 0.0;\r\n    shape.centroid = center;\r\n\r\n    return shape;\r\n}\r\n\r\n/**\r\n * @function b2TransformPolygon\r\n * @summary Transforms a polygon by applying a rigid body transformation.\r\n * @param {b2Transform} transform - The transformation to apply, consisting of a position vector and rotation.\r\n * @param {b2Polygon} polygon - The polygon to transform, containing vertices, normals and centroid.\r\n * @returns {b2Polygon} The transformed polygon with updated vertices, normals and centroid.\r\n * @description\r\n * Applies a rigid body transformation to a polygon by:\r\n * 1. Transforming each vertex using the full transform\r\n * 2. Rotating each normal vector using only the rotation component\r\n * 3. Transforming the centroid using the full transform\r\n */\r\nexport function b2TransformPolygon(transform, polygon)\r\n{\r\n    const p = polygon;\r\n\r\n    for (let i = 0; i < p.count; ++i)\r\n    {\r\n        p.vertices[i] = b2TransformPoint(transform, p.vertices[i]);\r\n        p.normals[i] = b2RotateVector(transform.q, p.normals[i]);\r\n    }\r\n\r\n    p.centroid = b2TransformPoint(transform, p.centroid);\r\n\r\n    return p;\r\n}\r\n\r\n/**\r\n * @function b2ComputeCircleMass\r\n * @summary Computes mass properties for a circle shape.\r\n * @param {b2Circle} shape - A circle shape object containing radius and center properties\r\n * @param {number} density - The density of the circle in mass per unit area\r\n * @returns {b2MassData} An object containing:\r\n * - mass: The total mass of the circle\r\n * - center: The center of mass (copied from shape.center)\r\n * - rotationalInertia: The rotational inertia about the center of mass\r\n * @description\r\n * Calculates the mass, center of mass, and rotational inertia for a circle shape\r\n * with given density. The rotational inertia is computed about the center of mass\r\n * using the parallel axis theorem when the circle's center is offset from the origin.\r\n */\r\nexport function b2ComputeCircleMass(shape, density)\r\n{\r\n    const rr = shape.radius * shape.radius;\r\n\r\n    const massData = new b2MassData();\r\n    massData.mass = density * Math.PI * rr;\r\n    massData.center = shape.center.clone();\r\n\r\n    // inertia about the local origin\r\n    massData.rotationalInertia = massData.mass * (0.5 * rr + b2Dot(shape.center, shape.center));\r\n\r\n    return massData;\r\n}\r\n\r\n/**\r\n * @function b2ComputeCapsuleMass\r\n * @description\r\n * Computes mass properties for a capsule shape, including total mass, center of mass,\r\n * and rotational inertia. A capsule consists of a rectangle with semicircles at both ends.\r\n * @param {b2Capsule} shape - A capsule shape defined by two centers (center1, center2) and a radius\r\n * @param {number} density - The density of the capsule in mass per unit area\r\n * @returns {b2MassData} An object containing:\r\n * - mass: The total mass of the capsule\r\n * - center: A b2Vec2 representing the center of mass\r\n * - rotationalInertia: The moment of inertia about the center of mass\r\n */\r\nexport function b2ComputeCapsuleMass(shape, density)\r\n{\r\n    const radius = shape.radius;\r\n    const rr = radius * radius;\r\n    const p1 = shape.center1;\r\n    const p2 = shape.center2;\r\n    const length = b2Length(b2Sub(p2, p1));\r\n    const ll = length * length;\r\n\r\n    const circleMass = density * Math.PI * rr;\r\n    const boxMass = density * (2.0 * radius * length);\r\n\r\n    const massData = new b2MassData();\r\n    massData.mass = circleMass + boxMass;\r\n    massData.center = new b2Vec2(0.5 * (p1.x + p2.x), 0.5 * (p1.y + p2.y));\r\n\r\n    // two offset half circles, both halves add up to full circle and each half is offset by half length\r\n    // semi-circle centroid = 4 r / 3 pi\r\n    // Need to apply parallel-axis theorem twice:\r\n    // 1. shift semi-circle centroid to origin\r\n    // 2. shift semi-circle to box end\r\n    // m * ((h + lc)^2 - lc^2) = m * (h^2 + 2 * h * lc)\r\n    // See = https://en.wikipedia.org/wiki/Parallel_axis_theorem\r\n    // I verified this formula by computing the convex hull of a 128 vertex capsule\r\n\r\n    // half circle centroid\r\n    const lc = 4.0 * radius / (3.0 * Math.PI);\r\n\r\n    // half length of rectangular portion of capsule\r\n    const h = 0.5 * length;\r\n\r\n    const circleInertia = circleMass * (0.5 * rr + h * h + 2.0 * h * lc);\r\n    const boxInertia = boxMass * (4.0 * rr + ll) / 12.0;\r\n    massData.rotationalInertia = circleInertia + boxInertia;\r\n\r\n    // inertia about the local origin\r\n    massData.rotationalInertia += massData.mass * b2Dot(massData.center, massData.center);\r\n\r\n    return massData;\r\n}\r\n\r\n/**\r\n * @function b2ComputePolygonMass\r\n * @description\r\n * Computes mass properties for a polygon shape, including mass, center of mass, and rotational inertia.\r\n * Handles special cases for 1-vertex (circle) and 2-vertex (capsule) polygons.\r\n * For polygons with 3 or more vertices, calculates properties using triangulation.\r\n * @param {b2Polygon} shape - The polygon shape containing vertices, normals, count, and radius\r\n * @param {number} density - The density of the shape in mass per unit area\r\n * @returns {b2MassData} Object containing:\r\n * - mass: Total mass of the shape\r\n * - center: Center of mass as b2Vec2\r\n * - rotationalInertia: Moment of inertia about the center of mass\r\n * @throws {Error} Throws assertion error if shape.count is 0 or exceeds B2_MAX_POLYGON_VERTICES\r\n */\r\nexport function b2ComputePolygonMass(shape, density)\r\n{\r\n    console.assert(shape.count > 0);\r\n\r\n    if (shape.count == 1)\r\n    {\r\n        const circle = new b2Circle();\r\n        circle.center = shape.vertices[0].clone();\r\n        circle.radius = shape.radius;\r\n\r\n        return b2ComputeCircleMass(circle, density);\r\n    }\r\n\r\n    if (shape.count == 2)\r\n    {\r\n        const capsule = new b2Capsule();\r\n        capsule.center1 = shape.vertices[0].clone();\r\n        capsule.center2 = shape.vertices[1].clone();\r\n        capsule.radius = shape.radius;\r\n\r\n        return b2ComputeCapsuleMass(capsule, density);\r\n    }\r\n\r\n    const vertices = new Array(B2_MAX_POLYGON_VERTICES);\r\n    const count = shape.count;\r\n    const radius = shape.radius;\r\n    console.assert(count <= B2_MAX_POLYGON_VERTICES);     // PJB: ragdolls crash at 8, maxPolygonVertices == 8, coincidence?\r\n\r\n    if (radius > 0.0)\r\n    {\r\n        // Approximate mass of rounded polygons by pushing out the vertices.\r\n        const sqrt2 = 1.412;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const j = i == 0 ? count - 1 : i - 1;\r\n            const n1 = shape.normals[j];\r\n            const n2 = shape.normals[i];\r\n\r\n            const mid = b2Normalize(b2Add(n1, n2));\r\n            vertices[i] = b2MulAdd(shape.vertices[i], sqrt2 * radius, mid);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            vertices[i] = shape.vertices[i];\r\n        }\r\n    }\r\n\r\n    let center = new b2Vec2(0.0, 0.0);\r\n    let area = 0.0;\r\n    let rotationalInertia = 0.0;\r\n\r\n    // Get a reference point for forming triangles.\r\n    // Use the first vertex to reduce round-off errors.\r\n    const r = vertices[0];\r\n\r\n    const inv3 = 1.0 / 3.0;\r\n\r\n    for (let i = 1; i < count - 1; ++i)\r\n    {\r\n        // Triangle edges\r\n        const e1 = b2Sub(vertices[i], r);\r\n        const e2 = b2Sub(vertices[i + 1], r);\r\n\r\n        const D = b2Cross(e1, e2);\r\n\r\n        const triangleArea = 0.5 * D;\r\n        area += triangleArea;\r\n\r\n        // Area weighted centroid, r at origin\r\n        center = b2MulAdd(center, triangleArea * inv3, b2Add(e1, e2));\r\n\r\n        const ex1 = e1.x,\r\n            ey1 = e1.y;\r\n        const ex2 = e2.x,\r\n            ey2 = e2.y;\r\n\r\n        const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\r\n        const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\r\n\r\n        rotationalInertia += (0.25 * inv3 * D) * (intx2 + inty2);\r\n    }\r\n\r\n    const massData = new b2MassData();\r\n\r\n    // Total mass\r\n    massData.mass = density * area;\r\n\r\n    // Center of mass, shift back from origin at r\r\n    console.assert(area > eps);\r\n    const invArea = 1.0 / area;\r\n    center.x *= invArea;\r\n    center.y *= invArea;\r\n    massData.center = b2Add(r, center);\r\n\r\n    // Inertia tensor relative to the local origin (point s).\r\n    massData.rotationalInertia = density * rotationalInertia;\r\n\r\n    // Shift to center of mass then to original body origin.\r\n    massData.rotationalInertia += massData.mass * (b2Dot(massData.center, massData.center) - b2Dot(center, center));\r\n\r\n    return massData;\r\n}\r\n\r\n/**\r\n * @function b2ComputeCircleAABB\r\n * @summary Computes an Axis-Aligned Bounding Box (AABB) for a circle shape after applying a transform.\r\n * @param {b2Circle} shape - The circle shape containing center point and radius.\r\n * @param {b2Transform} xf - The transform to be applied, consisting of a position (p) and rotation (q).\r\n * @returns {b2AABB} An AABB object defined by minimum and maximum points that bound the transformed circle.\r\n * @description\r\n * Calculates the AABB by transforming the circle's center point using the provided transform\r\n * and extending the bounds by the circle's radius in each direction.\r\n */\r\nexport function b2ComputeCircleAABB(shape, xf)\r\n{\r\n    // let p = b2TransformPoint(xf, shape.center);\r\n    const pX = (xf.q.c * shape.center.x - xf.q.s * shape.center.y) + xf.p.x;\r\n    const pY = (xf.q.s * shape.center.x + xf.q.c * shape.center.y) + xf.p.y;\r\n    const r = shape.radius;\r\n\r\n    const aabb = new b2AABB(pX - r, pY - r, pX + r, pY + r);\r\n\r\n    return aabb;\r\n}\r\n\r\n/**\r\n * @function b2ComputeCapsuleAABB\r\n * @summary Computes an Axis-Aligned Bounding Box (AABB) for a capsule shape.\r\n * @param {b2Capsule} shape - A capsule shape defined by two centers and a radius.\r\n * @param {b2Transform} xf - A transform containing position and rotation to be applied to the capsule.\r\n * @returns {b2AABB} An AABB that encompasses the transformed capsule shape.\r\n * @description\r\n * Calculates the minimum and maximum bounds of a capsule after applying a transform.\r\n * The AABB is computed by transforming the capsule's center points and extending\r\n * the bounds by the capsule's radius in all directions.\r\n */\r\nexport function b2ComputeCapsuleAABB(shape, xf)\r\n{\r\n    const v1 = b2TransformPoint(xf, shape.center1);\r\n    const v2 = b2TransformPoint(xf, shape.center2);\r\n\r\n    const lowerX = Math.min(v1.x, v2.x) - shape.radius;\r\n    const lowerY = Math.min(v1.y, v2.y) - shape.radius;\r\n    const upperX = Math.max(v1.x, v2.x) + shape.radius;\r\n    const upperY = Math.max(v1.y, v2.y) + shape.radius;\r\n\r\n    const aabb = new b2AABB(lowerX, lowerY, upperX, upperY);\r\n\r\n    return aabb;\r\n}\r\n\r\n/**\r\n * @function b2ComputePolygonAABB\r\n * @description\r\n * Computes the Axis-Aligned Bounding Box (AABB) for a polygon shape after applying a transform.\r\n * The AABB includes the polygon's radius in its calculations.\r\n * @param {b2Polygon} shape - The polygon shape containing vertices and radius\r\n * @param {b2Transform} xf - The transform to apply, consisting of position (p) and rotation (q)\r\n * @returns {b2AABB} An AABB object with lower and upper bounds that encompass the transformed polygon\r\n */\r\nexport function b2ComputePolygonAABB(shape, xf)\r\n{\r\n    // let lower = b2TransformPoint(xf, shape.vertices[0]);\r\n    const sv = shape.vertices[0];\r\n    let lowerX = (xf.q.c * sv.x - xf.q.s * sv.y) + xf.p.x;\r\n    let lowerY = (xf.q.s * sv.x + xf.q.c * sv.y) + xf.p.y;\r\n    let upperX = lowerX,\r\n        upperY = lowerY;\r\n\r\n    for (let i = 1; i < shape.count; ++i)\r\n    {\r\n        // let v = b2TransformPoint(xf, shape.vertices[i]);\r\n        const sv = shape.vertices[i];\r\n        const vx = (xf.q.c * sv.x - xf.q.s * sv.y) + xf.p.x;\r\n        const vy = (xf.q.s * sv.x + xf.q.c * sv.y) + xf.p.y;\r\n\r\n        // lower = b2Min(lower, v);\r\n        lowerX = Math.min(lowerX, vx);\r\n        lowerY = Math.min(lowerY, vy);\r\n\r\n        // upper = b2Max(upper, v);\r\n        upperX = Math.max(upperX, vx);\r\n        upperY = Math.max(upperY, vy);\r\n    }\r\n\r\n    const r = shape.radius;\r\n\r\n    // lower = b2Sub(lower, r);\r\n    lowerX -= r;\r\n    lowerY -= r;\r\n\r\n    // upper = b2Add(upper, r);\r\n    upperX += r;\r\n    upperY += r;\r\n\r\n    const aabb = new b2AABB(lowerX, lowerY, upperX, upperY);\r\n\r\n    return aabb;\r\n}\r\n\r\n/**\r\n * @summary Computes an Axis-Aligned Bounding Box (AABB) for a line segment.\r\n * @function b2ComputeSegmentAABB\r\n * @param {b2Segment} shape - A line segment defined by two points (point1 and point2)\r\n * @param {b2Transform} xf - A transform containing position and rotation to be applied to the segment\r\n * @returns {b2AABB} An AABB that contains the transformed line segment\r\n * @description\r\n * Transforms the segment's endpoints using the provided transform, then creates an AABB\r\n * that encompasses the transformed segment by finding the minimum and maximum coordinates\r\n * of the transformed endpoints.\r\n */\r\nexport function b2ComputeSegmentAABB(shape, xf)\r\n{\r\n    const v1 = b2TransformPoint(xf, shape.point1);\r\n    const v2 = b2TransformPoint(xf, shape.point2);\r\n\r\n    const lower = b2Min(v1, v2);\r\n    const upper = b2Max(v1, v2);\r\n\r\n    const aabb = new b2AABB(lower.x, lower.y, upper.x, upper.y);\r\n\r\n    return aabb;\r\n}\r\n\r\n/**\r\n * @summary Determines if a point lies within a circle.\r\n * @function b2PointInCircle\r\n * @param {b2Vec2} point - The point to test, represented as a 2D vector.\r\n * @param {b2Circle} shape - The circle to test against, containing center and radius properties.\r\n * @returns {boolean} True if the point lies within or on the circle's boundary, false otherwise.\r\n * @description\r\n * Tests if a point lies within a circle by comparing the squared distance between\r\n * the point and circle's center against the circle's squared radius.\r\n */\r\nexport function b2PointInCircle(point, shape)\r\n{\r\n    const center = shape.center;\r\n\r\n    return b2DistanceSquared(point, center) <= shape.radius * shape.radius;\r\n}\r\n\r\n/**\r\n * @function b2PointInCapsule\r\n * @summary Tests if a point lies inside a capsule shape.\r\n * @param {b2Vec2} point - The point to test\r\n * @param {b2Capsule} shape - The capsule shape defined by two centers and a radius\r\n * @returns {boolean} True if the point lies inside or on the capsule, false otherwise\r\n * @description\r\n * A capsule is defined by two end centers (center1 and center2) and a radius.\r\n * The function calculates if the given point lies within the capsule by:\r\n * 1. Testing if the capsule has zero length (centers are identical)\r\n * 2. If not, finding the closest point on the line segment between centers\r\n * 3. Checking if the distance from the test point to the closest point is within the radius\r\n */\r\nexport function b2PointInCapsule(point, shape)\r\n{\r\n    const rr = shape.radius * shape.radius;\r\n    const p1 = shape.center1;\r\n    const p2 = shape.center2;\r\n\r\n    const d = b2Sub(p2, p1);\r\n    const dd = b2Dot(d, d);\r\n\r\n    if (dd == 0.0)\r\n    {\r\n        // Capsule is really a circle\r\n        return b2DistanceSquared(point, p1) <= rr;\r\n    }\r\n\r\n    // Get closest point on capsule segment\r\n    // c = p1 + t * d\r\n    // dot(point - c, d) = 0\r\n    // dot(point - p1 - t * d, d) = 0\r\n    // t = dot(point - p1, d) / dot(d, d)\r\n    let t = b2Dot(b2Sub(point, p1), d) / dd;\r\n    t = b2ClampFloat(t, 0.0, 1.0);\r\n    const c = b2MulAdd(p1, t, d);\r\n\r\n    // Is query point within radius around closest point?\r\n    return b2DistanceSquared(point, c) <= rr;\r\n}\r\n\r\n/**\r\n * @function b2PointInPolygon\r\n * @description\r\n * Tests if a point lies inside a polygon shape by calculating the minimum distance\r\n * between the point and the polygon.\r\n * @param {b2Vec2} point - The point to test\r\n * @param {b2Polygon} shape - The polygon shape to test against\r\n * @returns {boolean} True if the point is inside or on the polygon (within shape.radius), false otherwise\r\n */\r\nexport function b2PointInPolygon(point, shape)\r\n{\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = b2MakeProxy(shape.vertices, shape.count, 0.0);\r\n    input.proxyB = b2MakeProxy([ point ], 1, 0.0);\r\n    input.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.useRadii = false;\r\n\r\n    const cache = new b2DistanceCache();\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    return output.distance <= shape.radius;\r\n}\r\n\r\nconst rayPoint = new b2Vec2(0, 0);\r\nconst rayNormal = new b2Vec2(0, 1);\r\n\r\n/**\r\n * @function b2RayCastCircle\r\n * @summary Performs a ray cast against a circle shape.\r\n * @param {b2RayCastInput} input - The ray cast input parameters containing:\r\n * - origin: b2Vec2 starting point of the ray\r\n * - translation: b2Vec2 direction and length of the ray\r\n * - maxFraction: number maximum intersection distance as a fraction of ray length\r\n * @param {b2Circle} shape - The circle shape to test against, containing:\r\n * - center: b2Vec2 position of circle center\r\n * - radius: number radius of the circle\r\n * @returns {b2CastOutput} The ray cast results containing:\r\n * - hit: boolean whether the ray intersects the circle\r\n * - point: b2Vec2 point of intersection if hit is true\r\n * - normal: b2Vec2 surface normal at intersection point if hit is true\r\n * - fraction: number intersection distance as a fraction of ray length if hit is true\r\n * @description\r\n * Calculates the intersection point between a ray and a circle shape.\r\n * Returns early with no hit if the ray length is 0 or if the ray passes outside the circle radius.\r\n */\r\nexport function b2RayCastCircle(input, shape)\r\n{\r\n    console.assert(b2IsValidRay(input));\r\n\r\n    const p = shape.center.clone();\r\n\r\n    const output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n    // Shift ray so circle center is the origin\r\n    const s = b2Sub(input.origin, p);\r\n    const res = b2GetLengthAndNormalize(input.translation);\r\n    const length = res.length;\r\n\r\n    if (length == 0.0)\r\n    {\r\n        // zero length ray\r\n        return output;\r\n    }\r\n    const d = res.normal;\r\n\r\n    // Find closest point on ray to origin\r\n\r\n    // solve = dot(s + t * d, d) = 0\r\n    const t = -b2Dot(s, d);\r\n\r\n    // c is the closest point on the line to the origin\r\n    const c = b2MulAdd(s, t, d);\r\n\r\n    const cc = b2Dot(c, c);\r\n    const r = shape.radius;\r\n    const rr = r * r;\r\n\r\n    if (cc > rr)\r\n    {\r\n        // closest point is outside the circle\r\n        return output;\r\n    }\r\n\r\n    // Pythagoras\r\n    const h = Math.sqrt(rr - cc);\r\n\r\n    const fraction = t - h;\r\n\r\n    if (fraction < 0.0 || input.maxFraction * length < fraction)\r\n    {\r\n        // outside the range of the ray segment\r\n        return output;\r\n    }\r\n\r\n    const hitPoint = b2MulAdd(s, fraction, d);\r\n\r\n    output.fraction = fraction / length;\r\n    output.normal = b2Normalize(hitPoint);\r\n    output.point = b2MulAdd(p, shape.radius, output.normal);\r\n    output.hit = true;\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2RayCastCapsule\r\n * @description\r\n * Performs a ray cast against a capsule shape. A capsule is defined by two centers and a radius.\r\n * If the capsule length is near zero, it degrades to a circle ray cast.\r\n * @param {b2RayCastInput} input - Contains ray cast parameters including:\r\n * - origin: b2Vec2 starting point of the ray\r\n * - translation: b2Vec2 direction and length of the ray\r\n * - maxFraction: number maximum intersection distance as a fraction of ray length\r\n * @param {b2Capsule} shape - The capsule to test against, containing:\r\n * - center1: b2Vec2 first endpoint of capsule centerline\r\n * - center2: b2Vec2 second endpoint of capsule centerline\r\n * - radius: number radius of the capsule\r\n * @returns {b2CastOutput} Contains the ray cast results:\r\n * - fraction: number intersection distance as a fraction of ray length\r\n * - point: b2Vec2 point of intersection\r\n * - normal: b2Vec2 surface normal at intersection\r\n * - hit: boolean whether an intersection occurred\r\n */\r\nexport function b2RayCastCapsule(input, shape)\r\n{\r\n    console.assert(b2IsValidRay(input));\r\n\r\n    const output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n    const v1 = shape.center1;\r\n    const v2 = shape.center2;\r\n\r\n    const e = b2Sub(v2, v1);\r\n\r\n    const res = b2GetLengthAndNormalize(e);\r\n    const capsuleLength = res.length;\r\n    const a = res.normal;\r\n\r\n    if (capsuleLength < eps)\r\n    {\r\n        // Capsule is really a circle\r\n        const circle = new b2Circle();\r\n        circle.center = v1;\r\n        circle.radius = shape.radius;\r\n\r\n        return b2RayCastCircle(input, circle);\r\n    }\r\n\r\n    const p1 = input.origin;\r\n    const d = input.translation;\r\n\r\n    // Ray from capsule start to ray start\r\n    const q = b2Sub(p1, v1);\r\n    const qa = b2Dot(q, a);\r\n\r\n    // Vector to ray start that is perpendicular to capsule axis\r\n    const qp = b2MulAdd(q, -qa, a);\r\n\r\n    const radius = shape.radius;\r\n\r\n    // Does the ray start within the infinite length capsule?\r\n    if (b2Dot(qp, qp) < radius * radius)\r\n    {\r\n        if (qa < 0.0)\r\n        {\r\n            // start point behind capsule segment\r\n            const circle = new b2Circle();\r\n            circle.center = v1;\r\n            circle.radius = shape.radius;\r\n\r\n            return b2RayCastCircle(input, circle);\r\n        }\r\n\r\n        if (qa > 1.0)\r\n        {\r\n            // start point ahead of capsule segment\r\n            const circle = new b2Circle();\r\n            circle.center = v2;\r\n            circle.radius = shape.radius;\r\n\r\n            return b2RayCastCircle(input, circle);\r\n        }\r\n\r\n        // ray starts inside capsule -> no hit\r\n        return output;\r\n    }\r\n\r\n    // Perpendicular to capsule axis, pointing right\r\n    let n = new b2Vec2(a.y, -a.x);\r\n\r\n    const res0 = b2GetLengthAndNormalize(d);\r\n    const rayLength = res0.length;\r\n    const u = res0.normal;\r\n\r\n    // Intersect ray with infinite length capsule\r\n    // v1 + radius * n + s1 * a = p1 + s2 * u\r\n    // v1 - radius * n + s1 * a = p1 + s2 * u\r\n\r\n    // s1 * a - s2 * u = b\r\n    // b = q - radius * ap\r\n    // or\r\n    // b = q + radius * ap\r\n\r\n    // Cramer's rule [a -u]\r\n    const den = -a.x * u.y + u.x * a.y;\r\n\r\n    if (-eps < den && den < eps)\r\n    {\r\n        // Ray is parallel to capsule and outside infinite length capsule\r\n        return output;\r\n    }\r\n\r\n    const b1 = b2MulSub(q, radius, n);\r\n    const b2 = b2MulAdd(q, radius, n);\r\n\r\n    const invDen = 1.0 / den;\r\n\r\n    // Cramer's rule [a b1]\r\n    const s21 = (a.x * b1.y - b1.x * a.y) * invDen;\r\n\r\n    // Cramer's rule [a b2]\r\n    const s22 = (a.x * b2.y - b2.x * a.y) * invDen;\r\n\r\n    let s2, b;\r\n\r\n    if (s21 < s22)\r\n    {\r\n        s2 = s21;\r\n        b = b1;\r\n    }\r\n    else\r\n    {\r\n        s2 = s22;\r\n        b = b2;\r\n        n = b2Neg(n);\r\n    }\r\n\r\n    if (s2 < 0.0 || input.maxFraction * rayLength < s2)\r\n    {\r\n        return output;\r\n    }\r\n\r\n    // Cramer's rule [b -u]\r\n    const s1 = (-b.x * u.y + u.x * b.y) * invDen;\r\n\r\n    if (s1 < 0.0)\r\n    {\r\n        // ray passes behind capsule segment\r\n        const circle = new b2Circle();\r\n        circle.center = v1;\r\n        circle.radius = shape.radius;\r\n\r\n        return b2RayCastCircle(input, circle);\r\n    }\r\n    else if (capsuleLength < s1)\r\n    {\r\n        // ray passes ahead of capsule segment\r\n        const circle = new b2Circle();\r\n        circle.center = v2;\r\n        circle.radius = shape.radius;\r\n\r\n        return b2RayCastCircle(input, circle);\r\n    }\r\n    else\r\n    {\r\n        // ray hits capsule side\r\n        output.fraction = s2 / rayLength;\r\n        output.point = b2Add(b2Lerp(v1, v2, s1 / capsuleLength), b2MulSV(shape.radius, n));\r\n        output.normal = n;\r\n        output.hit = true;\r\n\r\n        return output;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2RayCastSegment\r\n * @description\r\n * Performs a ray cast against a line segment, determining if and where the ray intersects the segment.\r\n * For one-sided segments, intersections are only detected from one side based on a cross product test.\r\n * @param {b2RayCastInput} input - Contains origin point, translation vector, and max fraction for the ray\r\n * @param {b2Segment} shape - The line segment defined by two points (point1 and point2)\r\n * @param {boolean} oneSided - Whether to treat the segment as one-sided\r\n * @returns {b2CastOutput} Contains hit status, intersection point, normal, and fraction along the ray\r\n */\r\nexport function b2RayCastSegment(input, shape, oneSided)\r\n{\r\n    if (oneSided)\r\n    {\r\n        // Skip left-side collision\r\n        const offset = b2Cross(b2Sub(input.origin, shape.point1), b2Sub(shape.point2, shape.point1));\r\n\r\n        if (offset < 0.0)\r\n        {\r\n            const output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n            return output;\r\n        }\r\n    }\r\n\r\n    // Put the ray into the edge's frame of reference.\r\n    const p1 = input.origin;\r\n    const d = input.translation;\r\n\r\n    const v1 = shape.point1;\r\n    const v2 = shape.point2;\r\n    const e = b2Sub(v2, v1);\r\n\r\n    const output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n    const res = b2GetLengthAndNormalize(e);\r\n    const length = res.length;\r\n    const eUnit = res.normal;\r\n\r\n    if (length == 0.0)\r\n    {\r\n        return output;\r\n    }\r\n\r\n    // Normal points to the right, looking from v1 towards v2\r\n    let normal = b2RightPerp(eUnit);\r\n\r\n    // Intersect ray with infinite segment using normal\r\n    // Similar to intersecting a ray with an infinite plane\r\n    // p = p1 + t * d\r\n    // dot(normal, p - v1) = 0\r\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\r\n    const numerator = b2Dot(normal, b2Sub(v1, p1));\r\n    const denominator = b2Dot(normal, d);\r\n\r\n    if (denominator == 0.0)\r\n    {\r\n        // parallel\r\n        return output;\r\n    }\r\n\r\n    const t = numerator / denominator;\r\n\r\n    if (t < 0.0 || input.maxFraction < t)\r\n    {\r\n        // out of ray range\r\n        return output;\r\n    }\r\n\r\n    // Intersection point on infinite segment\r\n    const p = b2MulAdd(p1, t, d);\r\n\r\n    // Compute position of p along segment\r\n    // p = v1 + s * e\r\n    // s = dot(p - v1, e) / dot(e, e)\r\n\r\n    const s = b2Dot(b2Sub(p, v1), eUnit);\r\n\r\n    if (s < 0.0 || length < s)\r\n    {\r\n        // out of segment range\r\n        return output;\r\n    }\r\n\r\n    if (numerator > 0.0)\r\n    {\r\n        normal = b2Neg(normal);\r\n    }\r\n\r\n    output.fraction = t;\r\n    output.point = b2MulAdd(p1, t, d);\r\n    output.normal = normal;\r\n    output.hit = true;\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2RayCastPolygon\r\n * @description\r\n * Performs a ray cast against a polygon shape, detecting intersection points and normals.\r\n * For non-zero radius polygons, converts the ray cast into a shape cast operation.\r\n * @param {b2RayCastInput} input - Contains origin point, translation vector, and max fraction\r\n * @param {b2Polygon} shape - The polygon to test against, containing vertices, normals, count and radius\r\n * @returns {b2CastOutput} Contains:\r\n * - hit: boolean indicating if intersection occurred\r\n * - point: intersection point (if hit is true)\r\n * - normal: surface normal at intersection (if hit is true)\r\n * - fraction: fraction of translation where intersection occurred (if hit is true)\r\n * @throws {Error} Throws assertion error if input ray is invalid\r\n */\r\nexport function b2RayCastPolygon(input, shape)\r\n{\r\n    console.assert(b2IsValidRay(input));\r\n\r\n    if (shape.radius === 0.0)\r\n    {\r\n        // Put the ray into the polygon's frame of reference.\r\n        const p1 = input.origin;\r\n        const d = input.translation;\r\n\r\n        let lower = 0.0,\r\n            upper = input.maxFraction;\r\n\r\n        let index = -1;\r\n\r\n        const output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n        for (let i = 0; i < shape.count; ++i)\r\n        {\r\n            // p = p1 + a * d\r\n            // dot(normal, p - v) = 0\r\n            // dot(normal, p1 - v) + a * dot(normal, d) = 0\r\n            const numerator = b2Dot(shape.normals[i], b2Sub(shape.vertices[i], p1));\r\n            const denominator = b2Dot(shape.normals[i], d);\r\n\r\n            if (denominator === 0.0)\r\n            {\r\n                if (numerator < 0.0)\r\n                {\r\n                    return output;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Note = we want this predicate without division:\r\n                // lower < numerator / denominator, where denominator < 0\r\n                // Since denominator < 0, we have to flip the inequality:\r\n                // lower < numerator / denominator <==> denominator * lower > numerator.\r\n                if (denominator < 0.0 && numerator < lower * denominator)\r\n                {\r\n                    // Increase lower.\r\n                    // The segment enters this half-space.\r\n                    lower = numerator / denominator;\r\n                    index = i;\r\n                }\r\n                else if (denominator > 0.0 && numerator < upper * denominator)\r\n                {\r\n                    // Decrease upper.\r\n                    // The segment exits this half-space.\r\n                    upper = numerator / denominator;\r\n                }\r\n            }\r\n\r\n            if (upper < lower)\r\n            {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        console.assert(0.0 <= lower && lower <= input.maxFraction);\r\n\r\n        if (index >= 0)\r\n        {\r\n            output.fraction = lower;\r\n            output.normal = shape.normals[index];\r\n            output.point = b2MulAdd(p1, lower, d);\r\n            output.hit = true;\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    // TODO_ERIN this is not working for ray vs box (zero radii)\r\n    const castInput = new b2ShapeCastPairInput();\r\n    castInput.proxyA = b2MakeProxy(shape.vertices, shape.count, shape.radius);\r\n    castInput.proxyB = b2MakeProxy([ input.origin ], 1, 0.0);\r\n    castInput.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    castInput.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    castInput.translationB = input.translation;\r\n    castInput.maxFraction = input.maxFraction;\r\n\r\n    return b2ShapeCast(castInput);\r\n}\r\n\r\n/**\r\n * @function b2ShapeCastCircle\r\n * @description\r\n * Performs shape casting between a circle and a set of points with radius.\r\n * @param {b2ShapeCastInput} input - Contains points array, count, radius, translation and maxFraction\r\n * @param {b2Circle} shape - Circle shape with center point and radius\r\n * @returns {b2CastOutput} The shape cast result containing intersection details\r\n */\r\nexport function b2ShapeCastCircle(input, shape)\r\n{\r\n    const pairInput = new b2ShapeCastPairInput();\r\n    pairInput.proxyA = b2MakeProxy([ shape.center.clone() ], 1, shape.radius);\r\n    pairInput.proxyB = b2MakeProxy(input.points, input.count, input.radius);\r\n    pairInput.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.translationB = input.translation;\r\n    pairInput.maxFraction = input.maxFraction;\r\n\r\n    const output = b2ShapeCast(pairInput);\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2ShapeCastCapsule\r\n * @description\r\n * Performs shape casting for a capsule shape against a set of points.\r\n * @param {b2ShapeCastInput} input - Contains the target points, count, radius,\r\n * translation, and maxFraction for the shape cast\r\n * @param {b2Capsule} shape - The capsule shape defined by two centers and a radius\r\n * @returns {b2CastOutput} The result of the shape cast operation\r\n */\r\nexport function b2ShapeCastCapsule(input, shape)\r\n{\r\n    const pairInput = new b2ShapeCastPairInput();\r\n    pairInput.proxyA = b2MakeProxy([ shape.center1, shape.center2 ], 2, shape.radius);\r\n    pairInput.proxyB = b2MakeProxy(input.points, input.count, input.radius);\r\n    pairInput.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.translationB = input.translation;\r\n    pairInput.maxFraction = input.maxFraction;\r\n\r\n    const output = b2ShapeCast(pairInput);\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2ShapeCastSegment\r\n * @param {b2ShapeCastInput} input - Contains shape points, count, radius, translation, and maxFraction\r\n * @param {b2Segment} shape - A segment defined by two points (point1 and point2)\r\n * @returns {b2CastOutput} The result of the shape cast operation\r\n * @description\r\n * Performs a shape cast operation between a segment and another shape. The function creates\r\n * proxies for both shapes, sets up their initial transforms, and performs the cast operation\r\n * using the specified translation and maximum fraction.\r\n */\r\nexport function b2ShapeCastSegment(input, shape)\r\n{\r\n    const pairInput = new b2ShapeCastPairInput();\r\n    pairInput.proxyA = b2MakeProxy([ shape.point1, shape.point2 ], 2, 0.0);\r\n    pairInput.proxyB = b2MakeProxy(input.points, input.count, input.radius);\r\n    pairInput.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.translationB = input.translation;\r\n    pairInput.maxFraction = input.maxFraction;\r\n\r\n    const output = b2ShapeCast(pairInput);\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2ShapeCastPolygon\r\n * @description\r\n * Performs shape casting between a polygon shape and a set of points, checking for collisions\r\n * along a translation path.\r\n * @param {b2ShapeCastInput} input - Contains the points, count, radius, translation, and maxFraction for the cast\r\n * @param {b2Polygon} shape - The polygon shape to test against, containing vertices, count, and radius\r\n * @returns {b2CastOutput} The result of the shape cast operation\r\n */\r\nexport function b2ShapeCastPolygon(input, shape)\r\n{\r\n    const pairInput = new b2ShapeCastPairInput();\r\n    pairInput.proxyA = b2MakeProxy(shape.vertices, shape.count, shape.radius);\r\n    pairInput.proxyB = b2MakeProxy(input.points, input.count, input.radius);\r\n    pairInput.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    pairInput.translationB = input.translation;\r\n    pairInput.maxFraction = input.maxFraction;\r\n\r\n    const output = b2ShapeCast(pairInput);\r\n\r\n    return output;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX, b2_aabbMargin, b2_linearSlop, b2_speculativeDistance } from './include/core_h.js';\r\nimport { B2_PROXY_TYPE, b2BroadPhase_CreateProxy, b2BroadPhase_DestroyProxy, b2BroadPhase_MoveProxy } from './include/broad_phase_h.js';\r\nimport {\r\n    b2AABB,\r\n    b2DistanceSquared,\r\n    b2Dot,\r\n    b2InvRotateVector,\r\n    b2InvTransformPoint,\r\n    b2IsValid,\r\n    b2Length,\r\n    b2LengthSquared,\r\n    b2Lerp,\r\n    b2Rot,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\nimport { b2AllocId, b2FreeId } from './include/id_pool_h.js';\r\nimport { b2BodyType, b2DefaultShapeDef, b2ShapeType } from './include/types_h.js';\r\nimport { b2CastOutput, b2ChainSegment, b2Circle, b2DistanceCache, b2DistanceInput, b2DistanceProxy, b2MassData, b2RayCastInput, b2Segment } from './include/collision_h.js';\r\nimport { b2ChainId, b2ShapeId, b2WorldId } from './include/id_h.js';\r\nimport { b2ChainShape, b2Shape, b2ShapeExtent } from './include/shape_h.js';\r\nimport {\r\n    b2ComputeCapsuleAABB,\r\n    b2ComputeCapsuleMass,\r\n    b2ComputeCircleAABB,\r\n    b2ComputeCircleMass,\r\n    b2ComputePolygonAABB,\r\n    b2ComputePolygonMass,\r\n    b2ComputeSegmentAABB,\r\n    b2PointInCapsule,\r\n    b2PointInCircle,\r\n    b2PointInPolygon,\r\n    b2RayCastCapsule,\r\n    b2RayCastCircle,\r\n    b2RayCastPolygon,\r\n    b2RayCastSegment,\r\n    b2ShapeCastCapsule,\r\n    b2ShapeCastCircle,\r\n    b2ShapeCastPolygon,\r\n    b2ShapeCastSegment,\r\n} from './include/geometry_h.js';\r\nimport { b2ContactFlags, b2DestroyContact, b2GetContactSim } from './include/contact_h.js';\r\nimport { b2GetBody, b2GetBodyFullId, b2GetBodyTransform, b2GetBodyTransformQuick, b2MakeBodyId, b2UpdateBodyMassData } from './include/body_h.js';\r\nimport { b2GetWorld, b2GetWorldLocked, b2SetType, b2ValidateSolverSets } from './include/world_h.js';\r\nimport { b2MakeProxy, b2ShapeDistance } from './include/distance_h.js';\r\n\r\n/**\r\n * @namespace Shape\r\n */\r\n\r\n/**\r\n * @import {b2BodyId} from './include/id_h.js'\r\n * @import {b2ShapeDef, b2ChainDef, b2Filter} from './include/types_h.js'\r\n * @import {b2Capsule, b2Polygon, b2Manifold} from './include/collision_h.js'\r\n */\r\n\r\nfunction b2GetShape(world, shapeId)\r\n{\r\n    const id = shapeId.index1 - 1;\r\n\r\n    // b2CheckIdAndRevision(world.shapeArray, id, shapeId.revision);\r\n    const shape = world.shapeArray[id];\r\n\r\n    return shape;\r\n}\r\n\r\nexport function b2GetOwnerTransform(world, shape)\r\n{\r\n    return b2GetBodyTransform(world, shape.bodyId);\r\n}\r\n\r\nfunction b2GetChainShape(world, chainId)\r\n{\r\n    const id = chainId.index1 - 1;\r\n\r\n    // b2CheckIdAndRevision(world.chainArray, id, chainId.revision);\r\n    const chain = world.chainArray[id];\r\n\r\n    return chain;\r\n}\r\n\r\nfunction b2UpdateShapeAABBs(shape, transform, proxyType)\r\n{\r\n    const speculativeDistance = b2_speculativeDistance;\r\n    const aabbMargin = b2_aabbMargin;\r\n\r\n    const aabb = b2ComputeShapeAABB(shape, transform);\r\n    aabb.lowerBoundX -= speculativeDistance;\r\n    aabb.lowerBoundY -= speculativeDistance;\r\n    aabb.upperBoundX += speculativeDistance;\r\n    aabb.upperBoundY += speculativeDistance;\r\n    shape.aabb = aabb;\r\n\r\n    const margin = proxyType == b2BodyType.b2_staticBody ? speculativeDistance : aabbMargin;\r\n    const fatAABB = new b2AABB(aabb.lowerBoundX - margin, aabb.lowerBoundY - margin,\r\n        aabb.upperBoundX + margin, aabb.upperBoundY + margin);\r\n    shape.fatAABB = fatAABB;\r\n}\r\n\r\nfunction b2CreateShapeInternal(world, body, transform, def, geometry, shapeType)\r\n{\r\n    //    B2_ASSERT(b2IsValid(def.density) && def.density >= 0.0);\r\n    //    B2_ASSERT(b2IsValid(def.friction) && def.friction >= 0.0);\r\n    //    B2_ASSERT(b2IsValid(def.restitution) && def.restitution >= 0.0);\r\n\r\n    const shapeId = b2AllocId(world.shapeIdPool);\r\n\r\n    if (shapeId == world.shapeArray.length)\r\n    {\r\n        world.shapeArray.push(new b2Shape());\r\n    }\r\n    \r\n    // eLse:        B2_ASSERT(world.shapeArray[shapeId].id == B2_NULL_INDEX);\r\n\r\n    // b2CheckIndex(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    switch (shapeType)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            shape.capsule = geometry;\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            shape.circle = geometry;\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            shape.polygon = geometry;\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            shape.segment = geometry;\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            shape.chainSegment = geometry;\r\n\r\n            break;\r\n\r\n        default:\r\n            //            B2_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    shape.id = shapeId;\r\n    shape.bodyId = body.id;\r\n    shape.type = shapeType;\r\n    shape.density = def.density;\r\n    shape.friction = def.friction;\r\n    shape.restitution = def.restitution;\r\n    shape.filter = def.filter;\r\n    shape.userData = def.userData;\r\n    shape.customColor = def.customColor;\r\n    shape.isSensor = def.isSensor;\r\n    shape.enlargedAABB = false;\r\n    shape.enableSensorEvents = def.enableSensorEvents;\r\n    shape.enableContactEvents = def.enableContactEvents;\r\n    shape.enableHitEvents = def.enableHitEvents;\r\n    shape.enablePreSolveEvents = def.enablePreSolveEvents;\r\n    shape.isFast = false;\r\n    shape.proxyKey = B2_NULL_INDEX;\r\n    shape.localCentroid = b2GetShapeCentroid(shape);\r\n    shape.aabb = new b2AABB();\r\n    shape.fatAABB = new b2AABB();\r\n    shape.revision += 1;\r\n\r\n    if (body.setIndex != b2SetType.b2_disabledSet)\r\n    {\r\n        const proxyType = body.type;\r\n        b2CreateShapeProxy(shape, world.broadPhase, proxyType, transform, def.forceContactCreation || def.isSensor);\r\n    }\r\n\r\n    if (body.headShapeId != B2_NULL_INDEX)\r\n    {\r\n        // b2CheckId(world.shapeArray, body.headShapeId);\r\n        const headShape = world.shapeArray[body.headShapeId];\r\n        headShape.prevShapeId = shapeId;\r\n    }\r\n\r\n    shape.prevShapeId = B2_NULL_INDEX;\r\n    shape.nextShapeId = body.headShapeId;\r\n    body.headShapeId = shapeId;\r\n    body.shapeCount += 1;\r\n\r\n    b2ValidateSolverSets(world);\r\n\r\n    return shape;\r\n}\r\n\r\nexport function b2CreateShape(bodyId, def, geometry, shapeType)\r\n{\r\n    // b2CheckDef(def);\r\n    console.assert(b2IsValid(def.density) && def.density >= 0.0);\r\n    console.assert(b2IsValid(def.friction) && def.friction >= 0.0);\r\n    console.assert(b2IsValid(def.restitution) && def.restitution >= 0.0);\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return new b2ShapeId( 0, 0, 0 );\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    const shape = b2CreateShapeInternal(world, body, transform, def, geometry, shapeType);\r\n\r\n    if (body.updateBodyMass === true)\r\n    {\r\n        b2UpdateBodyMassData(world, body);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n\r\n    const id = new b2ShapeId(shape.id + 1, bodyId.world0, shape.revision);\r\n\r\n    return id;\r\n}\r\n\r\n/**\r\n * Creates a circle shape and attaches it to a body.\r\n * @function b2CreateCircleShape\r\n * @param {b2BodyId} bodyId - The identifier of the body to attach the shape to\r\n * @param {b2ShapeDef} def - The shape definition containing properties like friction and density\r\n * @param {b2Circle} circle - The circle geometry definition\r\n * @returns {b2ShapeId} The identifier of the created circle shape\r\n */\r\nexport function b2CreateCircleShape(bodyId, def, circle)\r\n{\r\n    return b2CreateShape(bodyId, def, circle, b2ShapeType.b2_circleShape);\r\n}\r\n\r\n/**\r\n * @function b2CreateCapsuleShape\r\n * @summary Creates either a capsule shape or circle shape based on the distance between centers\r\n * @param {b2BodyId} bodyId - The body ID to attach the shape to\r\n * @param {b2ShapeDef} def - The shape definition parameters\r\n * @param {b2Capsule} capsule - The capsule geometry containing center1, center2 and radius\r\n * @returns {b2ShapeId} The ID of the created shape\r\n * @description\r\n * Creates a capsule shape if the distance between centers is greater than b2_linearSlop.\r\n * If centers are closer than b2_linearSlop, creates a circle shape instead with radius\r\n * equal to the capsule radius and center at the midpoint between capsule centers.\r\n */\r\nexport function b2CreateCapsuleShape(bodyId, def, capsule)\r\n{\r\n    const lengthSqr = b2DistanceSquared(capsule.center1, capsule.center2);\r\n\r\n    if (lengthSqr <= b2_linearSlop * b2_linearSlop)\r\n    {\r\n        const circle = new b2Circle();\r\n        circle.center = b2Lerp(capsule.center1, capsule.center2, 0.5);\r\n        circle.radius = capsule.radius;\r\n\r\n        return b2CreateShape(bodyId, def, circle, b2ShapeType.b2_circleShape);\r\n    }\r\n\r\n    return b2CreateShape(bodyId, def, capsule, b2ShapeType.b2_capsuleShape);\r\n}\r\n\r\n/**\r\n * Creates a polygon shape and attaches it to a body.\r\n * @function b2CreatePolygonShape\r\n * @param {b2BodyId} bodyId - The identifier of the body to attach the shape to\r\n * @param {b2ShapeDef} def - The shape definition containing common shape properties\r\n * @param {b2Polygon} polygon - The polygon data including vertices and radius\r\n * @returns {b2ShapeId} The identifier of the created polygon shape\r\n * @throws {Error} Throws an assertion error if the polygon radius is invalid or negative\r\n */\r\nexport function b2CreatePolygonShape(bodyId, def, polygon)\r\n{\r\n    console.assert(b2IsValid(polygon.radius) && polygon.radius >= 0.0);\r\n\r\n    return b2CreateShape(bodyId, def, polygon, b2ShapeType.b2_polygonShape);\r\n}\r\n\r\n/**\r\n * @summary Creates a segment shape attached to a body\r\n * @function b2CreateSegmentShape\r\n * @param {b2BodyId} bodyId - The ID of the body to attach the shape to\r\n * @param {b2ShapeDef} def - The shape definition parameters\r\n * @param {b2Segment} segment - The segment geometry defined by point1 and point2\r\n * @returns {b2ShapeId} The ID of the created segment shape\r\n * @description\r\n * Creates a segment shape between two points and attaches it to the specified body.\r\n * The function validates that the segment length is greater than b2_linearSlop\r\n * before creating the shape.\r\n * @throws {Error} Throws an assertion error if the segment length squared is less\r\n * than or equal to b2_linearSlop squared\r\n */\r\nexport function b2CreateSegmentShape(bodyId, def, segment)\r\n{\r\n    const lengthSqr = b2DistanceSquared(segment.point1, segment.point2);\r\n\r\n    if (lengthSqr <= b2_linearSlop * b2_linearSlop)\r\n    {\r\n        console.assert(false);\r\n\r\n        return new b2ShapeId();\r\n    }\r\n\r\n    return b2CreateShape(bodyId, def, segment, b2ShapeType.b2_segmentShape);\r\n}\r\n\r\nfunction b2DestroyShapeInternal(world, shape, body, wakeBodies)\r\n{\r\n    const shapeId = shape.id;\r\n\r\n    if (shape.prevShapeId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckId(world.shapeArray, shape.prevShapeId);\r\n        world.shapeArray[shape.prevShapeId].nextShapeId = shape.nextShapeId;\r\n    }\r\n\r\n    if (shape.nextShapeId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckId(world.shapeArray, shape.nextShapeId);\r\n        world.shapeArray[shape.nextShapeId].prevShapeId = shape.prevShapeId;\r\n    }\r\n\r\n    if (shapeId === body.headShapeId)\r\n    {\r\n        body.headShapeId = shape.nextShapeId;\r\n    }\r\n\r\n    body.shapeCount -= 1;\r\n\r\n    b2DestroyShapeProxy(shape, world.broadPhase);\r\n\r\n    let contactKey = body.headContactKey;\r\n\r\n    while (contactKey !== B2_NULL_INDEX)\r\n    {\r\n        const contactId = contactKey >> 1;\r\n        const edgeIndex = contactKey & 1;\r\n\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n        contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n        if (contact.shapeIdA === shapeId || contact.shapeIdB === shapeId)\r\n        {\r\n            b2DestroyContact(world, contact, wakeBodies);\r\n        }\r\n    }\r\n\r\n    b2FreeId(world.shapeIdPool, shapeId);\r\n    shape.id = B2_NULL_INDEX;\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2DestroyShape\r\n * @summary Destroys a shape in the physics world and updates the parent body's mass if needed.\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to destroy.\r\n * @description\r\n * Removes a shape from the physics world. If the parent body has automatic mass calculation enabled,\r\n * the body's mass properties are recalculated after the shape is destroyed.\r\n * The function performs the following operations:\r\n * 1. Retrieves the world and shape from the provided shapeId\r\n * 2. Destroys the shape internally\r\n * 3. Updates the parent body's mass data if automatic mass calculation is enabled\r\n */\r\nexport function b2DestroyShape(shapeId)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    const id = shapeId.index1 - 1;\r\n\r\n    // b2CheckIdAndRevision(world.shapeArray, id, shapeId.revision);\r\n\r\n    const shape = world.shapeArray[id];\r\n\r\n    const wakeBodies = true;\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    b2DestroyShapeInternal(world, shape, body, wakeBodies);\r\n\r\n    if (body.updateBodyMass === true)\r\n    {\r\n        b2UpdateBodyMassData(world, body);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2CreateChain\r\n * @description Creates a chain shape composed of connected line segments attached to a body.\r\n * The chain can be either a closed loop or an open chain.\r\n * @param {b2BodyId} bodyId - The ID of the body to attach the chain to\r\n * @param {b2ChainDef} def - The chain definition containing:\r\n * - {number} count - Number of vertices (must be >= 4)\r\n * - {b2Vec2[]} points - Array of vertex points\r\n * - {boolean} isLoop - Whether the chain forms a closed loop\r\n * - {number} friction - Friction coefficient (must be >= 0)\r\n * - {number} restitution - Restitution coefficient (must be >= 0)\r\n * - {b2Filter} filter - Collision filter data\r\n * - {*} userData - User data pointer\r\n * @returns {b2ChainId} The ID of the created chain shape\r\n * @throws {Error} Throws assertion error if friction or restitution are invalid/negative,\r\n * or if count is less than 4\r\n */\r\nexport function b2CreateChain(bodyId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    console.assert(b2IsValid(def.friction) && def.friction >= 0.0);\r\n    console.assert(b2IsValid(def.restitution) && def.restitution >= 0.0);\r\n    console.assert(def.count >= 4);\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return new b2ChainId();\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    const chainId = b2AllocId(world.chainIdPool);\r\n\r\n    if (chainId === world.chainArray.length)\r\n    {\r\n        world.chainArray.push(new b2ChainShape());\r\n    }\r\n\r\n    // b2CheckIndex(world.chainArray, chainId);\r\n    const chainShape = world.chainArray[chainId];\r\n\r\n    chainShape.id = chainId;\r\n    chainShape.bodyId = body.id;\r\n    chainShape.nextChainId = body.headChainId;\r\n    chainShape.revision += 1;\r\n    body.headChainId = chainId;\r\n\r\n    const shapeDef = b2DefaultShapeDef();\r\n    shapeDef.userData = def.userData;\r\n    shapeDef.restitution = def.restitution;\r\n    shapeDef.friction = def.friction;\r\n    shapeDef.filter = def.filter;\r\n    shapeDef.enableContactEvents = false;\r\n    shapeDef.enableHitEvents = false;\r\n    shapeDef.enableSensorEvents = false;\r\n\r\n    const n = def.count;\r\n    const points = def.points;\r\n    let chainSegment;\r\n\r\n    if (def.isLoop)\r\n    {\r\n        chainShape.count = n;\r\n        chainShape.shapeIndices = new Array(n);\r\n\r\n        let prevIndex = n - 1;\r\n\r\n        for (let i = 0; i < n - 2; ++i)\r\n        {\r\n            chainSegment = new b2ChainSegment();\r\n            chainSegment.ghost1 = points[prevIndex].clone();\r\n            chainSegment.segment = new b2Segment();\r\n            chainSegment.segment.point1 = points[i].clone();\r\n            chainSegment.segment.point2 = points[i + 1].clone();\r\n            chainSegment.ghost2 = points[i + 2].clone();\r\n            chainSegment.chainId = chainId;\r\n            prevIndex = i;\r\n\r\n            const shape = b2CreateShapeInternal(world, body, transform, shapeDef, chainSegment, b2ShapeType.b2_chainSegmentShape);\r\n            chainShape.shapeIndices[i] = shape.id;\r\n        }\r\n\r\n        chainSegment = new b2ChainSegment();\r\n        chainSegment.ghost1 = points[n - 3].clone();\r\n        chainSegment.segment = new b2Segment();\r\n        chainSegment.segment.point1 = points[n - 2].clone();\r\n        chainSegment.segment.point2 = points[n - 1].clone();\r\n        chainSegment.ghost2 = points[0].clone();\r\n        chainSegment.chainId = chainId;\r\n        let shape = b2CreateShapeInternal(world, body, transform, shapeDef, chainSegment, b2ShapeType.b2_chainSegmentShape);\r\n        chainShape.shapeIndices[n - 2] = shape.id;\r\n\r\n        chainSegment = new b2ChainSegment();\r\n        chainSegment.ghost1 = points[n - 2].clone();\r\n        chainSegment.segment = new b2Segment();\r\n        chainSegment.segment.point1 = points[n - 1].clone();\r\n        chainSegment.segment.point2 = points[0].clone();\r\n        chainSegment.ghost2 = points[1].clone();\r\n        chainSegment.chainId = chainId;\r\n        shape = b2CreateShapeInternal(world, body, transform, shapeDef, chainSegment, b2ShapeType.b2_chainSegmentShape);\r\n        chainShape.shapeIndices[n - 1] = shape.id;\r\n    }\r\n    else\r\n    {\r\n        chainShape.count = n - 3;\r\n        chainShape.shapeIndices = new Array(n);\r\n\r\n        for (let i = 0; i < n - 3; ++i)\r\n        {\r\n            chainSegment = new b2ChainSegment();\r\n            chainSegment.ghost1 = points[i].clone();\r\n            chainSegment.segment = new b2Segment();\r\n            chainSegment.segment.point1 = points[i + 1].clone();\r\n            chainSegment.segment.point2 = points[i + 2].clone();\r\n            chainSegment.ghost2 = points[i + 3].clone();\r\n            chainSegment.chainId = chainId;\r\n\r\n            const shape = b2CreateShapeInternal(world, body, transform, shapeDef, chainSegment, b2ShapeType.b2_chainSegmentShape);\r\n            chainShape.shapeIndices[i] = shape.id;\r\n        }\r\n    }\r\n\r\n    const id = new b2ChainId(chainId + 1, world.worldId, chainShape.revision);\r\n\r\n    return id;\r\n}\r\n\r\n/**\r\n * @function b2DestroyChain\r\n * @description\r\n * Destroys a chain of shapes attached to a body in a Box2D world. The function removes all shapes\r\n * associated with the chain and frees the chain ID from the world's chain ID pool.\r\n * @param {b2ChainId} chainId - The identifier for the chain to be destroyed, containing world and index information\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if the chain is not found in the body's chain list\r\n */\r\nexport function b2DestroyChain(chainId)\r\n{\r\n    const world = b2GetWorldLocked(chainId.world0);\r\n\r\n    const id = chainId.index1 - 1;\r\n\r\n    // b2CheckIdAndRevision(world.chainArray, id, chainId.revision);\r\n\r\n    const chain = world.chainArray[id];\r\n    const wakeBodies = true;\r\n\r\n    const body = b2GetBody(world, chain.bodyId);\r\n\r\n    // Remove the chain from the body's singly linked list.\r\n    let chainIdPtr = body.headChainId;\r\n    let found = false;\r\n\r\n    while (chainIdPtr !== null)\r\n    {\r\n        if (chainIdPtr === chain.id)\r\n        {\r\n            // chainIdPtr = chain.nextChainId;       // PJB - it's in the C but removed to prevent lint \"no-useless-assignment\"\r\n            found = true;\r\n\r\n            break;\r\n        }\r\n\r\n        chainIdPtr = world.chainArray[chainIdPtr].nextChainId;\r\n    }\r\n\r\n    console.assert(found === true);\r\n\r\n    if (found === false)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const count = chain.count;\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        const shapeId = chain.shapeIndices[i];\r\n\r\n        // b2CheckId(world.shapeArray, shapeId);\r\n        const shape = world.shapeArray[shapeId];\r\n        b2DestroyShapeInternal(world, shape, body, wakeBodies);\r\n    }\r\n\r\n    chain.shapeIndices = null;\r\n\r\n    // Return chain to free list.\r\n    b2FreeId(world.chainIdPool, id);\r\n    chain.id = null;\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\nexport function b2ComputeShapeAABB(shape, xf)\r\n{\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return b2ComputeCapsuleAABB(shape.capsule, xf);\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return b2ComputeCircleAABB(shape.circle, xf);\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            return b2ComputePolygonAABB(shape.polygon, xf);\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            return b2ComputeSegmentAABB(shape.segment, xf);\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            return b2ComputeSegmentAABB(shape.chainSegment.segment, xf);\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new b2AABB(xf.p.x, xf.p.y, xf.p.x, xf.p.y);\r\n    }\r\n}\r\n\r\nexport function b2GetShapeCentroid(shape)\r\n{\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return b2Lerp(shape.capsule.center1, shape.capsule.center2, 0.5);\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return shape.circle.center.clone();\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            return shape.polygon.centroid.clone();\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            return b2Lerp(shape.segment.point1, shape.segment.point2, 0.5);\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            return b2Lerp(shape.chainSegment.segment.point1, shape.chainSegment.segment.point2, 0.5);\r\n\r\n        default:\r\n            return new b2Vec2(0, 0);\r\n    }\r\n}\r\n\r\nexport function b2GetShapePerimeter(shape)\r\n{\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return 2.0 * b2Length(b2Sub(shape.capsule.center1, shape.capsule.center2)) +\r\n                   2.0 * Math.PI * shape.capsule.radius;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return 2.0 * Math.PI * shape.circle.radius;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n        {\r\n            const points = shape.polygon.vertices;\r\n            const count = shape.polygon.count;\r\n            let perimeter = 2.0 * Math.PI * shape.polygon.radius;\r\n            console.assert(count > 0);\r\n            let prev = points[count - 1];\r\n\r\n            for (let i = 0; i < count; ++i)\r\n            {\r\n                const next = points[i];\r\n                perimeter += b2Length(b2Sub(next, prev));\r\n                prev = next;\r\n            }\r\n\r\n            return perimeter;\r\n        }\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            return 2.0 * b2Length(b2Sub(shape.segment.point1, shape.segment.point2));\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            return 2.0 * b2Length(b2Sub(shape.chainSegment.segment.point1, shape.chainSegment.segment.point2));\r\n\r\n        default:\r\n            return 0.0;\r\n    }\r\n}\r\n\r\nexport function b2ComputeShapeMass(shape)\r\n{\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return b2ComputeCapsuleMass(shape.capsule, shape.density);\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return b2ComputeCircleMass(shape.circle, shape.density);\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            return b2ComputePolygonMass(shape.polygon, shape.density);\r\n\r\n        default:\r\n            return new b2MassData();\r\n    }\r\n}\r\n\r\nexport function b2ComputeShapeExtent(shape, localCenter)\r\n{\r\n    const extent = new b2ShapeExtent();\r\n\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            {\r\n                const radius = shape.capsule.radius;\r\n                extent.minExtent = radius;\r\n                const c1 = b2Sub(shape.capsule.center1, localCenter);\r\n                const c2 = b2Sub(shape.capsule.center2, localCenter);\r\n                extent.maxExtent = Math.sqrt(Math.max(b2LengthSquared(c1), b2LengthSquared(c2))) + radius;\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            {\r\n                const radius = shape.circle.radius;\r\n                extent.minExtent = radius;\r\n                extent.maxExtent = b2Length(b2Sub(shape.circle.center, localCenter)) + radius;\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            {\r\n                const poly = shape.polygon;\r\n                let minExtent = Number.MAX_VALUE;\r\n                let maxExtentSqr = 0.0;\r\n                const count = poly.count;\r\n\r\n                for (let i = 0; i < count; ++i)\r\n                {\r\n                    const v = poly.vertices[i];\r\n                    const planeOffset = b2Dot(poly.normals[i], b2Sub(v, poly.centroid));\r\n                    minExtent = Math.min(minExtent, planeOffset);\r\n\r\n                    const distanceSqr = b2LengthSquared(b2Sub(v, localCenter));\r\n                    maxExtentSqr = Math.max(maxExtentSqr, distanceSqr);\r\n                }\r\n\r\n                extent.minExtent = minExtent + poly.radius;\r\n                extent.maxExtent = Math.sqrt(maxExtentSqr) + poly.radius;\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            {\r\n                extent.minExtent = 0.0;\r\n                const c1 = b2Sub(shape.segment.point1, localCenter);\r\n                const c2 = b2Sub(shape.segment.point2, localCenter);\r\n                extent.maxExtent = Math.sqrt(Math.max(b2LengthSquared(c1), b2LengthSquared(c2)));\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            {\r\n                extent.minExtent = 0.0;\r\n                const c1 = b2Sub(shape.chainSegment.segment.point1, localCenter);\r\n                const c2 = b2Sub(shape.chainSegment.segment.point2, localCenter);\r\n                extent.maxExtent = Math.sqrt(Math.max(b2LengthSquared(c1), b2LengthSquared(c2)));\r\n            }\r\n\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return extent;\r\n}\r\n\r\nconst rayPoint = new b2Vec2(0, 0);\r\nconst rayNormal = new b2Vec2(0, 1);\r\n\r\nexport function b2RayCastShape(input, shape, transform)\r\n{\r\n    const localInput = input;\r\n    localInput.origin = b2InvTransformPoint(transform, input.origin);\r\n    localInput.translation = b2InvRotateVector(transform.q, input.translation);\r\n\r\n    let output = new b2CastOutput();\r\n    output.hit = false;\r\n    output.fraction = 0.0;\r\n    output.normal = new b2Vec2(0, 0);\r\n    output.point = new b2Vec2(0, 0);\r\n\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            output = b2RayCastCapsule(localInput, shape.capsule);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            output = b2RayCastCircle(localInput, shape.circle);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            output = b2RayCastPolygon(localInput, shape.polygon);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            output = b2RayCastSegment(localInput, shape.segment, false);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            output = b2RayCastSegment(localInput, shape.chainSegment.segment, true);\r\n\r\n            break;\r\n\r\n        default:\r\n            return output;\r\n    }\r\n\r\n    output.point = b2TransformPoint(transform, output.point);\r\n    output.normal = b2RotateVector(transform.q, output.normal);\r\n\r\n    return output;\r\n}\r\n\r\nexport function b2ShapeCastShape(input, shape, transform)\r\n{\r\n    const localInput = input;\r\n\r\n    for (let i = 0; i < localInput.count; ++i)\r\n    {\r\n        localInput.points[i] = b2InvTransformPoint(transform, input.points[i]);\r\n    }\r\n\r\n    localInput.translation = b2InvRotateVector(transform.q, input.translation);\r\n\r\n    let output = new b2CastOutput();\r\n    output.hit = false;\r\n    output.fraction = 0.0;\r\n    output.normal = new b2Vec2(0, 0);\r\n    output.point = new b2Vec2(0, 0);\r\n\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            output = b2ShapeCastCapsule(localInput, shape.capsule);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            output = b2ShapeCastCircle(localInput, shape.circle);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            output = b2ShapeCastPolygon(localInput, shape.polygon);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            output = b2ShapeCastSegment(localInput, shape.segment);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            output = b2ShapeCastSegment(localInput, shape.chainSegment.segment);\r\n\r\n            break;\r\n\r\n        default:\r\n            return output;\r\n    }\r\n\r\n    output.point = b2TransformPoint(transform, output.point);\r\n    output.normal = b2RotateVector(transform.q, output.normal);\r\n\r\n    return output;\r\n}\r\n\r\nexport function b2CreateShapeProxy(shape, bp, type, transform, forcePairCreation)\r\n{\r\n    console.assert(shape.proxyKey == B2_NULL_INDEX);\r\n\r\n    b2UpdateShapeAABBs(shape, transform, type);\r\n\r\n    // Create proxies in the broad-phase.\r\n    shape.proxyKey = b2BroadPhase_CreateProxy(bp, type, shape.fatAABB, shape.filter.categoryBits, shape.id, forcePairCreation);\r\n    console.assert(B2_PROXY_TYPE(shape.proxyKey) < b2BodyType.b2_bodyTypeCount);\r\n}\r\n\r\nexport function b2DestroyShapeProxy(shape, bp)\r\n{\r\n    if (shape.proxyKey != B2_NULL_INDEX)\r\n    {\r\n        b2BroadPhase_DestroyProxy(bp, shape.proxyKey);\r\n        shape.proxyKey = B2_NULL_INDEX;\r\n    }\r\n}\r\n\r\nexport function b2MakeShapeDistanceProxy(shape)\r\n{\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return b2MakeProxy([ shape.capsule.center1.clone(), shape.capsule.center2.clone() ], 2, shape.capsule.radius);\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return b2MakeProxy([ shape.circle.center.clone() ], 1, shape.circle.radius);\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            return b2MakeProxy(shape.polygon.vertices, shape.polygon.count, shape.polygon.radius);\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            return b2MakeProxy([ shape.segment.point1, shape.segment.point2 ], 2, 0.0);\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            return b2MakeProxy([ shape.chainSegment.segment.point1.clone(), shape.chainSegment.segment.point2.clone() ], 2, 0.0);\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new b2DistanceProxy();\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetBody\r\n * @summary Gets the body ID associated with a given shape ID.\r\n * @param {b2ShapeId} shapeId - The ID of the shape to query.\r\n * @returns {b2BodyId} The ID of the body that owns the shape.\r\n * @description\r\n * Retrieves the body ID for a given shape by first accessing the world object,\r\n * then getting the shape from the world, and finally creating a body ID\r\n * from the shape's stored body reference.\r\n */\r\nexport function b2Shape_GetBody(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return b2MakeBodyId(world, shape.bodyId);\r\n}\r\n\r\nexport function b2Shape_GetWorld(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n\r\n    return new b2WorldId(shapeId.world0 + 1, world.revision);\r\n}\r\n\r\n/**\r\n * @summary Sets the user data associated with a shape.\r\n * @function b2Shape_SetUserData\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to modify.\r\n * @param {*} userData - The user data to associate with the shape.\r\n * @returns {void}\r\n * @description\r\n * Associates arbitrary user data with a shape identified by shapeId. The shape must exist\r\n * in the world referenced by the shapeId. The function retrieves the shape from the world\r\n * and updates its userData property.\r\n */\r\nexport function b2Shape_SetUserData(shapeId, userData)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.userData = userData;\r\n}\r\n\r\n/**\r\n * @summary Gets the user data associated with a shape.\r\n * @function b2Shape_GetUserData\r\n * @param {b2ShapeId} shapeId - The identifier for the shape.\r\n * @returns {void} The user data associated with the shape.\r\n * @description\r\n * This function retrieves the user data that was previously attached to a shape\r\n * by looking up the shape in the world using the provided shape ID.\r\n */\r\nexport function b2Shape_GetUserData(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.userData;\r\n}\r\n\r\n/**\r\n * Checks if a shape is marked as a sensor.\r\n * @function b2Shape_IsSensor\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check.\r\n * @returns {boolean} True if the shape is a sensor, false otherwise.\r\n * @description\r\n * Retrieves a shape from the physics world using its ID and returns\r\n * whether it is configured as a sensor. Sensor shapes detect collisions\r\n * but do not generate physical responses.\r\n */\r\nexport function b2Shape_IsSensor(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.isSensor;\r\n}\r\n\r\n/**\r\n * Tests if a point lies within a shape.\r\n * @function b2Shape_TestPoint\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to test against\r\n * @param {b2Vec2} point - The world space point to test\r\n * @returns {boolean} True if the point is inside the shape, false otherwise\r\n * @description\r\n * Transforms the test point into the shape's local space and performs\r\n * point-in-shape testing based on the shape type (capsule, circle, or polygon).\r\n * Returns false for unrecognized shape types.\r\n */\r\nexport function b2Shape_TestPoint(shapeId, point)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    const transform = b2GetOwnerTransform(world, shape);\r\n    const localPoint = b2InvTransformPoint(transform, point);\r\n\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            return b2PointInCapsule(localPoint, shape.capsule);\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            return b2PointInCircle(localPoint, shape.circle);\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            return b2PointInPolygon(localPoint, shape.polygon);\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Shape_RayCast\r\n * @description\r\n * Performs a ray cast against a shape in world space, transforming the input/output\r\n * between local and world coordinates.\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to test\r\n * @param {b2Vec2} origin - The starting point of the ray in world coordinates\r\n * @param {b2Vec2} translation - The direction and length of the ray in world coordinates\r\n * @returns {b2CastOutput} The ray cast results containing:\r\n * - hit: boolean indicating if the ray intersects the shape\r\n * - point: intersection point in world coordinates (if hit is true)\r\n * - normal: surface normal at intersection in world coordinates (if hit is true)\r\n * - fraction: fraction of translation where intersection occurs (if hit is true)\r\n * @throws {Error} Throws assertion error if shape type is invalid\r\n */\r\nexport function b2Shape_RayCast(shapeId, origin, translation)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    const transform = b2GetOwnerTransform(world, shape);\r\n\r\n    // input in local coordinates\r\n    const input = new b2RayCastInput();\r\n    input.maxFraction = 1.0;\r\n    input.origin = b2InvTransformPoint(transform, origin);\r\n    input.translation = b2InvRotateVector(transform.q, translation);\r\n\r\n    let output = new b2CastOutput(rayNormal, rayPoint);\r\n\r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            output = b2RayCastCapsule(input, shape.capsule);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            output = b2RayCastCircle(input, shape.circle);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            output = b2RayCastSegment(input, shape.segment, false);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            output = b2RayCastPolygon(input, shape.polygon);\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            output = b2RayCastSegment(input, shape.chainSegment.segment, true);\r\n\r\n            break;\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return output;\r\n    }\r\n\r\n    if (output.hit)\r\n    {\r\n        // convert to world coordinates\r\n        output.normal = b2RotateVector(transform.q, output.normal);\r\n        output.point = b2TransformPoint(transform, output.point);\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * @function b2Shape_SetDensity\r\n * @summary Sets the density of a shape and optionally updates the parent body's mass.\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to modify.\r\n * @param {number} density - The new density value. Must be non-negative.\r\n * @returns {void}\r\n * @description\r\n * Sets a new density value for the specified shape. If the new density matches\r\n * the current density, no changes are made. The function performs validation\r\n * to ensure the density is a valid non-negative number.\r\n * @throws {Error} Throws an assertion error if the density is invalid or negative.\r\n */\r\nexport function b2Shape_SetDensity(shapeId, density)\r\n{\r\n    console.assert(b2IsValid(density) && density >= 0.0);\r\n\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world == null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    if (density == shape.density)\r\n    {\r\n        // early return to avoid expensive function\r\n        return;\r\n    }\r\n\r\n    shape.density = density;\r\n}\r\n\r\n/**\r\n * @summary Gets the density value of a shape.\r\n * @function b2Shape_GetDensity\r\n * @param {b2ShapeId} shapeId - The identifier for the shape within a Box2D world.\r\n * @returns {number} The density value of the specified shape.\r\n * @description\r\n * Retrieves the density property of a shape by first accessing the world object\r\n * using the world identifier stored in the shapeId, then accessing the specific\r\n * shape within that world.\r\n */\r\nexport function b2Shape_GetDensity(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.density;\r\n}\r\n\r\n/**\r\n * Sets the friction coefficient for a shape.\r\n * @function b2Shape_SetFriction\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to modify\r\n * @param {number} friction - The friction coefficient value (must be >= 0)\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if friction is invalid or negative\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n * @description\r\n * Sets a new friction value for the specified shape. The operation will not proceed\r\n * if the physics world is locked. The friction parameter must be a valid number\r\n * greater than or equal to zero.\r\n */\r\nexport function b2Shape_SetFriction(shapeId, friction)\r\n{\r\n    console.assert(b2IsValid(friction) && friction >= 0.0);\r\n\r\n    const world = b2GetWorld(shapeId.world0);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.friction = friction;\r\n}\r\n\r\n/**\r\n * Gets the friction coefficient of a shape.\r\n * @function b2Shape_GetFriction\r\n * @param {b2ShapeId} shapeId - The identifier for the shape in the physics world.\r\n * @returns {number} The friction coefficient of the shape.\r\n * @description\r\n * Retrieves the friction value from a shape object in the Box2D physics world\r\n * using the provided shape identifier.\r\n */\r\nexport function b2Shape_GetFriction(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.friction;\r\n}\r\n\r\n/**\r\n * Sets the restitution (bounciness) value for a shape.\r\n * @function b2Shape_SetRestitution\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to modify.\r\n * @param {number} restitution - The restitution value to set. Must be non-negative.\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if restitution is invalid or negative,\r\n * or if the world is locked.\r\n */\r\nexport function b2Shape_SetRestitution(shapeId, restitution)\r\n{\r\n    console.assert(b2IsValid(restitution) && restitution >= 0.0);\r\n\r\n    const world = b2GetWorld(shapeId.world0);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.restitution = restitution;\r\n}\r\n\r\n/**\r\n * Gets the restitution coefficient of a shape.\r\n * @function b2Shape_GetRestitution\r\n * @param {b2ShapeId} shapeId - The identifier for the shape in the physics world.\r\n * @returns {number} The restitution coefficient of the shape.\r\n * @description\r\n * Retrieves the restitution (bounciness) value associated with the specified shape\r\n * from the physics world.\r\n */\r\nexport function b2Shape_GetRestitution(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.restitution;\r\n}\r\n\r\n/**\r\n * Gets the filter data for a shape.\r\n * @function b2Shape_GetFilter\r\n * @param {b2ShapeId} shapeId - The identifier for the shape.\r\n * @returns {b2Filter} The collision filter data associated with the shape.\r\n * @description\r\n * Retrieves the collision filtering data from a shape by first accessing the world\r\n * object using the world identifier stored in the shapeId, then accessing the\r\n * shape within that world using the shapeId.\r\n */\r\nexport function b2Shape_GetFilter(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.filter;\r\n}\r\n\r\n// Static function, not exported\r\nfunction b2ResetProxy(world, shape, wakeBodies, destroyProxy)\r\n{\r\n    const body = b2GetBody(world, shape.bodyId);\r\n\r\n    const shapeId = shape.id;\r\n\r\n    // destroy all contacts associated with this shape\r\n    let contactKey = body.headContactKey;\r\n\r\n    while (contactKey !== B2_NULL_INDEX)\r\n    {\r\n        const contactId = contactKey >> 1;\r\n        const edgeIndex = contactKey & 1;\r\n\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n        contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n        if (contact.shapeIdA === shapeId || contact.shapeIdB === shapeId)\r\n        {\r\n            b2DestroyContact(world, contact, wakeBodies);\r\n        }\r\n    }\r\n\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    if (shape.proxyKey !== B2_NULL_INDEX)\r\n    {\r\n        const proxyType = B2_PROXY_TYPE(shape.proxyKey);\r\n        b2UpdateShapeAABBs(shape, transform, proxyType);\r\n\r\n        if (destroyProxy)\r\n        {\r\n            b2BroadPhase_DestroyProxy(world.broadPhase, shape.proxyKey);\r\n\r\n            const forcePairCreation = true;\r\n            shape.proxyKey = b2BroadPhase_CreateProxy(world.broadPhase, proxyType, shape.fatAABB, shape.filter.categoryBits,\r\n                shapeId, forcePairCreation);\r\n        }\r\n        else\r\n        {\r\n            b2BroadPhase_MoveProxy(world.broadPhase, shape.proxyKey, shape.fatAABB);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const proxyType = body.type;\r\n        b2UpdateShapeAABBs(shape, transform, proxyType);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * Sets the collision filter for a shape.\r\n * @function b2Shape_SetFilter\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to modify.\r\n * @param {b2Filter} filter - The new collision filter settings to apply.\r\n * @returns {void}\r\n * @description\r\n * Updates the collision filter properties of a shape. If the new filter settings\r\n * match the existing ones, no changes are made. When the categoryBits change,\r\n * the shape's broad-phase proxy is destroyed and recreated. The function also\r\n * wakes connected bodies when the filter changes.\r\n */\r\nexport function b2Shape_SetFilter(shapeId, filter)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    if (filter.maskBits === shape.filter.maskBits && filter.categoryBits === shape.filter.categoryBits &&\r\n        filter.groupIndex === shape.filter.groupIndex)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // If the category bits change, I need to destroy the proxy because it affects the tree sorting.\r\n    const destroyProxy = filter.categoryBits === shape.filter.categoryBits;\r\n\r\n    shape.filter = filter;\r\n\r\n    // need to wake bodies because a filter change may destroy contacts\r\n    const wakeBodies = true;\r\n    b2ResetProxy(world, shape, wakeBodies, destroyProxy);\r\n}\r\n\r\n/**\r\n * @function b2Shape_EnableSensorEvents\r\n * @summary Enables or disables sensor events for a specific shape.\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to modify.\r\n * @param {boolean} flag - True to enable sensor events, false to disable them.\r\n * @returns {void}\r\n * @description\r\n * Sets the enableSensorEvents property of a shape in the physics world. The shape\r\n * must exist in a valid world context for the operation to succeed.\r\n */\r\nexport function b2Shape_EnableSensorEvents(shapeId, flag)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.enableSensorEvents = flag;\r\n}\r\n\r\n/**\r\n * Checks if sensor events are enabled for a given shape.\r\n * @function b2Shape_AreSensorEventsEnabled\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check.\r\n * @returns {boolean} True if sensor events are enabled for the shape, false otherwise.\r\n * @description\r\n * This function retrieves a shape from the physics world using its ID and returns\r\n * the state of its sensor events flag.\r\n */\r\nexport function b2Shape_AreSensorEventsEnabled(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.enableSensorEvents;\r\n}\r\n\r\n/**\r\n * @summary Enables or disables contact events for a shape.\r\n * @function b2Shape_EnableContactEvents\r\n * @param {b2ShapeId} shapeId - The identifier for the shape.\r\n * @param {boolean} flag - True to enable contact events, false to disable.\r\n * @returns {void}\r\n * @description\r\n * Sets whether a shape should generate contact events during collision detection.\r\n * The shape must belong to a valid world, otherwise the function returns without effect.\r\n */\r\nexport function b2Shape_EnableContactEvents(shapeId, flag)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.enableContactEvents = flag;\r\n}\r\n\r\n/**\r\n * Checks if contact events are enabled for a given shape.\r\n * @function b2Shape_AreContactEventsEnabled\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check.\r\n * @returns {boolean} True if contact events are enabled for the shape, false otherwise.\r\n * @description\r\n * This function retrieves a shape from the physics world using its ID and checks\r\n * the enableContactEvents property of that shape.\r\n */\r\nexport function b2Shape_AreContactEventsEnabled(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.enableContactEvents;\r\n}\r\n\r\n/**\r\n * @function b2Shape_EnablePreSolveEvents\r\n * @param {b2ShapeId} shapeId - The identifier for the shape in the physics world\r\n * @param {boolean} flag - Boolean value to enable or disable pre-solve events for the shape\r\n * @returns {void}\r\n * @description\r\n * Enables or disables pre-solve events for a specific shape in the physics simulation.\r\n * The function first validates the world reference and returns if invalid.\r\n * If valid, it updates the shape's pre-solve events setting according to the flag parameter.\r\n */\r\nexport function b2Shape_EnablePreSolveEvents(shapeId, flag)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.enablePreSolveEvents = flag;\r\n}\r\n\r\n/**\r\n * @summary Checks if pre-solve events are enabled for a given shape.\r\n * @function b2Shape_ArePreSolveEventsEnabled\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check.\r\n * @returns {boolean} True if pre-solve events are enabled for the shape, false otherwise.\r\n * @description\r\n * This function retrieves a shape from the physics world using its ID and checks\r\n * the enablePreSolveEvents property of that shape.\r\n */\r\nexport function b2Shape_ArePreSolveEventsEnabled(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.enablePreSolveEvents;\r\n}\r\n\r\n/**\r\n * @summary Enables or disables hit event notifications for a shape.\r\n * @function b2Shape_EnableHitEvents\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to modify.\r\n * @param {boolean} flag - True to enable hit events, false to disable.\r\n * @returns {void}\r\n * @description\r\n * Sets whether a shape should generate hit events during collision detection.\r\n * The shape must belong to a valid world, otherwise the function returns without effect.\r\n * @throws {Error} If the world associated with the shapeId is locked.\r\n */\r\nexport function b2Shape_EnableHitEvents(shapeId, flag)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.enableHitEvents = flag;\r\n}\r\n\r\n/**\r\n * Checks if hit events are enabled for a given shape.\r\n * @function b2Shape_AreHitEventsEnabled\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check.\r\n * @returns {boolean} True if hit events are enabled for the shape, false otherwise.\r\n * @description\r\n * This function retrieves a shape from the physics world using its ID and checks\r\n * if hit events are enabled for that shape by accessing the enableHitEvents property.\r\n */\r\nexport function b2Shape_AreHitEventsEnabled(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.enableHitEvents;\r\n}\r\n\r\n/**\r\n * Gets the type of a shape from the physics world using its shape ID.\r\n * @function b2Shape_GetType\r\n * @param {b2ShapeId} shapeId - The ID of the shape to query\r\n * @returns {b2ShapeType} The type of the specified shape\r\n * @description\r\n * Retrieves a shape from the physics world using the provided shape ID\r\n * and returns its type classification.\r\n */\r\nexport function b2Shape_GetType(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.type;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetCircle\r\n * @param {b2ShapeId} shapeId - A shape identifier containing world and shape reference\r\n * @returns {b2Circle} The circle shape object\r\n * @description\r\n * Retrieves a circle shape from the physics world using the provided shape identifier.\r\n * @throws {Error} Throws an assertion error if the shape type is not b2_circleShape\r\n */\r\nexport function b2Shape_GetCircle(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    console.assert(shape.type === b2ShapeType.b2_circleShape);\r\n\r\n    return shape.circle;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetSegment\r\n * @param {b2ShapeId} shapeId - A shape identifier containing world and shape reference\r\n * @returns {b2Segment} The segment data from the specified shape\r\n * @description\r\n * Retrieves the segment data from a shape in the physics world. The shape must be of type b2_segmentShape.\r\n * @throws {Error} Throws an assertion error if the shape type is not b2_segmentShape\r\n */\r\nexport function b2Shape_GetSegment(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    console.assert(shape.type === b2ShapeType.b2_segmentShape);\r\n\r\n    return shape.segment;\r\n}\r\n\r\n/**\r\n * Gets the chain segment data from a shape identified by its ID.\r\n * @function b2Shape_GetChainSegment\r\n * @param {Object} shapeId - An object containing the shape identifier and world reference.\r\n * @param {number} shapeId.world0 - The world identifier.\r\n * @returns {Object} The chain segment data associated with the shape.\r\n * @throws {Error} Throws an assertion error if the shape type is not b2_chainSegmentShape.\r\n */\r\nexport function b2Shape_GetChainSegment(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    console.assert(shape.type === b2ShapeType.b2_chainSegmentShape);\r\n\r\n    return shape.chainSegment;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetCapsule\r\n * @param {b2ShapeId} shapeId - A shape identifier containing world and shape reference information\r\n * @returns {b2Capsule} The capsule shape data associated with the given shape ID\r\n * @description\r\n * Retrieves the capsule shape data from a shape in the physics world using the provided shape ID.\r\n * @throws {Error} Throws an assertion error if the shape type is not b2_capsuleShape\r\n */\r\nexport function b2Shape_GetCapsule(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    console.assert(shape.type === b2ShapeType.b2_capsuleShape);\r\n\r\n    return shape.capsule;\r\n}\r\n\r\n/**\r\n * Gets a polygon shape from a shape ID.\r\n * @function b2Shape_GetPolygon\r\n * @param {b2ShapeId} shapeId - The ID of the shape to retrieve.\r\n * @returns {b2Polygon} The polygon shape associated with the given shape ID.\r\n * @throws {Error} Throws an assertion error if the shape type is not b2_polygonShape.\r\n */\r\nexport function b2Shape_GetPolygon(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n    console.assert(shape.type === b2ShapeType.b2_polygonShape);\r\n\r\n    return shape.polygon;\r\n}\r\n\r\n/**\r\n * @function b2Shape_SetCircle\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to be modified\r\n * @param {b2Circle} circle - The circle shape configuration to set\r\n * @returns {void}\r\n * @description\r\n * Sets a shape's type to circle and updates its properties. The function updates\r\n * the shape's proxy in the broad-phase collision system and can wake connected bodies.\r\n * If the world is locked or invalid, the function returns without making changes.\r\n */\r\nexport function b2Shape_SetCircle(shapeId, circle)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.circle = circle;\r\n    shape.type = b2ShapeType.b2_circleShape;\r\n\r\n    // need to wake bodies so they can react to the shape change\r\n    const wakeBodies = true;\r\n    const destroyProxy = true;\r\n    b2ResetProxy(world, shape, wakeBodies, destroyProxy);\r\n}\r\n\r\n/**\r\n * @function b2Shape_SetCapsule\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to be modified\r\n * @param {b2Capsule} capsule - The capsule shape configuration to set\r\n * @returns {void}\r\n * @description\r\n * Sets a shape's type to capsule and updates its configuration. The function\r\n * resets the shape's proxy in the broad-phase collision system, optionally\r\n * waking connected bodies and destroying the existing proxy.\r\n * @throws {Error} If the world reference is invalid (null)\r\n */\r\nexport function b2Shape_SetCapsule(shapeId, capsule)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.capsule = capsule;\r\n    shape.type = b2ShapeType.b2_capsuleShape;\r\n\r\n    // need to wake bodies so they can react to the shape change\r\n    const wakeBodies = true;\r\n    const destroyProxy = true;\r\n    b2ResetProxy(world, shape, wakeBodies, destroyProxy);\r\n}\r\n\r\n/**\r\n * @function b2Shape_SetSegment\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to be modified\r\n * @param {b2Segment} segment - The segment data to assign to the shape\r\n * @returns {void}\r\n * @description\r\n * Sets a shape's type to segment and updates its segment data. After updating,\r\n * it resets the shape's collision proxy in the physics world. The function requires\r\n * a valid world lock to execute successfully.\r\n */\r\nexport function b2Shape_SetSegment(shapeId, segment)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.segment = segment;\r\n    shape.type = b2ShapeType.b2_segmentShape;\r\n\r\n    // need to wake bodies so they can react to the shape change\r\n    const wakeBodies = true;\r\n    const destroyProxy = true;\r\n    b2ResetProxy(world, shape, wakeBodies, destroyProxy);\r\n}\r\n\r\n/**\r\n * @function b2Shape_SetPolygon\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to be modified\r\n * @param {b2Polygon} polygon - The polygon data to assign to the shape\r\n * @returns {void}\r\n * @description\r\n * Sets a shape's type to polygon and assigns polygon data to it. The function\r\n * updates the shape's proxy in the broad-phase collision system and can wake\r\n * connected bodies.\r\n * @throws {Error} If the world associated with the shapeId is not found\r\n */\r\nexport function b2Shape_SetPolygon(shapeId, polygon)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    shape.polygon = polygon;\r\n    shape.type = b2ShapeType.b2_polygonShape;\r\n\r\n    // need to wake bodies so they can react to the shape change\r\n    const wakeBodies = true;\r\n    const destroyProxy = true;\r\n    b2ResetProxy(world, shape, wakeBodies, destroyProxy);\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetParentChain\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to check for parent chain\r\n * @returns {b2ChainId} A b2ChainId object. Returns an empty b2ChainId (default values) if the shape\r\n * is not a chain segment shape or has no parent chain\r\n * @description\r\n * Retrieves the parent chain identifier for a given shape if it is a chain segment shape\r\n * and has an associated chain. The function checks if the shape is of type b2_chainSegmentShape\r\n * and has a valid chain reference before returning the chain identifier.\r\n */\r\nexport function b2Shape_GetParentChain(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    if (shape.type === b2ShapeType.b2_chainSegmentShape)\r\n    {\r\n        const chainId = shape.chainSegment.chainId;\r\n\r\n        if (chainId !== B2_NULL_INDEX)\r\n        {\r\n            // b2CheckId(world.chainArray, chainId);\r\n            const chain = world.chainArray[chainId];\r\n\r\n            return new b2ChainId(chainId + 1, shapeId.world0, chain.revision);\r\n        }\r\n    }\r\n\r\n    return new b2ChainId();\r\n}\r\n\r\n/**\r\n * Sets the friction value for all shapes in a chain.\r\n * @function b2Chain_SetFriction\r\n * @param {b2ChainId} chainId - The identifier for the chain whose friction will be modified\r\n * @param {number} friction - The friction value to set for all shapes in the chain\r\n * @returns {void}\r\n * @description\r\n * Updates the friction property of each shape within the specified chain. The function\r\n * retrieves the chain shape from the world, then iterates through all shapes in the\r\n * chain and sets their friction to the specified value.\r\n */\r\nexport function b2Chain_SetFriction(chainId, friction)\r\n{\r\n    const world = b2GetWorldLocked(chainId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const chainShape = b2GetChainShape(world, chainId);\r\n\r\n    const count = chainShape.count;\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        const shapeId = chainShape.shapeIndices[i];\r\n\r\n        // b2CheckId(world.shapeArray, shapeId);\r\n        const shape = world.shapeArray[shapeId];\r\n        shape.friction = friction;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Chain_SetRestitution\r\n * @summary Sets the restitution value for all shapes in a chain.\r\n * @param {b2ChainId} chainId - The identifier for the chain whose restitution will be set\r\n * @param {number} restitution - The restitution value to apply to all shapes in the chain\r\n * @returns {void}\r\n * @description\r\n * Sets the restitution coefficient for all shapes that make up the specified chain.\r\n * If the world is not found using the provided chainId, the function returns without making changes.\r\n */\r\nexport function b2Chain_SetRestitution(chainId, restitution)\r\n{\r\n    const world = b2GetWorldLocked(chainId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const chainShape = b2GetChainShape(world, chainId);\r\n\r\n    const count = chainShape.count;\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        const shapeId = chainShape.shapeIndices[i];\r\n\r\n        // b2CheckId(world.shapeArray, shapeId);\r\n        const shape = world.shapeArray[shapeId];\r\n        shape.restitution = restitution;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the contact capacity for a given shape.\r\n * @function b2Shape_GetContactCapacity\r\n * @param {b2ShapeId} shapeId - The identifier for the shape to check\r\n * @returns {number} The number of contacts for the shape's body. Returns 0 if the world is invalid,\r\n * or if the shape is a sensor.\r\n * @description\r\n * Retrieves the number of contacts associated with the body that owns the specified shape.\r\n * If the shape is a sensor or the world reference is invalid, the function returns 0.\r\n */\r\nexport function b2Shape_GetContactCapacity(shapeId)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    if (shape.isSensor)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n\r\n    // Conservative and fast\r\n    return body.contactCount;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetContactData\r\n * @param {b2ShapeId} shapeId - The identifier of the shape to get contact data for\r\n * @param {Array<{shapeIdA: b2ShapeId, shapeIdB: b2ShapeId, manifold: b2Manifold}>} contactData - Array to store the contact data\r\n * @param {number} capacity - Maximum number of contacts to retrieve\r\n * @returns {number} The number of contacts found and stored in contactData\r\n * @description\r\n * Retrieves contact data for a specified shape. For each valid contact involving the shape,\r\n * stores the shape IDs of both bodies in contact and their contact manifold.\r\n * Only stores contacts where the touching flag is set and ignores sensor shapes.\r\n * @throws {Error} If the world is locked or invalid\r\n */\r\nexport function b2Shape_GetContactData(shapeId, contactData, capacity)\r\n{\r\n    const world = b2GetWorldLocked(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    if (shape.isSensor)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    let contactKey = body.headContactKey;\r\n    let index = 0;\r\n\r\n    while (contactKey !== B2_NULL_INDEX && index < capacity)\r\n    {\r\n        const contactId = contactKey >> 1;\r\n        const edgeIndex = contactKey & 1;\r\n\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n\r\n        // Does contact involve this shape and is it touching?\r\n        if ((contact.shapeIdA === shapeId.index1 - 1 || contact.shapeIdB === shapeId.index1 - 1) &&\r\n            (contact.flags & b2ContactFlags.b2_contactTouchingFlag) !== 0)\r\n        {\r\n            const shapeA = world.shapeArray[contact.shapeIdA];\r\n            const shapeB = world.shapeArray[contact.shapeIdB];\r\n\r\n            contactData[index].shapeIdA = new b2ShapeId(shapeA.id + 1, shapeId.world0, shapeA.revision);\r\n            contactData[index].shapeIdB = new b2ShapeId(shapeB.id + 1, shapeId.world0, shapeB.revision);\r\n\r\n            const contactSim = b2GetContactSim(world, contact);\r\n            contactData[index].manifold = contactSim.manifold;\r\n            index += 1;\r\n        }\r\n\r\n        contactKey = contact.edges[edgeIndex].nextKey;\r\n    }\r\n\r\n    console.assert(index <= capacity);\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetAABB\r\n * @summary Gets the Axis-Aligned Bounding Box (AABB) for a shape.\r\n * @param {b2ShapeId} shapeId - The identifier for the shape.\r\n * @returns {b2AABB} The AABB of the shape. Returns an empty AABB if the world is null.\r\n * @description\r\n * Retrieves the Axis-Aligned Bounding Box (AABB) associated with a shape in the physics world.\r\n * If the world reference is invalid, returns a default AABB with zero dimensions.\r\n */\r\nexport function b2Shape_GetAABB(shapeId)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return new b2AABB();\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n\r\n    return shape.aabb;\r\n}\r\n\r\n/**\r\n * @function b2Shape_GetClosestPoint\r\n * @summary Gets the closest point on a shape to a target point\r\n * @param {b2ShapeId} shapeId - ID of the shape to query\r\n * @param {b2Vec2} target - The target point to find the closest point to\r\n * @returns {b2Vec2} The closest point on the shape to the target point. Returns (0,0) if the world is invalid.\r\n * @description\r\n * Calculates the closest point on a shape to a given target point, taking into account\r\n * the shape's position and rotation in world space. Uses the distance calculation\r\n * algorithm with shape proxies and transforms.\r\n */\r\nexport function b2Shape_GetClosestPoint(shapeId, target)\r\n{\r\n    const world = b2GetWorld(shapeId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return new b2Vec2(0, 0);\r\n    }\r\n\r\n    const shape = b2GetShape(world, shapeId);\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = b2MakeShapeDistanceProxy(shape);\r\n    input.proxyB = b2MakeProxy([ target ], 1, 0.0);\r\n    input.transformA = transform;\r\n    input.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.useRadii = true;\r\n\r\n    const cache = new b2DistanceCache();\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    return output.pointA;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2AABB, b2Vec2 } from './math_functions_h.js';\r\nimport { b2Capsule, b2ChainSegment, b2Circle, b2Polygon, b2Segment } from './collision_h.js';\r\nimport { b2Filter, b2ShapeType } from './types_h.js';\r\n\r\nexport class b2Shape\r\n{\r\n    constructor()\r\n    {\r\n        this.id = 0;\r\n        this.bodyId = 0;\r\n        this.prevShapeId = 0;\r\n        this.nextShapeId = 0;\r\n        this.type = b2ShapeType.e_unknown;\r\n        this.density = 0;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n\r\n        this.aabb = new b2AABB();\r\n        this.fatAABB = new b2AABB();\r\n        this.localCentroid = new b2Vec2();\r\n        this.proxyKey = 0;\r\n\r\n        this.filter = new b2Filter();\r\n        this.userData = null;\r\n        this.customColor = 0;\r\n\r\n        this.capsule = new b2Capsule();\r\n        this.circle = new b2Circle();\r\n        this.polygon = new b2Polygon();\r\n        this.segment = new b2Segment();\r\n        this.chainSegment = new b2ChainSegment();\r\n\r\n        this.revision = 0;\r\n        this.isSensor = false;\r\n        this.enableSensorEvents = false;\r\n        this.enableContactEvents = false;\r\n        this.enableHitEvents = false;\r\n        this.enablePreSolveEvents = false;\r\n        this.enlargedAABB = false;\r\n        this.isFast = false;\r\n\r\n        this.imageNoDebug = false;      // suppress debug drawing except when there's an image attached\r\n        this.image = null;\r\n        this.imageScale = null;\r\n        this.imageOffset = null;\r\n        this.imageRect = null;          // use a b2AABB with width and height in upperBoundX and upperBoundY\r\n    }\r\n}\r\n\r\nexport class b2ChainShape\r\n{\r\n    constructor()\r\n    {\r\n        this.id = 0;\r\n        this.bodyId = 0;\r\n        this.nextChainId = 0;\r\n        this.shapeIndices = [];\r\n        this.count = 0;\r\n        this.revision = 0;\r\n    }\r\n}\r\n\r\nexport class b2ShapeExtent\r\n{\r\n    constructor()\r\n    {\r\n        this.minExtent = 0;\r\n        this.maxExtent = 0;\r\n    }\r\n}\r\n\r\nexport {\r\n    b2CreateCircleShape,\r\n    b2CreateCapsuleShape,\r\n    b2CreatePolygonShape,\r\n    b2CreateSegmentShape,\r\n    b2CreateChain,\r\n    b2DestroyShape,\r\n    b2CreateShapeProxy,\r\n    b2DestroyShapeProxy,\r\n    b2ComputeShapeMass,\r\n    b2ComputeShapeExtent,\r\n    b2ComputeShapeAABB,\r\n    b2GetShapeCentroid,\r\n    b2GetShapePerimeter,\r\n    b2MakeShapeDistanceProxy,\r\n    b2RayCastShape,\r\n    b2ShapeCastShape,\r\n    b2GetOwnerTransform,\r\n    b2Shape_AreContactEventsEnabled,\r\n    b2Shape_AreHitEventsEnabled,\r\n    b2Shape_ArePreSolveEventsEnabled,\r\n    b2Shape_AreSensorEventsEnabled,\r\n    b2Shape_EnableContactEvents,\r\n    b2Shape_EnableHitEvents,\r\n    b2Shape_EnablePreSolveEvents,\r\n    b2Shape_EnableSensorEvents,\r\n    b2Shape_GetAABB,\r\n    b2Shape_GetBody,\r\n    b2Shape_GetWorld,\r\n    b2Shape_GetCapsule,\r\n    b2Shape_GetCircle,\r\n    b2Shape_GetClosestPoint,\r\n    b2Shape_GetContactCapacity,\r\n    b2Shape_GetContactData,\r\n    b2Shape_GetDensity,\r\n    b2Shape_GetFilter,\r\n    b2Shape_GetFriction,\r\n    b2Shape_GetParentChain,\r\n    b2Shape_GetPolygon,\r\n    b2Shape_GetRestitution,\r\n    b2Shape_GetSegment,\r\n    b2Shape_GetChainSegment,\r\n    b2Shape_GetType,\r\n    b2Shape_GetUserData,\r\n    b2Shape_IsSensor,\r\n    b2Shape_RayCast,\r\n    b2Shape_SetCapsule,\r\n    b2Shape_SetCircle,\r\n    b2Shape_SetDensity,\r\n    b2Shape_SetFilter,\r\n    b2Shape_SetFriction,\r\n    b2Shape_SetPolygon,\r\n    b2Shape_SetRestitution,\r\n    b2Shape_SetSegment,\r\n    b2Shape_SetUserData,\r\n    b2Shape_TestPoint,\r\n    b2Chain_SetFriction,\r\n    b2Chain_SetRestitution,\r\n    b2DestroyChain,\r\n} from '../shape_c.js';\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2BitSet } from './include/bitset_h.js';\r\n\r\n/**\r\n * @namespace BitSet\r\n */\r\n\r\nconst b2_64bits = 8;\r\n\r\nexport function b2CreateBitSet(bitCapacity)\r\n{\r\n    const bitSet = new b2BitSet();\r\n    const cap = Math.floor((bitCapacity + b2_64bits * 8 - 1) / (b2_64bits * 8));\r\n\r\n    bitSet.blockCapacity = cap;\r\n    bitSet.blockCount = 0;\r\n    bitSet.bits = new BigUint64Array(bitSet.blockCapacity);\r\n    bitSet.bits.fill(0n);\r\n\r\n    return bitSet;\r\n}\r\n\r\nexport function b2DestroyBitSet(bitSet)\r\n{\r\n    bitSet.blockCapacity = 0;\r\n    bitSet.blockCount = 0;\r\n    bitSet.bits = null;\r\n}\r\n\r\nexport function b2SetBitCountAndClear(bitSet, bitCount)\r\n{\r\n    const blockCount = Math.floor((bitCount + b2_64bits * 8 - 1) / (b2_64bits * 8));\r\n\r\n    if (bitSet.blockCapacity < blockCount)\r\n    {\r\n        b2DestroyBitSet(bitSet);\r\n        const newBitCapacity = bitCount + (bitCount >> 1);\r\n        bitSet = b2CreateBitSet(newBitCapacity);\r\n    }\r\n\r\n    bitSet.blockCount = blockCount;\r\n    bitSet.bits.fill(0n);\r\n\r\n    return bitSet;\r\n}\r\n\r\nexport function b2GrowBitSet(bitSet, blockCount)\r\n{\r\n    console.assert(blockCount > bitSet.blockCount, \"grow is unnecessary here\");\r\n\r\n    if (blockCount > bitSet.blockCapacity)\r\n    {\r\n        const oldCapacity = bitSet.blockCapacity;\r\n        bitSet.blockCapacity = blockCount + (blockCount >> 1);\r\n        const newBits = new BigUint64Array(bitSet.blockCapacity);\r\n        newBits.fill(0n);\r\n\r\n        if (bitSet.blockCount > 0)\r\n        {\r\n            newBits.set(bitSet.bits.subarray(0, oldCapacity));\r\n        }\r\n\r\n        bitSet.bits = newBits;\r\n    }\r\n\r\n    bitSet.blockCount = blockCount;\r\n}\r\n\r\nexport function b2InPlaceUnion(setA, setB)\r\n{\r\n    console.assert(setA.blockCount == setB.blockCount);\r\n    const blockCount = setA.blockCount;\r\n\r\n    for (let i = 0; i < blockCount; ++i)\r\n    {\r\n        setA.bits[i] |= setB.bits[i];\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    b2CreateBitSet,\r\n    b2DestroyBitSet,\r\n    b2GrowBitSet,\r\n    b2InPlaceUnion,\r\n    b2SetBitCountAndClear\r\n} from '../bitset_c.js';\r\n\r\n// Bit set provides fast operations on large arrays of bits.\r\nexport class b2BitSet\r\n{\r\n    constructor()\r\n    {\r\n        this.bits = null;\r\n        this.blockCapacity = 0;\r\n        this.blockCount = 0;\r\n    }\r\n}\r\n\r\nexport {\r\n    b2CreateBitSet, b2DestroyBitSet, b2SetBitCountAndClear, b2GrowBitSet, b2InPlaceUnion\r\n};\r\n\r\nexport function b2SetBit(bitSet, bitIndex)\r\n{\r\n    const blockIndex = Math.floor(bitIndex / 64);\r\n    console.assert(blockIndex < bitSet.blockCount);\r\n    bitSet.bits[blockIndex] |= (BigInt(1) << BigInt(bitIndex % 64));\r\n}\r\n\r\nexport function b2SetBitGrow(bitSet, bitIndex)\r\n{\r\n    const blockIndex = Math.floor(bitIndex / 64);\r\n\r\n    if (blockIndex >= bitSet.blockCount)\r\n    {\r\n        b2GrowBitSet(bitSet, blockIndex + 1);\r\n    }\r\n\r\n    bitSet.bits[blockIndex] |= (BigInt(1) << BigInt(bitIndex % 64));\r\n}\r\n\r\nexport function b2ClearBit(bitSet, bitIndex)\r\n{\r\n    const blockIndex = Math.floor(bitIndex / 64);\r\n\r\n    if (blockIndex >= bitSet.blockCount)\r\n    {\r\n        return;\r\n    }\r\n    \r\n    bitSet.bits[blockIndex] &= ~(BigInt(1) << BigInt(bitIndex % 64));\r\n}\r\n\r\nexport function b2GetBit(bitSet, bitIndex)\r\n{\r\n    const blockIndex = Math.floor(bitIndex / 64);\r\n\r\n    if (blockIndex >= bitSet.blockCount)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return (bitSet.bits[blockIndex] & (BigInt(1) << BigInt(bitIndex % 64))) !== BigInt(0);\r\n}\r\n\r\nexport function b2GetBitSetBytes(bitSet)\r\n{\r\n    return bitSet.blockCapacity * 8; // 8 bytes per 64-bit block\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX, b2_graphColorCount } from './include/core_h.js';\r\nimport { b2AddContact, b2AddJoint, b2ContactArray, b2JointArray, b2RemoveContact, b2RemoveJoint } from './include/block_array_h.js';\r\nimport { b2BitSet, b2ClearBit, b2CreateBitSet, b2DestroyBitSet, b2SetBitCountAndClear } from './include/bitset_h.js';\r\nimport { b2CheckIndex, b2SetType } from './include/world_h.js';\r\nimport { b2ContactFlags, b2ContactSimFlags } from './include/contact_h.js';\r\n\r\n/**\r\n * @namespace ConstraintGraph\r\n */\r\n\r\n// JS conversion is not using threads, everything should go into the overflow set for single thread processing\r\nexport const b2_overflowIndex = b2_graphColorCount - 1;\r\n\r\nexport class b2GraphColor\r\n{\r\n    constructor()\r\n    {\r\n        this.bodySet = new b2BitSet();\r\n        this.contacts = new b2ContactArray();\r\n        this.joints = new b2JointArray();\r\n        this.overflowConstraints = null;\r\n    }\r\n}\r\n\r\nexport class b2ConstraintGraph\r\n{\r\n    constructor()\r\n    {\r\n        this.colors = [];\r\n\r\n        for (let i = 0; i < b2_graphColorCount; i++)\r\n        { this.colors.push(new b2GraphColor()); }\r\n    }\r\n}\r\n\r\nexport function b2CreateGraph(graph, bodyCapacity)\r\n{\r\n    console.assert( b2_graphColorCount >= 2, \"must have at least two constraint graph colors\" );\r\n    console.assert( b2_overflowIndex == b2_graphColorCount - 1, \"bad over flow index\");\r\n\r\n    graph = new b2ConstraintGraph();\r\n\r\n    bodyCapacity = Math.max(bodyCapacity, 8);\r\n\r\n    for (let i = 0; i < b2_overflowIndex; i++)\r\n    {\r\n        const color = graph.colors[i];\r\n        color.bodySet = b2CreateBitSet(bodyCapacity);\r\n        color.bodySet = b2SetBitCountAndClear(color.bodySet, bodyCapacity);\r\n    }\r\n\r\n    return graph;\r\n}\r\n\r\nexport function b2DestroyGraph(graph)\r\n{\r\n    for (let i = 0; i < b2_graphColorCount; i++)\r\n    {\r\n        const color = graph.colors[i];\r\n\r\n        // console.assert( i != b2_overflowIndex || color.bodySet.bits == null );\r\n        b2DestroyBitSet(color.bodySet); color.bodySet = null;\r\n        color.contacts = null;\r\n        color.joints = null;\r\n    }\r\n}\r\n\r\nexport function b2AddContactToGraph(world, contactSim, contact)\r\n{\r\n    if (contactSim.manifold.pointCount <= 0)\r\n    {\r\n        throw new Error(\"Assert failed: contactSim.manifold.pointCount > 0\");\r\n    }\r\n\r\n    if (!(contactSim.simFlags & b2ContactSimFlags.b2_simTouchingFlag))\r\n    {\r\n        throw new Error(\"Assert failed: contactSim.simFlags & b2_simTouchingFlag\");\r\n    }\r\n\r\n    if (!(contact.flags & b2ContactFlags.b2_contactTouchingFlag))\r\n    {\r\n        throw new Error(\"Assert failed: contact.flags & b2_contactTouchingFlag\");\r\n    }\r\n\r\n    const graph = world.constraintGraph;\r\n    const colorIndex = b2_overflowIndex;\r\n\r\n    const bodyIdA = contact.edges[0].bodyId;\r\n    const bodyIdB = contact.edges[1].bodyId;\r\n    b2CheckIndex(world.bodyArray, bodyIdA);\r\n    b2CheckIndex(world.bodyArray, bodyIdB);\r\n\r\n    const bodyA = world.bodyArray[bodyIdA];\r\n    const bodyB = world.bodyArray[bodyIdB];\r\n    const staticA = bodyA.setIndex == b2SetType.b2_staticSet;\r\n    const staticB = bodyB.setIndex == b2SetType.b2_staticSet;\r\n\r\n    if (staticA && staticB)\r\n    {\r\n        throw new Error(\"Assert failed: staticA == false || staticB == false\");\r\n    }\r\n\r\n    const color = graph.colors[colorIndex];\r\n    contact.colorIndex = colorIndex;\r\n    contact.localIndex = color.contacts.count;\r\n\r\n    const newContact = b2AddContact(color.contacts);    // add a b2ContactSim to the color.contacts array and return it\r\n    newContact.set(contactSim);\r\n\r\n    if (staticA)\r\n    {\r\n        newContact.bodySimIndexA = B2_NULL_INDEX;\r\n        newContact.invMassA = 0.0;\r\n        newContact.invIA = 0.0;\r\n    }\r\n    else\r\n    {\r\n        if (bodyA.setIndex !== b2SetType.b2_awakeSet)\r\n        {\r\n            throw new Error(\"Assert failed: bodyA.setIndex == b2SetType.b2_awakeSet\");\r\n        }\r\n        const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n        const localIndex = bodyA.localIndex;\r\n\r\n        if (!(0 <= localIndex && localIndex < awakeSet.sims.count))\r\n        {\r\n            throw new Error(\"Assert failed: 0 <= localIndex && localIndex < awakeSet.sims.count\");\r\n        }\r\n        newContact.bodySimIndexA = localIndex;\r\n\r\n        const bodySimA = awakeSet.sims.data[localIndex];\r\n        newContact.invMassA = bodySimA.invMass;\r\n        newContact.invIA = bodySimA.invInertia;\r\n    }\r\n\r\n    if (staticB)\r\n    {\r\n        newContact.bodySimIndexB = B2_NULL_INDEX;\r\n        newContact.invMassB = 0.0;\r\n        newContact.invIB = 0.0;\r\n    }\r\n    else\r\n    {\r\n        if (bodyB.setIndex !== b2SetType.b2_awakeSet)\r\n        {\r\n            throw new Error(\"Assert failed: bodyB.setIndex == b2SetType.b2_awakeSet\");\r\n        }\r\n        const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n        const localIndex = bodyB.localIndex;\r\n\r\n        if (!(0 <= localIndex && localIndex < awakeSet.sims.count))\r\n        {\r\n            throw new Error(\"Assert failed: 0 <= localIndex && localIndex < awakeSet.sims.count\");\r\n        }\r\n        newContact.bodySimIndexB = localIndex;\r\n\r\n        const bodySimB = awakeSet.sims.data[localIndex];\r\n        newContact.invMassB = bodySimB.invMass;\r\n        newContact.invIB = bodySimB.invInertia;\r\n    }\r\n}\r\n\r\nexport function b2RemoveContactFromGraph(world, bodyIdA, bodyIdB, colorIndex, localIndex)\r\n{\r\n    const graph = world.constraintGraph;\r\n\r\n    if (colorIndex !== b2_overflowIndex)\r\n    {\r\n        throw new Error(\"Assert failed: colorIndex == b2_overflowIndex\");\r\n    }\r\n    const color = graph.colors[colorIndex];\r\n\r\n    if ( colorIndex != b2_overflowIndex )\r\n    {\r\n        // might clear a bit for a static body, but this has no effect\r\n        b2ClearBit( color.bodySet, bodyIdA );\r\n        b2ClearBit( color.bodySet, bodyIdB );\r\n    }\r\n\r\n    const movedIndex = b2RemoveContact(color.contacts, localIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        // Fix index on swapped contact\r\n        const movedContactSim = color.contacts.data[localIndex];\r\n\r\n        // Fix moved contact\r\n        const movedId = movedContactSim.contactId;\r\n        const movedContact = world.contactArray[movedId];\r\n\r\n        if (movedContact.setIndex !== b2SetType.b2_awakeSet)\r\n        {\r\n            throw new Error(\"Assert failed: movedContact.setIndex == b2SetType.b2_awakeSet\");\r\n        }\r\n\r\n        if (movedContact.colorIndex !== colorIndex)\r\n        {\r\n            throw new Error(\"Assert failed: movedContact.colorIndex == colorIndex\");\r\n        }\r\n\r\n        if (movedContact.localIndex !== movedIndex)\r\n        {\r\n            throw new Error(\"Assert failed: movedContact.localIndex == movedIndex\");\r\n        }\r\n        movedContact.localIndex = localIndex;\r\n    }\r\n}\r\n\r\nfunction b2AssignJointColor(graph, bodyIdA, bodyIdB, staticA, staticB)\r\n{\r\n    console.assert( staticA == false || staticB == false );\r\n\r\n    return b2_overflowIndex;\r\n}\r\n\r\nexport function b2CreateJointInGraph(world, joint)\r\n{\r\n    const graph = world.constraintGraph;\r\n\r\n    const bodyIdA = joint.edges[0].bodyId;\r\n    const bodyIdB = joint.edges[1].bodyId;\r\n\r\n    // array_h.b2CheckIndex(world.bodyArray, bodyIdA);\r\n    // array_h.b2CheckIndex(world.bodyArray, bodyIdB);\r\n\r\n    const bodyA = world.bodyArray[bodyIdA];\r\n    const bodyB = world.bodyArray[bodyIdB];\r\n    const staticA = bodyA.setIndex === b2SetType.b2_staticSet;\r\n    const staticB = bodyB.setIndex === b2SetType.b2_staticSet;\r\n\r\n    if (staticA && staticB)\r\n    {\r\n        throw new Error(\"Assert failed: staticA == false || staticB == false\");\r\n    }\r\n\r\n    const colorIndex = b2AssignJointColor( graph, bodyIdA, bodyIdB, staticA, staticB );\r\n\r\n    const jointSim = b2AddJoint(graph.colors[colorIndex].joints);\r\n    joint.colorIndex = colorIndex;\r\n    joint.localIndex = graph.colors[colorIndex].joints.count - 1;\r\n\r\n    return jointSim;\r\n}\r\n\r\nexport function b2AddJointToGraph(world, jointSim, joint)\r\n{\r\n    const jointDst = b2CreateJointInGraph(world, joint);\r\n    Object.assign(jointDst, jointSim);\r\n}\r\n\r\nexport function b2RemoveJointFromGraph(world, bodyIdA, bodyIdB, colorIndex, localIndex)\r\n{\r\n    const graph = world.constraintGraph;\r\n\r\n    console.assert(0 <= colorIndex && colorIndex < b2_graphColorCount);\r\n    const color = graph.colors[colorIndex];\r\n\r\n    if (colorIndex != b2_overflowIndex)\r\n    {\r\n        b2ClearBit(color.bodySet, bodyIdA);\r\n        b2ClearBit(color.bodySet, bodyIdB);\r\n    }\r\n\r\n    // remove joint localIndex\r\n    const movedIndex = b2RemoveJoint(color.joints, localIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        // Fix moved joint\r\n        const movedJointSim = color.joints.data[localIndex];\r\n        const movedId = movedJointSim.jointId;\r\n\r\n        // array_h.b2CheckIndex(world.jointArray, movedId);\r\n        if (movedId != world.jointArray[movedId].jointId)\r\n        {\r\n            throw new Error(\"Assert failed: movedId != jointId\");\r\n        }\r\n\r\n        const movedJoint = world.jointArray[movedId];\r\n\r\n        if (movedJoint.setIndex !== b2SetType.b2_awakeSet)\r\n        {\r\n            throw new Error(\"Assert failed: movedJoint.setIndex == b2SetType.b2_awakeSet\");\r\n        }\r\n\r\n        if (movedJoint.colorIndex !== colorIndex)\r\n        {\r\n            throw new Error(\"Assert failed: movedJoint.colorIndex == colorIndex\");\r\n        }\r\n\r\n        if (movedJoint.localIndex !== movedIndex)\r\n        {\r\n            throw new Error(\"Assert failed: movedJoint.localIndex == movedIndex\");\r\n        }\r\n\r\n        movedJoint.localIndex = localIndex;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2BodyState } from './include/body_h.js';\r\nimport { b2SetType } from './include/world_h.js';\r\nimport { b2Softness } from './include/solver_h.js';\r\nimport { b2_overflowIndex } from './include/constraint_graph_h.js';\r\n\r\n/**\r\n * @namespace ContactSolver\r\n */\r\n\r\nexport class b2ContactConstraint\r\n{\r\n    constructor()\r\n    {\r\n        this.indexA = 0;\r\n        this.indexB = 0;\r\n        this.normalX = 0;\r\n        this.normalY = 0;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n        this.pointCount = 0;\r\n        this.softness = new b2Softness();\r\n        this.invMassA = 0;\r\n        this.invIA = 0;\r\n        this.invMassB = 0;\r\n        this.invIB = 0;\r\n        this.points = [];\r\n    }\r\n}\r\n\r\nexport class b2ContactConstraintPoint\r\n{\r\n    constructor()\r\n    {\r\n        this.normalImpulse = 0;\r\n        this.tangentImpulse = 0;\r\n        this.maxNormalImpulse = 0;\r\n        this.anchorAX = 0;\r\n        this.anchorAY = 0;\r\n        this.anchorBX = 0;\r\n        this.anchorBY = 0;\r\n        this.baseSeparation = 0;\r\n        this.normalMass = 0;\r\n        this.tangentMass = 0;\r\n        this.relativeVelocity = 0;\r\n    }\r\n}\r\n\r\nexport function b2PrepareOverflowContacts(context)\r\n{\r\n    const world = context.world;\r\n    const graph = context.graph;\r\n    const color = graph.colors[b2_overflowIndex];\r\n    const constraints = color.overflowConstraints;\r\n    const contactCount = color.contacts.count;\r\n    const contacts = color.contacts.data;\r\n    const awakeStates = context.states;\r\n\r\n    // const bodies = world.bodyArray;     // debug only\r\n    \r\n    const contactSoftness = context.contactSoftness;\r\n    const staticSoftness = context.staticSoftness;\r\n\r\n    const warmStartScale = world.enableWarmStarting ? 1.0 : 0.0;\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const contactSim = contacts[i];\r\n        const manifold = contactSim.manifold;\r\n        const pointCount = manifold.pointCount;\r\n\r\n        const indexA = contactSim.bodySimIndexA;\r\n        const indexB = contactSim.bodySimIndexB;\r\n\r\n        // #if B2_VALIDATE  debug only\r\n        // const bodyA = bodies[contactSim._bodyIdA];\r\n        // const validIndexA = bodyA.setIndex == b2SetType.b2_awakeSet ? bodyA.localIndex : B2_NULL_INDEX;\r\n        // console.assert( indexA == validIndexA );\r\n\r\n        // const bodyB = bodies[contactSim._bodyIdB];\r\n        // const validIndexB = bodyB.setIndex == b2SetType.b2_awakeSet ? bodyB.localIndex : B2_NULL_INDEX;\r\n        // console.assert( indexB == validIndexB );\r\n        // #endif\r\n\r\n        const constraint = constraints[i];\r\n        constraint.indexA = indexA;\r\n        constraint.indexB = indexB;\r\n        constraint.normalX = manifold.normalX;\r\n        constraint.normalY = manifold.normalY;\r\n        constraint.friction = contactSim.friction;\r\n        constraint.restitution = contactSim.restitution;\r\n        constraint.pointCount = pointCount;\r\n\r\n        // let vA = new b2Vec2();\r\n        let vAX = 0;\r\n        let vAY = 0;\r\n        let wA = 0;\r\n        const mA = contactSim.invMassA;\r\n        const iA = contactSim.invIA;\r\n\r\n        if (indexA !== B2_NULL_INDEX)\r\n        {\r\n            const stateA = awakeStates[indexA];\r\n            vAX = stateA.linearVelocity.x;\r\n            vAY = stateA.linearVelocity.y;\r\n            wA = stateA.angularVelocity;\r\n        }\r\n\r\n        // let vB = new b2Vec2();\r\n        let vBX = 0;\r\n        let vBY = 0;\r\n        let wB = 0;\r\n        const mB = contactSim.invMassB;\r\n        const iB = contactSim.invIB;\r\n\r\n        if (indexB !== B2_NULL_INDEX)\r\n        {\r\n            const stateB = awakeStates[indexB];\r\n            vBX = stateB.linearVelocity.x;\r\n            vBY = stateB.linearVelocity.y;\r\n            wB = stateB.angularVelocity;\r\n        }\r\n\r\n        constraint.softness = (indexA === B2_NULL_INDEX || indexB === B2_NULL_INDEX) ? staticSoftness : contactSoftness;\r\n\r\n        constraint.invMassA = mA;\r\n        constraint.invIA = iA;\r\n        constraint.invMassB = mB;\r\n        constraint.invIB = iB;\r\n\r\n        const normalX = constraint.normalX;\r\n        const normalY = constraint.normalY;\r\n\r\n        // const tangent = b2RightPerp(constraint.normal);\r\n        const tangentX = constraint.normalY;\r\n        const tangentY = -constraint.normalX;\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            const mp = manifold.points[j];\r\n            const cp = constraint.points[j] = new b2ContactConstraintPoint();\r\n\r\n            cp.normalImpulse = warmStartScale * mp.normalImpulse;\r\n            cp.tangentImpulse = warmStartScale * mp.tangentImpulse;\r\n            cp.maxNormalImpulse = 0.0;\r\n\r\n            // const rA = new b2Vec2(mp.anchorAX, mp.anchorAY);\r\n            const rAX = mp.anchorAX;\r\n            const rAY = mp.anchorAY;\r\n\r\n            // const rB = new b2Vec2(mp.anchorBX, mp.anchorBY);\r\n            const rBX = mp.anchorBX;\r\n            const rBY = mp.anchorBY;\r\n\r\n            // cp.anchorA = rA;\r\n            cp.anchorAX = rAX;\r\n            cp.anchorAY = rAY;\r\n\r\n            // cp.anchorB = rB;\r\n            cp.anchorBX = rBX;\r\n            cp.anchorBY = rBY;\r\n            const subX = rBX - rAX;\r\n            const subY = rBY - rAY;\r\n\r\n            // cp.baseSeparation = mp.separation - b2Dot(b2Sub(rB, rA), normal);\r\n            cp.baseSeparation = mp.separation - (subX * normalX + subY * normalY);\r\n\r\n            // const rnA = b2Cross(rA, normal);\r\n            const rnA = rAX * normalY - rAY * normalX;\r\n\r\n            // const rnB = b2Cross(rB, normal);\r\n            const rnB = rBX * normalY - rBY * normalX;\r\n            const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n            cp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\r\n\r\n            // const rtA = b2Cross(rA, tangent);\r\n            const rtA = rAX * tangentY - rAY * tangentX;\r\n\r\n            // const rtB = b2Cross(rB, tangent);\r\n            const rtB = rBX * tangentY - rBY * tangentX;\r\n            const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\r\n            cp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\r\n\r\n            // const vrA = b2Add(vA, b2CrossSV(wA, rA));\r\n            const vrAX = vAX + (-wA * rAY);\r\n            const vrAY = vAY + (wA * rAX);\r\n\r\n            // const vrB = b2Add(vB, b2CrossSV(wB, rB));\r\n            const vrBX = vBX + (-wB * rBY);\r\n            const vrBY = vBY + (wB * rBX);\r\n\r\n            // cp.relativeVelocity = b2Dot(normal, b2Sub(vrB, vrA));\r\n            cp.relativeVelocity = normalX * (vrBX - vrAX) + normalY * (vrBY - vrAY);\r\n        }\r\n    }\r\n}\r\n\r\nexport function b2WarmStartOverflowContacts(context)\r\n{\r\n    const graph = context.graph;\r\n    const color = graph.colors[b2_overflowIndex];\r\n    const constraints = color.overflowConstraints;\r\n    const contactCount = color.contacts.count;\r\n    const awakeSet = context.world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const states = awakeSet.states.data;\r\n\r\n    const dummyState = new b2BodyState();\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const constraint = constraints[i];\r\n\r\n        const indexA = constraint.indexA;\r\n        const indexB = constraint.indexB;\r\n\r\n        const stateA = indexA === B2_NULL_INDEX ? dummyState : states[indexA];\r\n        const stateB = indexB === B2_NULL_INDEX ? dummyState : states[indexB];\r\n\r\n        const vA = stateA.linearVelocity;\r\n        let wA = stateA.angularVelocity;\r\n        const vB = stateB.linearVelocity;\r\n        let wB = stateB.angularVelocity;\r\n\r\n        const mA = constraint.invMassA;\r\n        const iA = constraint.invIA;\r\n        const mB = constraint.invMassB;\r\n        const iB = constraint.invIB;\r\n\r\n        const normalX = constraint.normalX;\r\n        const normalY = constraint.normalY;\r\n\r\n        // const tangent = b2RightPerp(constraint.normal);\r\n        const tangentx = constraint.normalY;\r\n        const tangenty = -constraint.normalX;\r\n        const pointCount = constraint.pointCount;\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            const cp = constraint.points[j];\r\n            const rAX = cp.anchorAX;\r\n            const rAY = cp.anchorAY;\r\n            const rBX = cp.anchorBX;\r\n            const rBY = cp.anchorBY;\r\n\r\n            // const P = b2Add(b2MulSV(cp.normalImpulse, normal), b2MulSV(cp.tangentImpulse, tangent));\r\n            const Px = (cp.normalImpulse * normalX) + (cp.tangentImpulse * tangentx);\r\n            const Py = (cp.normalImpulse * normalY) + (cp.tangentImpulse * tangenty);\r\n\r\n            // wA -= iA * b2Cross(rA, P);\r\n            wA -= iA * (rAX * Py - rAY * Px);\r\n\r\n            // vA = b2MulAdd(vA, -mA, P);\r\n            vA.x -= mA * Px;\r\n            vA.y -= mA * Py;\r\n\r\n            // wB += iB * b2Cross(rB, P);\r\n            wB += iB * (rBX * Py - rBY * Px);\r\n\r\n            // vB = b2MulAdd(vB, mB, P);\r\n            vB.x += mB * Px;\r\n            vB.y += mB * Py;\r\n        }\r\n\r\n        stateA.linearVelocity = vA;\r\n        stateA.angularVelocity = wA;\r\n        stateB.linearVelocity = vB;\r\n        stateB.angularVelocity = wB;\r\n    }\r\n}\r\n\r\nexport function b2SolveOverflowContacts(context, useBias)\r\n{\r\n    const graph = context.graph;\r\n    const color = graph.colors[b2_overflowIndex];\r\n    const constraints = color.overflowConstraints;\r\n    const contactCount = color.contacts.count;\r\n    const awakeSet = context.world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const states = awakeSet.states;\r\n\r\n    const inv_h = context.inv_h;\r\n    const pushout = context.world.contactPushoutVelocity;\r\n\r\n    // Dummy body to represent a static body\r\n    const dummyState = new b2BodyState();\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n\r\n        const constraint = constraints[i];\r\n        const mA = constraint.invMassA;\r\n        const iA = constraint.invIA;\r\n        const mB = constraint.invMassB;\r\n        const iB = constraint.invIB;\r\n\r\n        const stateA = constraint.indexA === B2_NULL_INDEX ? dummyState : states.data[constraint.indexA];\r\n        let vAX = stateA.linearVelocity.x;\r\n        let vAY = stateA.linearVelocity.y;\r\n        let wA = stateA.angularVelocity;\r\n        const dqA = stateA.deltaRotation;\r\n\r\n        const stateB = constraint.indexB === B2_NULL_INDEX ? dummyState : states.data[constraint.indexB];\r\n        let vBX = stateB.linearVelocity.x;\r\n        let vBY = stateB.linearVelocity.y;\r\n        let wB = stateB.angularVelocity;\r\n        const dqB = stateB.deltaRotation;\r\n\r\n        const dpx = stateB.deltaPosition.x - stateA.deltaPosition.x;\r\n        const dpy = stateB.deltaPosition.y - stateA.deltaPosition.y;\r\n\r\n        const normalX = constraint.normalX;\r\n        const normalY = constraint.normalY;\r\n        const tangentx = normalY;\r\n        const tangenty = -normalX;\r\n        const friction = constraint.friction;\r\n        const softness = constraint.softness;\r\n\r\n        const pointCount = constraint.pointCount;\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            const cp = constraint.points[j];\r\n\r\n            // Compute current separation\r\n            const rx = (dqB.c * cp.anchorBX - dqB.s * cp.anchorBY) - (dqA.c * cp.anchorAX - dqA.s * cp.anchorAY);\r\n            const ry = (dqB.s * cp.anchorBX + dqB.c * cp.anchorBY) - (dqA.s * cp.anchorAX + dqA.c * cp.anchorAY);\r\n            const s = (dpx + rx) * normalX + (dpy + ry) * normalY + cp.baseSeparation;\r\n\r\n            let velocityBias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (s > 0.0)\r\n            {\r\n                velocityBias = s * inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                velocityBias = Math.max(softness.biasRate * s, -pushout);\r\n                massScale = softness.massScale;\r\n                impulseScale = softness.impulseScale;\r\n            }\r\n\r\n            // Fixed anchor points\r\n            const rAX = cp.anchorAX;\r\n            const rAY = cp.anchorAY;\r\n            const rBX = cp.anchorBX;\r\n            const rBY = cp.anchorBY;\r\n\r\n            // Relative normal velocity at contact\r\n            const vn = (vBX - vAX + wB * -rBY - wA * -rAY) * normalX +\r\n                        (vBY - vAY + wB * rBX - wA * rAX) * normalY;\r\n\r\n            // Incremental normal impulse\r\n            let impulse = -cp.normalMass * massScale * (vn + velocityBias) - impulseScale * cp.normalImpulse;\r\n\r\n            // Clamp the accumulated impulse\r\n            const newImpulse = Math.max(cp.normalImpulse + impulse, 0.0);\r\n            impulse = newImpulse - cp.normalImpulse;\r\n            cp.normalImpulse = newImpulse;\r\n            cp.maxNormalImpulse = Math.max(cp.maxNormalImpulse, impulse);\r\n\r\n            // Apply normal impulse\r\n            const Px = impulse * normalX;\r\n            const Py = impulse * normalY;\r\n            vAX -= mA * Px;\r\n            vAY -= mA * Py;\r\n            wA -= iA * (rAX * Py - rAY * Px);\r\n            vBX += mB * Px;\r\n            vBY += mB * Py;\r\n            wB += iB * (rBX * Py - rBY * Px);\r\n        }\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            const cp = constraint.points[j];\r\n            const rAX = cp.anchorAX;\r\n            const rAY = cp.anchorAY;\r\n            const rBX = cp.anchorBX;\r\n            const rBY = cp.anchorBY;\r\n        \r\n            // Relative tangent velocity at contact\r\n            const vtx = (vBX - wB * rBY) - (vAX - wA * rAY);\r\n            const vty = (vBY + wB * rBX) - (vAY + wA * rAX);\r\n            const vt = vtx * tangentx + vty * tangenty;\r\n        \r\n            // Incremental tangent impulse\r\n            let impulse = cp.tangentMass * (-vt);\r\n        \r\n            // Clamp the accumulated force\r\n            const maxFriction = friction * cp.normalImpulse;\r\n            const oldTangentImpulse = cp.tangentImpulse;\r\n            cp.tangentImpulse = oldTangentImpulse + impulse;\r\n            cp.tangentImpulse = cp.tangentImpulse < -maxFriction ? -maxFriction :\r\n                (cp.tangentImpulse > maxFriction ? maxFriction : cp.tangentImpulse);\r\n            impulse = cp.tangentImpulse - oldTangentImpulse;\r\n        \r\n            // Apply tangent impulse\r\n            const Px = impulse * tangentx;\r\n            const Py = impulse * tangenty;\r\n        \r\n            vAX -= mA * Px;\r\n            vAY -= mA * Py;\r\n            wA -= iA * (rAX * Py - rAY * Px);\r\n        \r\n            vBX += mB * Px;\r\n            vBY += mB * Py;\r\n            wB += iB * (rBX * Py - rBY * Px);\r\n        }\r\n\r\n        stateA.linearVelocity.x = vAX;\r\n        stateA.linearVelocity.y = vAY;\r\n        stateA.angularVelocity = wA;\r\n        stateB.linearVelocity.x = vBX;\r\n        stateB.linearVelocity.y = vBY;\r\n        stateB.angularVelocity = wB;\r\n    }\r\n}\r\n\r\nexport function b2ApplyOverflowRestitution(context)\r\n{\r\n    const graph = context.graph;\r\n    const color = graph.colors[b2_overflowIndex];\r\n    const constraints = color.overflowConstraints;\r\n    const contactCount = color.contacts.count;\r\n    const awakeSet = context.world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const states = awakeSet.states;\r\n\r\n    const threshold = context.world.restitutionThreshold;\r\n\r\n    // Dummy state to represent a static body\r\n    const dummyState = new b2BodyState();\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const constraint = constraints[i];\r\n\r\n        const restitution = constraint.restitution;\r\n\r\n        if (restitution === 0.0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const mA = constraint.invMassA;\r\n        const iA = constraint.invIA;\r\n        const mB = constraint.invMassB;\r\n        const iB = constraint.invIB;\r\n\r\n        const stateA = constraint.indexA === B2_NULL_INDEX ? dummyState : states.data[constraint.indexA];\r\n        const vA = stateA.linearVelocity;\r\n        let wA = stateA.angularVelocity;\r\n\r\n        const stateB = constraint.indexB === B2_NULL_INDEX ? dummyState : states.data[constraint.indexB];\r\n        const vB = stateB.linearVelocity;\r\n        let wB = stateB.angularVelocity;\r\n\r\n        const normalX = constraint.normalX;\r\n        const normalY = constraint.normalY;\r\n        const pointCount = constraint.pointCount;\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            const cp = constraint.points[j];\r\n\r\n            if (cp.relativeVelocity > -threshold || cp.maxNormalImpulse === 0.0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Fixed anchor points\r\n            const rAX = cp.anchorAX;\r\n            const rAY = cp.anchorAY;\r\n            const rBX = cp.anchorBX;\r\n            const rBY = cp.anchorBY;\r\n\r\n            // Relative normal velocity at contact\r\n            // const vrB = b2Add(vB, b2CrossSV(wB, rB));\r\n            const vrBX = vB.x + -wB * rBY;\r\n            const vrBY = vB.y + wB * rBX;\r\n\r\n            // const vrA = b2Add(vA, b2CrossSV(wA, rA));\r\n            const vrAX = vA.x + -wA * rAY;\r\n            const vrAY = vA.y + wA * rAX;\r\n\r\n            // const vn = b2Dot(b2Sub(vrB, vrA), normal);\r\n            const subX = vrBX - vrAX;\r\n            const subY = vrBY - vrAY;\r\n            const vn = subX * normalX + subY * normalY;\r\n\r\n            // Compute normal impulse\r\n            let impulse = -cp.normalMass * (vn + restitution * cp.relativeVelocity);\r\n\r\n            // Clamp the accumulated impulse\r\n            const newImpulse = Math.max(cp.normalImpulse + impulse, 0.0);\r\n            impulse = newImpulse - cp.normalImpulse;\r\n            cp.normalImpulse = newImpulse;\r\n            cp.maxNormalImpulse = Math.max(cp.maxNormalImpulse, impulse);\r\n\r\n            // Apply contact impulse\r\n            // const P = b2MulSV(impulse, normal);\r\n            const PX = impulse * normalX;\r\n            const PY = impulse * normalY;\r\n\r\n            // vA = b2MulSub(vA, mA, P);\r\n            vA.x -= mA * PX;\r\n            vA.y -= mA * PY;\r\n\r\n            // wA -= iA * b2Cross(rA, P);\r\n            wA -= iA * (rAX * PY - rAY * PX);\r\n\r\n            // vB = b2MulAdd(vB, mB, P);\r\n            vB.x += mB * PX;\r\n            vB.y += mB * PY;\r\n\r\n            // wB += iB * b2Cross(rB, P);\r\n            wB += iB * (rBX * PY - rBY * PX);\r\n        }\r\n\r\n        // stateA.linearVelocity = vA; PJB: vA, vB have been references all along...\r\n        stateA.angularVelocity = wA;\r\n\r\n        // stateB.linearVelocity = vB;\r\n        stateB.angularVelocity = wB;\r\n    }\r\n}\r\n\r\nexport function b2StoreOverflowImpulses(context)\r\n{\r\n    const graph = context.graph;\r\n    const color = graph.colors[b2_overflowIndex];\r\n    const constraints = color.overflowConstraints;\r\n    const contacts = color.contacts;\r\n    const contactCount = color.contacts.count;\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const constraint = constraints[i];\r\n        const contact = contacts.data[i];\r\n        const manifold = contact.manifold;\r\n        const pointCount = manifold.pointCount;\r\n\r\n        for (let j = 0; j < pointCount; ++j)\r\n        {\r\n            manifold.points[j].normalImpulse = constraint.points[j].normalImpulse;\r\n            manifold.points[j].tangentImpulse = constraint.points[j].tangentImpulse;\r\n            manifold.points[j].maxNormalImpulse = constraint.points[j].maxNormalImpulse;\r\n            manifold.points[j].normalVelocity = constraint.points[j].relativeVelocity;\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport * as b2Math from './include/math_functions_h.js';\r\n\r\n/**\r\n * @namespace Aabb\r\n */\r\n\r\n/**\r\n * @import {b2AABB} from './include/math_functions_h.js'\r\n */\r\n\r\n// Get surface area of an AABB (the perimeter length)\r\nexport function b2Perimeter(a)\r\n{\r\n    const wx = a.upperBoundX - a.lowerBoundX;\r\n    const wy = a.upperBoundY - a.lowerBoundY;\r\n\r\n    return 2.0 * (wx + wy);\r\n}\r\n\r\nexport function b2EnlargeAABB(a, b)\r\n{\r\n    let changed = false;\r\n\r\n    if (b.lowerBoundX < a.lowerBoundX)\r\n    {\r\n        a.lowerBoundX = b.lowerBoundX;\r\n        changed = true;\r\n    }\r\n\r\n    if (b.lowerBoundY < a.lowerBoundY)\r\n    {\r\n        a.lowerBoundY = b.lowerBoundY;\r\n        changed = true;\r\n    }\r\n\r\n    if (a.upperBoundX < b.upperBoundX)\r\n    {\r\n        a.upperBoundX = b.upperBoundX;\r\n        changed = true;\r\n    }\r\n\r\n    if (a.upperBoundY < b.upperBoundY)\r\n    {\r\n        a.upperBoundY = b.upperBoundY;\r\n        changed = true;\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\nexport function b2AABB_Overlaps(a, b)\r\n{\r\n    return !(a.lowerBoundX >= b.upperBoundX ||\r\n             a.upperBoundX <= b.lowerBoundX ||\r\n             a.lowerBoundY >= b.upperBoundY ||\r\n             a.upperBoundY <= b.lowerBoundY);\r\n}\r\n\r\n/**\r\n * Validates an Axis-Aligned Bounding Box (AABB)\r\n * @function b2AABB_IsValid\r\n * @param {b2AABB} aabb - The AABB to validate\r\n * @returns {boolean} True if the AABB exists and has valid dimensions and coordinates\r\n * @description\r\n * Checks if an AABB is valid by verifying:\r\n * 1. The AABB object exists\r\n * 2. The width (upperBoundX - lowerBoundX) is non-negative\r\n * 3. The height (upperBoundY - lowerBoundY) is non-negative\r\n * 4. All coordinate values are valid numbers\r\n */\r\nexport function b2AABB_IsValid(aabb)\r\n{\r\n    const dx = aabb.upperBoundX - aabb.lowerBoundX;   // b2Math.b2Sub(a.upperBound, a.lowerBound);\r\n    const dy = aabb.upperBoundY - aabb.lowerBoundY;\r\n    let valid = dx >= 0.0 && dy >= 0.0;\r\n    valid = valid && b2Math.b2IsValid(aabb.lowerBoundX) && b2Math.b2IsValid(aabb.lowerBoundY)\r\n                && b2Math.b2IsValid(aabb.upperBoundX) && b2Math.b2IsValid(aabb.upperBoundY);\r\n\r\n    return valid;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport * as b2Math from './include/math_functions_h.js';\r\n\r\nimport { B2_HUGE, B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2AABB_Overlaps, b2EnlargeAABB, b2Perimeter } from './include/aabb_h.js';\r\n\r\nimport { b2DynamicTree } from './include/dynamic_tree_h.js';\r\nimport { b2PairQueryCallback } from './include/broad_phase_h.js';\r\nimport { b2TreeNode } from './include/collision_h.js';\r\n\r\n/**\r\n * @namespace DynamicTree\r\n */\r\n\r\n/**\r\n * @import {b2AABB, b2Vec2} from './include/math_functions_h.js'\r\n * @import {b2RayCastInput, b2ShapeCastInput} from './include/collision_h.js'\r\n */\r\n\r\nconst B2_TREE_STACK_SIZE = 1024;\r\n\r\nfunction b2IsLeaf(node)\r\n{\r\n    return node.height === 0;\r\n}\r\n\r\n/**\r\n * Creates and initializes a new b2DynamicTree instance.\r\n * @function b2DynamicTree_Create\r\n * @returns {b2DynamicTree} A new dynamic tree with:\r\n * - Initial node capacity of 16\r\n * - Empty root (B2_NULL_INDEX)\r\n * - Initialized node array with parent/next pointers\r\n * - All nodes set to height -1\r\n * - Free list starting at index 0\r\n * - Zero proxy count\r\n * - Null leaf indices and centers\r\n * - Zero rebuild capacity\r\n * @description\r\n * Creates a b2DynamicTree data structure used for efficient spatial partitioning.\r\n * The tree is initialized with a pre-allocated pool of nodes linked in a free list.\r\n */\r\nexport function b2DynamicTree_Create()\r\n{\r\n\r\n    const tree = new b2DynamicTree();\r\n    tree.root = B2_NULL_INDEX;\r\n\r\n    tree.nodeCapacity = 16;\r\n    tree.nodeCount = 0;\r\n    tree.nodes = Array.from({ length: tree.nodeCapacity }, () => new b2TreeNode());    // Array(tree.nodeCapacity).fill().map(() => new b2TreeNode());\r\n\r\n    for (let i = 0; i < tree.nodeCapacity - 1; ++i)\r\n    {\r\n        tree.nodes[i].parent_next = i + 1;\r\n        tree.nodes[i].height = -1;\r\n    }\r\n    tree.nodes[tree.nodeCapacity - 1].parent_next = B2_NULL_INDEX;\r\n    tree.nodes[tree.nodeCapacity - 1].height = -1;\r\n    tree.freeList = 0;\r\n\r\n    tree.proxyCount = 0;\r\n    tree.leafIndices = null;\r\n\r\n    // tree.leafBoxes = null;\r\n    tree.leafCenters = null;\r\n\r\n    // tree.binIndices = null;\r\n    tree.rebuildCapacity = 0;\r\n\r\n    return tree;\r\n}\r\n\r\n/**\r\n * @summary Destroys a dynamic tree by clearing its internal data structures.\r\n * @function b2DynamicTree_Destroy\r\n * @param {b2DynamicTree} tree - The dynamic tree to destroy.\r\n * @returns {void}\r\n * @description\r\n * Clears the nodes, leaf indices, and leaf centers arrays of the dynamic tree,\r\n * effectively destroying the tree's data structure.\r\n */\r\nexport function b2DynamicTree_Destroy(tree)\r\n{\r\n    // In JavaScript, we don't need to manually free memory\r\n    tree.nodes = null;\r\n    tree.leafIndices = null;\r\n\r\n    // tree.leafBoxes = null;\r\n    tree.leafCenters = null;\r\n\r\n    // tree.binIndices = null;\r\n}\r\n\r\nfunction b2AllocateNode(tree)\r\n{\r\n    if (tree.freeList === B2_NULL_INDEX)\r\n    {\r\n        const oldNodes = tree.nodes;\r\n        tree.nodeCapacity += tree.nodeCapacity >> 1;\r\n\r\n        tree.nodes = Array.from({ length: tree.nodeCapacity }, () => new b2TreeNode());    // Array(tree.nodeCapacity).fill().map(() => new b2TreeNode());\r\n        // tree.nodes = new Array(tree.nodeCapacity).fill().map((_, i) => {\r\n        //     if (i < oldNodes.length) {\r\n        //         return oldNodes[i];\r\n        //     } else {\r\n        //         return new b2TreeNode();\r\n        //     }\r\n        // });\r\n        tree.nodes = Array.from({ length: tree.nodeCapacity }, (_, i) =>\r\n        {\r\n            if (i < oldNodes.length)\r\n            {\r\n                return oldNodes[i];\r\n            }\r\n            else\r\n            {\r\n                return new b2TreeNode();\r\n            }\r\n        });\r\n        \r\n        for (let i = tree.nodeCount; i < tree.nodeCapacity - 1; ++i)\r\n        {\r\n            tree.nodes[i].parent_next = i + 1;\r\n            tree.nodes[i].height = -1;\r\n        }\r\n\r\n        tree.nodes[tree.nodeCapacity - 1].parent_next = B2_NULL_INDEX;\r\n        tree.nodes[tree.nodeCapacity - 1].height = -1;\r\n        tree.freeList = tree.nodeCount;\r\n    }\r\n\r\n    const nodeIndex = tree.freeList;\r\n    const node = tree.nodes[nodeIndex];\r\n    tree.freeList = node.parent_next;\r\n    tree.nodes[nodeIndex] = new b2TreeNode();\r\n    ++tree.nodeCount;\r\n\r\n    return nodeIndex;\r\n}\r\n\r\nfunction b2FreeNode(tree, nodeId)\r\n{\r\n    tree.nodes[nodeId].parent_next = tree.freeList;\r\n    tree.nodes[nodeId].height = -1;\r\n    tree.freeList = nodeId;\r\n    --tree.nodeCount;\r\n}\r\n\r\nfunction b2FindBestSibling(tree, boxD)\r\n{\r\n    const centerD = b2Math.b2AABB_Center(boxD);\r\n    const areaD = b2Perimeter(boxD);\r\n\r\n    const nodes = tree.nodes;\r\n    const rootIndex = tree.root;\r\n\r\n    const rootBox = nodes[rootIndex].aabb;\r\n\r\n    let areaBase = b2Perimeter(rootBox);\r\n\r\n    let directCost = b2Perimeter(b2Math.b2AABB_Union(rootBox, boxD));\r\n    let inheritedCost = 0;\r\n\r\n    let bestSibling = rootIndex;\r\n    let bestCost = directCost;\r\n\r\n    let index = rootIndex;\r\n\r\n    while (nodes[index].height > 0)\r\n    {\r\n        const child1 = nodes[index].child1;\r\n        const child2 = nodes[index].child2;\r\n\r\n        const cost = directCost + inheritedCost;\r\n\r\n        if (cost < bestCost)\r\n        {\r\n            bestSibling = index;\r\n            bestCost = cost;\r\n        }\r\n\r\n        inheritedCost += directCost - areaBase;\r\n\r\n        const leaf1 = nodes[child1].height === 0;\r\n        const leaf2 = nodes[child2].height === 0;\r\n\r\n        let lowerCost1 = Number.MAX_VALUE;\r\n        const box1 = nodes[child1].aabb;\r\n        const directCost1 = b2Perimeter(b2Math.b2AABB_Union(box1, boxD));\r\n        let area1 = 0;\r\n\r\n        if (leaf1)\r\n        {\r\n            const cost1 = directCost1 + inheritedCost;\r\n\r\n            if (cost1 < bestCost)\r\n            {\r\n                bestSibling = child1;\r\n                bestCost = cost1;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            area1 = b2Perimeter(box1);\r\n            lowerCost1 = inheritedCost + directCost1 + Math.min(areaD - area1, 0);\r\n        }\r\n\r\n        let lowerCost2 = Number.MAX_VALUE;\r\n        const box2 = nodes[child2].aabb;\r\n        const directCost2 = b2Perimeter(b2Math.b2AABB_Union(box2, boxD));\r\n        let area2 = 0;\r\n\r\n        if (leaf2)\r\n        {\r\n            const cost2 = directCost2 + inheritedCost;\r\n\r\n            if (cost2 < bestCost)\r\n            {\r\n                bestSibling = child2;\r\n                bestCost = cost2;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            area2 = b2Perimeter(box2);\r\n            lowerCost2 = inheritedCost + directCost2 + Math.min(areaD - area2, 0);\r\n        }\r\n\r\n        if (leaf1 && leaf2)\r\n        {\r\n            break;\r\n        }\r\n\r\n        if (bestCost <= lowerCost1 && bestCost <= lowerCost2)\r\n        {\r\n            break;\r\n        }\r\n\r\n        if (lowerCost1 === lowerCost2 && !leaf1)\r\n        {\r\n            const d1 = b2Math.b2Sub(b2Math.b2AABB_Center(box1), centerD);\r\n            const d2 = b2Math.b2Sub(b2Math.b2AABB_Center(box2), centerD);\r\n            lowerCost1 = b2Math.b2LengthSquared(d1);\r\n            lowerCost2 = b2Math.b2LengthSquared(d2);\r\n        }\r\n\r\n        if (lowerCost1 < lowerCost2 && !leaf1)\r\n        {\r\n            index = child1;\r\n            areaBase = area1;\r\n            directCost = directCost1;\r\n        }\r\n        else\r\n        {\r\n            index = child2;\r\n            areaBase = area2;\r\n            directCost = directCost2;\r\n        }\r\n    }\r\n\r\n    return bestSibling;\r\n}\r\n\r\nconst b2RotateType = {\r\n    b2_rotateNone: 0,\r\n    b2_rotateBF: 1,\r\n    b2_rotateBG: 2,\r\n    b2_rotateCD: 3,\r\n    b2_rotateCE: 4\r\n};\r\n\r\n// Perform a left or right rotation if node A is imbalanced.\r\n// Returns the new root index.\r\nexport function b2RotateNodes(tree, iA)\r\n{\r\n    console.assert(iA != B2_NULL_INDEX);\r\n\r\n    const nodes = tree.nodes;\r\n\r\n    const A = nodes[iA];\r\n\r\n    if (A.height < 2)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const iB = A.child1;\r\n    const iC = A.child2;\r\n    console.assert(0 <= iB && iB < tree.nodeCapacity);\r\n    console.assert(0 <= iC && iC < tree.nodeCapacity);\r\n\r\n    const B = nodes[iB];\r\n    const C = nodes[iC];\r\n\r\n    if (B.height === 0)\r\n    {\r\n        // B is a leaf and C is internal\r\n        console.assert(C.height > 0);\r\n\r\n        const iF = C.child1;\r\n        const iG = C.child2;\r\n        const F = nodes[iF];\r\n        const G = nodes[iG];\r\n        console.assert(0 <= iF && iF < tree.nodeCapacity);\r\n        console.assert(0 <= iG && iG < tree.nodeCapacity);\r\n\r\n        // Base cost\r\n        const costBase = b2Perimeter(C.aabb);\r\n\r\n        // Cost of swapping B and F\r\n        const aabbBG = b2Math.b2AABB_Union(B.aabb, G.aabb);\r\n        const costBF = b2Perimeter(aabbBG);\r\n\r\n        // Cost of swapping B and G\r\n        const aabbBF = b2Math.b2AABB_Union(B.aabb, F.aabb);\r\n        const costBG = b2Perimeter(aabbBF);\r\n\r\n        if (costBase < costBF && costBase < costBG)\r\n        {\r\n            // Rotation does not improve cost\r\n            return;\r\n        }\r\n\r\n        if (costBF < costBG)\r\n        {\r\n            // Swap B and F\r\n            A.child1 = iF;\r\n            C.child1 = iB;\r\n\r\n            B.parent_next = iC;\r\n            F.parent_next = iA;\r\n\r\n            C.aabb = aabbBG;\r\n\r\n            C.height = 1 + Math.max(B.height, G.height);\r\n            A.height = 1 + Math.max(C.height, F.height);\r\n            C.categoryBits = B.categoryBits | G.categoryBits;\r\n            A.categoryBits = C.categoryBits | F.categoryBits;\r\n            C.enlarged = B.enlarged || G.enlarged;\r\n            A.enlarged = C.enlarged || F.enlarged;\r\n        }\r\n        else\r\n        {\r\n            // Swap B and G\r\n            A.child1 = iG;\r\n            C.child2 = iB;\r\n\r\n            B.parent_next = iC;\r\n            G.parent_next = iA;\r\n\r\n            C.aabb = aabbBF;\r\n\r\n            C.height = 1 + Math.max(B.height, F.height);\r\n            A.height = 1 + Math.max(C.height, G.height);\r\n            C.categoryBits = B.categoryBits | F.categoryBits;\r\n            A.categoryBits = C.categoryBits | G.categoryBits;\r\n            C.enlarged = B.enlarged || F.enlarged;\r\n            A.enlarged = C.enlarged || G.enlarged;\r\n        }\r\n    }\r\n    else if (C.height === 0)\r\n    {\r\n        // C is a leaf and B is internal\r\n        console.assert(B.height > 0);\r\n\r\n        const iD = B.child1;\r\n        const iE = B.child2;\r\n        const D = nodes[iD];\r\n        const E = nodes[iE];\r\n        console.assert(0 <= iD && iD < tree.nodeCapacity);\r\n        console.assert(0 <= iE && iE < tree.nodeCapacity);\r\n\r\n        // Base cost\r\n        const costBase = b2Perimeter(B.aabb);\r\n\r\n        // Cost of swapping C and D\r\n        const aabbCE = b2Math.b2AABB_Union(C.aabb, E.aabb);\r\n        const costCD = b2Perimeter(aabbCE);\r\n\r\n        // Cost of swapping C and E\r\n        const aabbCD = b2Math.b2AABB_Union(C.aabb, D.aabb);\r\n        const costCE = b2Perimeter(aabbCD);\r\n\r\n        if (costBase < costCD && costBase < costCE)\r\n        {\r\n            // Rotation does not improve cost\r\n            return;\r\n        }\r\n\r\n        if (costCD < costCE)\r\n        {\r\n            // Swap C and D\r\n            A.child2 = iD;\r\n            B.child1 = iC;\r\n\r\n            C.parent_next = iB;\r\n            D.parent_next = iA;\r\n\r\n            B.aabb = aabbCE;\r\n\r\n            B.height = 1 + Math.max(C.height, E.height);\r\n            A.height = 1 + Math.max(B.height, D.height);\r\n            B.categoryBits = C.categoryBits | E.categoryBits;\r\n            A.categoryBits = B.categoryBits | D.categoryBits;\r\n            B.enlarged = C.enlarged || E.enlarged;\r\n            A.enlarged = B.enlarged || D.enlarged;\r\n        }\r\n        else\r\n        {\r\n            // Swap C and E\r\n            A.child2 = iE;\r\n            B.child2 = iC;\r\n\r\n            C.parent_next = iB;\r\n            E.parent_next = iA;\r\n\r\n            B.aabb = aabbCD;\r\n            B.height = 1 + Math.max(C.height, D.height);\r\n            A.height = 1 + Math.max(B.height, E.height);\r\n            B.categoryBits = C.categoryBits | D.categoryBits;\r\n            A.categoryBits = B.categoryBits | E.categoryBits;\r\n            B.enlarged = C.enlarged || D.enlarged;\r\n            A.enlarged = B.enlarged || E.enlarged;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const iD = B.child1;\r\n        const iE = B.child2;\r\n        const iF = C.child1;\r\n        const iG = C.child2;\r\n\r\n        const D = nodes[iD];\r\n        const E = nodes[iE];\r\n        const F = nodes[iF];\r\n        const G = nodes[iG];\r\n\r\n        console.assert(0 <= iD && iD < tree.nodeCapacity);\r\n        console.assert(0 <= iE && iE < tree.nodeCapacity);\r\n        console.assert(0 <= iF && iF < tree.nodeCapacity);\r\n        console.assert(0 <= iG && iG < tree.nodeCapacity);\r\n\r\n        // Base cost\r\n        const areaB = b2Perimeter(B.aabb);\r\n        const areaC = b2Perimeter(C.aabb);\r\n        const costBase = areaB + areaC;\r\n        let bestRotation = b2RotateType.b2_rotateNone;\r\n        let bestCost = costBase;\r\n\r\n        // Cost of swapping B and F\r\n        const aabbBG = b2Math.b2AABB_Union(B.aabb, G.aabb);\r\n        const costBF = areaB + b2Perimeter(aabbBG);\r\n\r\n        if (costBF < bestCost)\r\n        {\r\n            bestRotation = b2RotateType.b2_rotateBF;\r\n            bestCost = costBF;\r\n        }\r\n\r\n        // Cost of swapping B and G\r\n        const aabbBF = b2Math.b2AABB_Union(B.aabb, F.aabb);\r\n        const costBG = areaB + b2Perimeter(aabbBF);\r\n\r\n        if (costBG < bestCost)\r\n        {\r\n            bestRotation = b2RotateType.b2_rotateBG;\r\n            bestCost = costBG;\r\n        }\r\n\r\n        // Cost of swapping C and D\r\n        const aabbCE = b2Math.b2AABB_Union(C.aabb, E.aabb);\r\n        const costCD = areaC + b2Perimeter(aabbCE);\r\n\r\n        if (costCD < bestCost)\r\n        {\r\n            bestRotation = b2RotateType.b2_rotateCD;\r\n            bestCost = costCD;\r\n        }\r\n\r\n        // Cost of swapping C and E\r\n        const aabbCD = b2Math.b2AABB_Union(C.aabb, D.aabb);\r\n        const costCE = areaC + b2Perimeter(aabbCD);\r\n\r\n        if (costCE < bestCost)\r\n        {\r\n            bestRotation = b2RotateType.b2_rotateCE;\r\n\r\n            // bestCost = costCE;\r\n        }\r\n\r\n        switch (bestRotation)\r\n        {\r\n            case b2RotateType.b2_rotateNone:\r\n                break;\r\n\r\n            case b2RotateType.b2_rotateBF:\r\n                A.child1 = iF;\r\n                C.child1 = iB;\r\n\r\n                B.parent_next = iC;\r\n                F.parent_next = iA;\r\n\r\n                C.aabb = aabbBG;\r\n                C.height = 1 + Math.max(B.height, G.height);\r\n                A.height = 1 + Math.max(C.height, F.height);\r\n                C.categoryBits = B.categoryBits | G.categoryBits;\r\n                A.categoryBits = C.categoryBits | F.categoryBits;\r\n                C.enlarged = B.enlarged || G.enlarged;\r\n                A.enlarged = C.enlarged || F.enlarged;\r\n\r\n                break;\r\n\r\n            case b2RotateType.b2_rotateBG:\r\n                A.child1 = iG;\r\n                C.child2 = iB;\r\n\r\n                B.parent_next = iC;\r\n                G.parent_next = iA;\r\n\r\n                C.aabb = aabbBF;\r\n                C.height = 1 + Math.max(B.height, F.height);\r\n                A.height = 1 + Math.max(C.height, G.height);\r\n                C.categoryBits = B.categoryBits | F.categoryBits;\r\n                A.categoryBits = C.categoryBits | G.categoryBits;\r\n                C.enlarged = B.enlarged || F.enlarged;\r\n                A.enlarged = C.enlarged || G.enlarged;\r\n\r\n                break;\r\n\r\n            case b2RotateType.b2_rotateCD:\r\n                A.child2 = iD;\r\n                B.child1 = iC;\r\n\r\n                C.parent_next = iB;\r\n                D.parent_next = iA;\r\n\r\n                B.aabb = aabbCE;\r\n                B.height = 1 + Math.max(C.height, E.height);\r\n                A.height = 1 + Math.max(B.height, D.height);\r\n                B.categoryBits = C.categoryBits | E.categoryBits;\r\n                A.categoryBits = B.categoryBits | D.categoryBits;\r\n                B.enlarged = C.enlarged || E.enlarged;\r\n                A.enlarged = B.enlarged || D.enlarged;\r\n\r\n                break;\r\n\r\n            case b2RotateType.b2_rotateCE:\r\n                A.child2 = iE;\r\n                B.child2 = iC;\r\n\r\n                C.parent_next = iB;\r\n                E.parent_next = iA;\r\n\r\n                B.aabb = aabbCD;\r\n                B.height = 1 + Math.max(C.height, D.height);\r\n                A.height = 1 + Math.max(B.height, E.height);\r\n                B.categoryBits = C.categoryBits | D.categoryBits;\r\n                A.categoryBits = B.categoryBits | E.categoryBits;\r\n                B.enlarged = C.enlarged || D.enlarged;\r\n                A.enlarged = B.enlarged || E.enlarged;\r\n\r\n                break;\r\n\r\n            default:\r\n                console.assert(false);\r\n\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport function b2InsertLeaf(tree, leaf, shouldRotate)\r\n{\r\n    if (tree.root === B2_NULL_INDEX)\r\n    {\r\n        tree.root = leaf;\r\n        tree.nodes[tree.root].parent_next = B2_NULL_INDEX;\r\n\r\n        return;\r\n    }\r\n\r\n    // Stage 1: find the best sibling for this node\r\n    const leafAABB = tree.nodes[leaf].aabb;\r\n    const sibling = b2FindBestSibling(tree, leafAABB);\r\n\r\n    // Stage 2: create a new parent for the leaf and sibling\r\n    const oldParent = tree.nodes[sibling].parent_next;\r\n    const newParent = b2AllocateNode(tree);\r\n\r\n    // warning: node pointer can change after allocation\r\n    const nodes = tree.nodes;\r\n    nodes[newParent].parent_next = oldParent;\r\n    nodes[newParent].userData = -1;\r\n    nodes[newParent].aabb = b2Math.b2AABB_Union(leafAABB, nodes[sibling].aabb);\r\n    nodes[newParent].categoryBits = nodes[leaf].categoryBits | nodes[sibling].categoryBits;\r\n    nodes[newParent].height = nodes[sibling].height + 1;\r\n\r\n    if (oldParent !== B2_NULL_INDEX)\r\n    {\r\n        // The sibling was not the root.\r\n        if (nodes[oldParent].child1 === sibling)\r\n        {\r\n            nodes[oldParent].child1 = newParent;\r\n        }\r\n        else\r\n        {\r\n            nodes[oldParent].child2 = newParent;\r\n        }\r\n        nodes[newParent].child1 = sibling;\r\n        nodes[newParent].child2 = leaf;\r\n        nodes[sibling].parent_next = newParent;\r\n        nodes[leaf].parent_next = newParent;\r\n    }\r\n    else\r\n    {\r\n        // The sibling was the root.\r\n        nodes[newParent].child1 = sibling;\r\n        nodes[newParent].child2 = leaf;\r\n        nodes[sibling].parent_next = newParent;\r\n        nodes[leaf].parent_next = newParent;\r\n        tree.root = newParent;\r\n    }\r\n\r\n    // Stage 3: walk back up the tree fixing heights and AABBs\r\n    let index = nodes[leaf].parent_next;\r\n\r\n    while (index !== B2_NULL_INDEX)\r\n    {\r\n        const child1 = nodes[index].child1;\r\n        const child2 = nodes[index].child2;\r\n        console.assert(child1 !== B2_NULL_INDEX);\r\n        console.assert(child2 !== B2_NULL_INDEX);\r\n        nodes[index].aabb = b2Math.b2AABB_Union(nodes[child1].aabb, nodes[child2].aabb);\r\n        nodes[index].categoryBits = nodes[child1].categoryBits | nodes[child2].categoryBits;\r\n        nodes[index].height = 1 + Math.max(nodes[child1].height, nodes[child2].height);\r\n        nodes[index].enlarged = nodes[child1].enlarged || nodes[child2].enlarged;\r\n\r\n        if (shouldRotate)\r\n        {\r\n            b2RotateNodes(tree, index);\r\n        }\r\n        index = nodes[index].parent_next;\r\n    }\r\n}\r\n\r\nexport function b2RemoveLeaf(tree, leaf)\r\n{\r\n    if (leaf === tree.root)\r\n    {\r\n        tree.root = B2_NULL_INDEX;\r\n\r\n        return;\r\n    }\r\n\r\n    const nodes = tree.nodes;\r\n    const parent = nodes[leaf].parent_next;\r\n    const grandParent = nodes[parent].parent_next;\r\n    let sibling;\r\n\r\n    if (nodes[parent].child1 === leaf)\r\n    {\r\n        sibling = nodes[parent].child2;\r\n    }\r\n    else\r\n    {\r\n        sibling = nodes[parent].child1;\r\n    }\r\n\r\n    if (grandParent !== B2_NULL_INDEX)\r\n    {\r\n        // Destroy parent and connect sibling to grandParent.\r\n        if (nodes[grandParent].child1 === parent)\r\n        {\r\n            nodes[grandParent].child1 = sibling;\r\n        }\r\n        else\r\n        {\r\n            nodes[grandParent].child2 = sibling;\r\n        }\r\n        nodes[sibling].parent_next = grandParent;\r\n        b2FreeNode(tree, parent);\r\n\r\n        // Adjust ancestor bounds.\r\n        let index = grandParent;\r\n\r\n        while (index !== B2_NULL_INDEX)\r\n        {\r\n            const node = nodes[index];\r\n            const child1 = nodes[node.child1];\r\n            const child2 = nodes[node.child2];\r\n\r\n            node.aabb = b2Math.b2AABB_Union(child1.aabb, child2.aabb);\r\n            node.categoryBits = child1.categoryBits | child2.categoryBits;\r\n            node.height = 1 + Math.max(child1.height, child2.height);\r\n            index = node.parent_next;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        tree.root = sibling;\r\n        tree.nodes[sibling].parent_next = B2_NULL_INDEX;\r\n        b2FreeNode(tree, parent);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a proxy in a dynamic tree for collision detection. The proxy is added as a leaf node.\r\n * @function b2DynamicTree_CreateProxy\r\n * @param {b2DynamicTree} tree - The dynamic tree to add the proxy to\r\n * @param {b2AABB} aabb - The axis-aligned bounding box for the proxy\r\n * @param {number} categoryBits - The collision category bits for filtering\r\n * @param {number} userData - User data associated with this proxy\r\n * @returns {number} The ID of the created proxy node\r\n * @throws {Error} Throws assertion error if AABB bounds are outside valid range\r\n */\r\nexport function b2DynamicTree_CreateProxy(tree, aabb, categoryBits, userData)\r\n{\r\n    console.assert( -B2_HUGE< aabb.lowerBoundX && aabb.lowerBoundX < B2_HUGE);\r\n    console.assert( -B2_HUGE< aabb.lowerBoundY && aabb.lowerBoundY < B2_HUGE);\r\n    console.assert( -B2_HUGE< aabb.upperBoundX && aabb.upperBoundX < B2_HUGE);\r\n    console.assert( -B2_HUGE< aabb.upperBoundY && aabb.upperBoundY < B2_HUGE);\r\n\r\n    const proxyId = b2AllocateNode(tree);\r\n    const node = tree.nodes[proxyId];\r\n\r\n    node.aabb = aabb;\r\n    node.userData = userData;\r\n    node.categoryBits = categoryBits;\r\n    node.height = 0;\r\n\r\n    const shouldRotate = true;\r\n    b2InsertLeaf(tree, proxyId, shouldRotate);\r\n\r\n    tree.proxyCount += 1;\r\n\r\n    return proxyId;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_DestroyProxy\r\n * @summary Removes and frees a proxy from the dynamic tree.\r\n * @param {b2DynamicTree} tree - The dynamic tree containing the proxy\r\n * @param {number} proxyId - The ID of the proxy to destroy (must be >= 0 and < nodeCapacity)\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if:\r\n * - proxyId is out of bounds\r\n * - the node is not a leaf\r\n * - the tree has no proxies\r\n * @description\r\n * Removes a leaf node from the tree, frees the node's memory, and decrements\r\n * the proxy count. The proxy must be a valid leaf node in the tree.\r\n */\r\nexport function b2DynamicTree_DestroyProxy(tree, proxyId)\r\n{\r\n    console.assert( 0 <= proxyId && proxyId < tree.nodeCapacity );\r\n    console.assert( b2IsLeaf( tree.nodes[proxyId] ) );\r\n\r\n    b2RemoveLeaf(tree, proxyId);\r\n    b2FreeNode(tree, proxyId);\r\n\r\n    console.assert( tree.proxyCount > 0 );\r\n    tree.proxyCount -= 1;\r\n}\r\n\r\n/**\r\n * @summary Gets the total number of proxies in a dynamic tree.\r\n * @function b2DynamicTree_GetProxyCount\r\n * @param {b2DynamicTree} tree - The dynamic tree to query.\r\n * @returns {number} The total count of proxies in the tree.\r\n * @description\r\n * Returns the number of proxies currently stored in the dynamic tree by accessing\r\n * the proxyCount property.\r\n */\r\nexport function b2DynamicTree_GetProxyCount(tree)\r\n{\r\n    return tree.proxyCount;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_MoveProxy\r\n * @description\r\n * Updates the position of a proxy in the dynamic tree by removing and reinserting it\r\n * with a new AABB.\r\n * @param {b2DynamicTree} tree - The dynamic tree containing the proxy\r\n * @param {number} proxyId - The ID of the proxy to move (must be within tree.nodeCapacity)\r\n * @param {b2AABB} aabb - The new axis-aligned bounding box for the proxy\r\n * @returns {void}\r\n * @throws {Error} Throws assertion errors if:\r\n * - The AABB is invalid\r\n * - The AABB dimensions exceed B2_HUGE\r\n * - The proxyId is out of bounds\r\n * - The node at proxyId is not a leaf node\r\n */\r\nexport function b2DynamicTree_MoveProxy(tree, proxyId, aabb)\r\n{\r\n    console.assert( b2Math.b2AABB_IsValid( aabb ) );\r\n    console.assert( aabb.upperBoundX - aabb.lowerBoundX < B2_HUGE);\r\n    console.assert( aabb.upperBoundY - aabb.lowerBoundY < B2_HUGE);\r\n    console.assert( 0 <= proxyId && proxyId < tree.nodeCapacity );\r\n    console.assert( b2IsLeaf( tree.nodes[proxyId] ) );\r\n\r\n    b2RemoveLeaf(tree, proxyId);\r\n\r\n    tree.nodes[proxyId].aabb = aabb;\r\n\r\n    const shouldRotate = false;\r\n    b2InsertLeaf(tree, proxyId, shouldRotate);\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_EnlargeProxy\r\n * @description\r\n * Updates a proxy's AABB in the dynamic tree and rebalances the tree structure by\r\n * enlarging parent nodes' AABBs as needed.\r\n * @param {b2DynamicTree} tree - The dynamic tree containing the proxy\r\n * @param {number} proxyId - The ID of the proxy to enlarge\r\n * @param {b2AABB} aabb - The new axis-aligned bounding box for the proxy\r\n * @returns {void}\r\n * @throws {Error} Throws assertion errors if:\r\n * - The AABB is invalid\r\n * - The AABB dimensions exceed B2_HUGE\r\n * - The proxyId is out of bounds\r\n * - The node is not a leaf\r\n * - The new AABB is contained within the old one\r\n */\r\nexport function b2DynamicTree_EnlargeProxy(tree, proxyId, aabb)\r\n{\r\n    const nodes = tree.nodes;\r\n\r\n    console.assert( b2Math.b2AABB_IsValid( aabb ) );\r\n    console.assert( aabb.upperBoundX - aabb.lowerBoundX < B2_HUGE);\r\n    console.assert( aabb.upperBoundY - aabb.lowerBoundY < B2_HUGE);\r\n    console.assert( 0 <= proxyId && proxyId < tree.nodeCapacity );\r\n    console.assert( b2IsLeaf( tree.nodes[proxyId] ) );\r\n\r\n    // Caller must ensure this\r\n    console.assert( b2Math.b2AABB_Contains( nodes[proxyId].aabb, aabb ) == false );\r\n\r\n    nodes[proxyId].aabb = aabb;\r\n\r\n    // enlarge parents until they don't need to be bigger to encompass aabb\r\n    let parentIndex = nodes[proxyId].parent_next;\r\n\r\n    while (parentIndex !== B2_NULL_INDEX)\r\n    {\r\n        const changed = b2EnlargeAABB(nodes[parentIndex].aabb, aabb);\r\n        nodes[parentIndex].enlarged = true;\r\n        parentIndex = nodes[parentIndex].parent_next;\r\n\r\n        if (!changed)\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // mark all remaining parents 'enlarged' up to root (or previously marked)\r\n    while (parentIndex !== B2_NULL_INDEX)\r\n    {\r\n        if (nodes[parentIndex].enlarged === true)\r\n        {\r\n            // early out because this ancestor was previously ascended and marked as enlarged\r\n            break;\r\n        }\r\n\r\n        nodes[parentIndex].enlarged = true;\r\n        parentIndex = nodes[parentIndex].parent_next;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Gets the height of a dynamic tree\r\n * @function b2DynamicTree_GetHeight\r\n * @param {b2DynamicTree} tree - The dynamic tree to measure\r\n * @returns {number} The height of the tree. Returns 0 if the tree is empty (root is null)\r\n * @description\r\n * Returns the height of the specified dynamic tree by accessing the height property\r\n * of the root node. The height represents the maximum number of levels from the root\r\n * to any leaf node.\r\n */\r\nexport function b2DynamicTree_GetHeight(tree)\r\n{\r\n    if (tree.root === B2_NULL_INDEX)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    return tree.nodes[tree.root].height;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_GetAreaRatio\r\n * @summary Calculates the ratio of total internal node perimeter to root node perimeter in a dynamic tree\r\n * @param {b2DynamicTree} tree - The dynamic tree structure to analyze\r\n * @returns {number} The ratio of total internal node perimeter to root perimeter. Returns 0 if the tree is empty.\r\n * @description\r\n * Computes the sum of all internal node perimeters (excluding leaves and root)\r\n * divided by the root node perimeter. This ratio provides a measure of the tree's\r\n * spatial organization.\r\n */\r\nexport function b2DynamicTree_GetAreaRatio(tree)\r\n{\r\n    if (tree.root === B2_NULL_INDEX)\r\n    {\r\n        return 0.0;\r\n    }\r\n\r\n    const root = tree.nodes[tree.root];\r\n    const rootArea = b2Perimeter(root.aabb);\r\n\r\n    let totalArea = 0.0;\r\n\r\n    for (let i = 0; i < tree.nodeCapacity; ++i)\r\n    {\r\n        const node = tree.nodes[i];\r\n\r\n        if (node.height < 0 || b2IsLeaf(node) || i === tree.root)\r\n        {\r\n            // Free node in pool\r\n            continue;\r\n        }\r\n\r\n        totalArea += b2Perimeter(node.aabb);\r\n    }\r\n\r\n    return totalArea / rootArea;\r\n}\r\n\r\n// // Compute the height of a sub-tree.\r\n// function b2ComputeHeight(tree, nodeId) {\r\n//     console.assert( 0 <= nodeId && nodeId < tree.nodeCapacity );\r\n//     const node = tree.nodes[nodeId];\r\n\r\n//     if (b2IsLeaf(node)) {\r\n//         return 0;\r\n//     }\r\n\r\n//     const height1 = b2ComputeHeight(tree, node.child1);\r\n//     const height2 = b2ComputeHeight(tree, node.child2);\r\n//     return 1 + Math.max(height1, height2);\r\n// }\r\n\r\n// export function b2DynamicTree_ComputeHeight(tree) {\r\n//     const height = b2ComputeHeight(tree, tree.root);\r\n//     return height;\r\n// }\r\n\r\n/**\r\n * @summary Validates the internal state of a dynamic tree\r\n * @function b2DynamicTree_Validate\r\n * @param {b2DynamicTree} tree - The dynamic tree to validate\r\n * @returns {void}\r\n * @description\r\n * Performs validation checks on a b2DynamicTree data structure to ensure\r\n * its internal state is consistent. This is typically used for debugging\r\n * and testing purposes.\r\n */\r\nexport function b2DynamicTree_Validate(tree)\r\n{\r\n    // Implementation skipped due to conditional compilation\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_GetMaxBalance\r\n * @summary Calculates the maximum height difference between sibling nodes in a dynamic tree\r\n * @param {b2DynamicTree} tree - The dynamic tree to analyze\r\n * @returns {number} The maximum balance value (height difference) found between any pair of sibling nodes\r\n * @description\r\n * Iterates through all non-leaf nodes in the tree and calculates the absolute height difference\r\n * between their child nodes. Returns the largest height difference found.\r\n */\r\nexport function b2DynamicTree_GetMaxBalance(tree)\r\n{\r\n    let maxBalance = 0;\r\n\r\n    for (let i = 0; i < tree.nodeCapacity; ++i)\r\n    {\r\n        const node = tree.nodes[i];\r\n\r\n        if (node.height <= 1)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        console.assert(b2IsLeaf(node) == false);\r\n\r\n        const child1 = node.child1;\r\n        const child2 = node.child2;\r\n        const balance = Math.abs(tree.nodes[child2].height - tree.nodes[child1].height);\r\n        maxBalance = Math.max(maxBalance, balance);\r\n    }\r\n\r\n    return maxBalance;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_RebuildBottomUp\r\n * @description\r\n * Rebuilds a dynamic tree from the bottom up by iteratively combining nodes with the lowest perimeter cost.\r\n * The function first identifies all leaf nodes, then pairs them based on minimum combined AABB perimeter,\r\n * creating parent nodes until a single root node remains.\r\n * @param {b2DynamicTree} tree - The dynamic tree to rebuild\r\n * @returns {void}\r\n * @note The function validates the tree structure after rebuilding\r\n */\r\nexport function b2DynamicTree_RebuildBottomUp(tree)\r\n{\r\n    const nodes = new Array(tree.nodeCount);\r\n    let count = 0;\r\n\r\n    // Build array of leaves. Free the rest.\r\n    for (let i = 0; i < tree.nodeCapacity; ++i)\r\n    {\r\n        if (tree.nodes[i].height < 0)\r\n        {\r\n            // free node in pool\r\n            continue;\r\n        }\r\n\r\n        if (b2IsLeaf(tree.nodes[i]))\r\n        {\r\n            tree.nodes[i].parent_next = B2_NULL_INDEX;\r\n            nodes[count] = i;\r\n            ++count;\r\n        }\r\n        else\r\n        {\r\n            b2FreeNode(tree, i);\r\n        }\r\n    }\r\n\r\n    while (count > 1)\r\n    {\r\n        let minCost = Number.MAX_VALUE;\r\n        let iMin = -1,\r\n            jMin = -1;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const aabbi = tree.nodes[nodes[i]].aabb;\r\n\r\n            for (let j = i + 1; j < count; ++j)\r\n            {\r\n                const aabbj = tree.nodes[nodes[j]].aabb;\r\n                const b = b2Math.b2AABB_Union(aabbi, aabbj);\r\n                const cost = b2Perimeter(b);\r\n\r\n                if (cost < minCost)\r\n                {\r\n                    iMin = i;\r\n                    jMin = j;\r\n                    minCost = cost;\r\n                }\r\n            }\r\n        }\r\n\r\n        const index_i = nodes[iMin];\r\n        const index_j = nodes[jMin];\r\n        const child1 = tree.nodes[index_i];\r\n        const child2 = tree.nodes[index_j];\r\n\r\n        const parentIndex = b2AllocateNode(tree);\r\n        const parent = tree.nodes[parentIndex];\r\n        parent.child1 = index_i;\r\n        parent.child2 = index_j;\r\n        parent.aabb = b2Math.b2AABB_Union(child1.aabb, child2.aabb);\r\n        parent.categoryBits = child1.categoryBits | child2.categoryBits;\r\n        parent.height = 1 + Math.max(child1.height, child2.height);\r\n        parent.parent_next = B2_NULL_INDEX;\r\n\r\n        child1.parent_next = parentIndex;\r\n        child2.parent_next = parentIndex;\r\n\r\n        nodes[jMin] = nodes[count - 1];\r\n        nodes[iMin] = parentIndex;\r\n        --count;\r\n    }\r\n\r\n    tree.root = nodes[0];\r\n\r\n    b2DynamicTree_Validate(tree);\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_ShiftOrigin\r\n * @summary Shifts the coordinate system of all nodes in a dynamic tree by subtracting a new origin.\r\n * @param {b2DynamicTree} tree - The dynamic tree whose nodes will be shifted\r\n * @param {b2Vec2} newOrigin - The vector to subtract from all node boundaries\r\n * @returns {void}\r\n * @description\r\n * Updates the axis-aligned bounding boxes (AABBs) of all nodes in the tree by\r\n * subtracting the newOrigin vector from both their lower and upper bounds.\r\n */\r\nexport function b2DynamicTree_ShiftOrigin(tree, newOrigin)\r\n{\r\n    // shift all AABBs\r\n    for (let i = 0; i < tree.nodeCapacity; ++i)\r\n    {\r\n        const n = tree.nodes[i];\r\n        n.aabb.lowerBoundX -= newOrigin.x;\r\n        n.aabb.lowerBoundY -= newOrigin.y;\r\n        n.aabb.upperBoundX -= newOrigin.x;\r\n        n.aabb.upperBoundY -= newOrigin.y;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_GetByteCount\r\n * @summary Calculates the approximate memory usage of a dynamic tree in bytes.\r\n * @param {b2DynamicTree} tree - The dynamic tree instance to measure.\r\n * @returns {number} The estimated memory usage in bytes.\r\n * @description\r\n * Calculates the memory footprint by summing:\r\n * - Base object properties\r\n * - Node array storage\r\n * - Rebuild capacity storage\r\n */\r\nexport function b2DynamicTree_GetByteCount(tree)\r\n{\r\n    const size = Object.keys(tree).length * 8 + // Rough estimate for object properties\r\n               tree.nodeCapacity * Object.keys(tree.nodes[0]).length * 8 + // Estimate for nodes\r\n               tree.rebuildCapacity * (4 + 16 + 8 + 4); // Estimate for rebuild data\r\n\r\n    return size;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_Query\r\n * @description\r\n * Queries a dynamic tree to find all nodes that overlap with the given AABB and match the category mask bits.\r\n * Uses a stack-based traversal to efficiently search the tree structure.\r\n * @param {b2DynamicTree} tree - The dynamic tree to query\r\n * @param {b2AABB} aabb - The axis-aligned bounding box to test for overlaps\r\n * @param {number} maskBits - Category bits used to filter nodes\r\n * @param {function} callback - Function called for each overlapping leaf node.\r\n * Return false to terminate early, true to continue.\r\n * @param {*} context - User context data passed to the callback function\r\n * @returns {void}\r\n */\r\nexport function b2DynamicTree_Query(tree, aabb, maskBits, callback, context)\r\n{\r\n    if (tree.root == B2_NULL_INDEX)\r\n    {\r\n        return;\r\n    }\r\n        \r\n    const stack = [];\r\n    stack.push(tree.root);\r\n\r\n    while (stack.length > 0)\r\n    {\r\n        const nodeId = stack.pop();\r\n\r\n        if (nodeId == B2_NULL_INDEX)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const node = tree.nodes[nodeId];\r\n\r\n        if ((node.categoryBits & maskBits) !== 0 && b2AABB_Overlaps(node.aabb, aabb))\r\n        {\r\n            // PJB: this is called a LOT, remove function call overhead\r\n            if (node.height == 0)   // b2IsLeaf(node))\r\n            {\r\n                // callback to user code with proxy id\r\n                const proceed = callback(nodeId, node.userData, context);\r\n\r\n                if (proceed === false)\r\n                {\r\n                    return;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                stack.push(node.child1);\r\n                stack.push(node.child2);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst stack = Array(64);        // 14 is the deepest I have seen\r\n\r\nexport function b2DynamicTree_QueryAll(tree, aabb, context)\r\n{\r\n    if (tree.root == B2_NULL_INDEX)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const lx = aabb.lowerBoundX,\r\n        ux = aabb.upperBoundX;\r\n    const ly = aabb.lowerBoundY,\r\n        uy = aabb.upperBoundY;\r\n    const nodes = tree.nodes;\r\n\r\n    let stackCount = 0;\r\n    stack[stackCount++] = tree.root;\r\n\r\n    let nodeId, node, a;\r\n\r\n    while (stackCount > 0)\r\n    {\r\n        nodeId = stack[--stackCount];\r\n        node = nodes[nodeId];\r\n\r\n        if (node.height == 0)   // b2IsLeaf(node)\r\n        {\r\n            a = node.aabb;      // weird JS optimisation, we gain 100ms (from 8600ms) if this is done inside each branch compared with doing it before\r\n\r\n            if (a.lowerBoundX < ux &&\r\n                a.upperBoundX > lx &&\r\n                a.lowerBoundY < uy &&\r\n                a.upperBoundY > ly)\r\n            {\r\n                b2PairQueryCallback(nodeId, node.userData, context);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            a = node.aabb;\r\n\r\n            if (a.lowerBoundX < ux &&\r\n                a.upperBoundX > lx &&\r\n                a.lowerBoundY < uy &&\r\n                a.upperBoundY > ly)\r\n            {\r\n                // assumes both children will exist, following the pattern in (e.g.) b2FindBestSibling\r\n                stack[stackCount++] = node.child1;\r\n                stack[stackCount++] = node.child2;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Performs a ray cast query on a dynamic tree\r\n * @function b2DynamicTree_RayCast\r\n * @param {b2DynamicTree} tree - The dynamic tree to query\r\n * @param {b2RayCastInput} input - Input parameters for the ray cast including:\r\n * - origin: b2Vec2 starting point\r\n * - translation: b2Vec2 ray direction and length\r\n * - maxFraction: number maximum ray length multiplier\r\n * @param {number} maskBits - Bit mask to filter nodes by category\r\n * @param {Function} callback - Function called for each leaf node intersection\r\n * - Parameters: (input: b2RayCastInput, nodeId: number, userData: any, context: any)\r\n * - Returns: number between 0 and 1 to continue search, 0 to terminate\r\n * @param {*} context - User context passed to callback\r\n * @description\r\n * Traverses the dynamic tree and finds all leaf nodes that intersect with the input ray.\r\n * For each intersection, calls the callback function which can control continuation of the search.\r\n * Uses an AABB overlap test and separating axis test to efficiently cull branches.\r\n */\r\nexport function b2DynamicTree_RayCast(tree, input, maskBits, callback, context)\r\n{\r\n    const p1 = input.origin;\r\n    const d = input.translation;\r\n\r\n    const r = b2Math.b2Normalize(d);\r\n\r\n    // v is perpendicular to the segment.\r\n    const v = b2Math.b2CrossSV(1.0, r);\r\n    const abs_v = b2Math.b2Abs(v);\r\n\r\n    // Separating axis for segment (Gino, p80).\r\n    // |dot(v, p1 - c)| > dot(|v|, h)\r\n\r\n    let maxFraction = input.maxFraction;\r\n\r\n    let p2 = b2Math.b2MulAdd(p1, maxFraction, d);\r\n\r\n    // Build a bounding box for the segment.\r\n    // let segmentAABB = new b2Math.b2AABB(b2Math.b2Min(p1, p2), b2Math.b2Max(p1, p2));\r\n    const segmentAABB = new b2Math.b2AABB(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.max(p1.x, p2.x), Math.max(p1.y, p2.y));\r\n\r\n    const stack = [];\r\n    stack.push(tree.root);\r\n\r\n    const subInput = input;\r\n\r\n    while (stack.length > 0)\r\n    {\r\n        const nodeId = stack.pop();\r\n\r\n        if (nodeId == B2_NULL_INDEX)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const node = tree.nodes[nodeId];\r\n\r\n        if (b2AABB_Overlaps(node.aabb, segmentAABB) == false || (node.categoryBits & maskBits) == 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        // Separating axis for segment (Gino, p80).\r\n        // |dot(v, p1 - c)| > dot(|v|, h)\r\n        // radius extension is added to the node in this case\r\n        const c = b2Math.b2AABB_Center(node.aabb);\r\n        const h = b2Math.b2AABB_Extents(node.aabb);\r\n        const term1 = Math.abs(b2Math.b2Dot(v, b2Math.b2Sub(p1, c)));\r\n        const term2 = b2Math.b2Dot(abs_v, h);\r\n\r\n        if (term2 < term1)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (node.height == 0)   // b2IsLeaf(node))\r\n        {\r\n            subInput.maxFraction = maxFraction;\r\n\r\n            const value = callback(subInput, nodeId, node.userData, context);\r\n\r\n            if (value == 0.0)\r\n            {\r\n                // The client has terminated the ray cast.\r\n                return;\r\n            }\r\n\r\n            if (0.0 < value && value <= maxFraction)\r\n            {\r\n                // Update segment bounding box.\r\n                maxFraction = value;\r\n                p2 = b2Math.b2MulAdd(p1, maxFraction, d);\r\n                segmentAABB.lowerBoundX = Math.min(p1.x, p2.x);\r\n                segmentAABB.lowerBoundY = Math.min(p1.y, p2.y);\r\n                segmentAABB.upperBoundX = Math.max(p1.x, p2.x);\r\n                segmentAABB.upperBoundY = Math.max(p1.y, p2.y);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // TODO_ERIN just put one node on the stack, continue on a child node\r\n            // TODO_ERIN test ordering children by nearest to ray origin\r\n            stack.push(node.child1);\r\n            stack.push(node.child2);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_ShapeCast\r\n * @description\r\n * Performs a shape cast query against nodes in a dynamic tree, testing for overlaps\r\n * between a moving shape and static shapes in the tree.\r\n * @param {b2DynamicTree} tree - The dynamic tree to query against\r\n * @param {b2ShapeCastInput} input - Contains the shape definition, translation vector,\r\n * radius, and maximum fraction for the cast\r\n * @param {number} maskBits - Bit mask to filter tree nodes by category\r\n * @param {Function} callback - Function called when potential overlaps are found.\r\n * Returns a fraction value to continue or terminate the cast\r\n * @param {*} context - User data passed to the callback function\r\n * @returns {void}\r\n * The callback function should have the signature:\r\n * function(input: b2ShapeCastInput, nodeId: number, userData: any, context: any): number\r\n * It should return 0 to terminate the cast, or a fraction between 0 and 1 to update the cast distance\r\n */\r\nexport function b2DynamicTree_ShapeCast(tree, input, maskBits, callback, context)\r\n{\r\n    if (input.count == 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const originAABB = new b2Math.b2AABB(input.points[0], input.points[0]);\r\n\r\n    for (let i = 1; i < input.count; ++i)\r\n    {\r\n        originAABB.lowerBoundX = Math.min(originAABB.lowerBoundX, input.points[i].x);\r\n        originAABB.lowerBoundY = Math.min(originAABB.lowerBoundY, input.points[i].y);\r\n        originAABB.upperBoundX = Math.max(originAABB.upperBoundX, input.points[i].x);\r\n        originAABB.upperBoundY = Math.max(originAABB.upperBoundY, input.points[i].y);\r\n    }\r\n\r\n    // let radius = new b2Math.b2Vec2(input.radius, input.radius);\r\n\r\n    // originAABB.lowerBound = b2Math.b2Sub(originAABB.lowerBound, radius);\r\n    originAABB.lowerBoundX = originAABB.lowerBoundX - input.radius;\r\n    originAABB.lowerBoundY = originAABB.lowerBoundY - input.radius;\r\n    originAABB.upperBoundX = originAABB.upperBoundX + input.radius;\r\n    originAABB.upperBoundY = originAABB.upperBoundY + input.radius;\r\n\r\n    const p1 = b2Math.b2AABB_Center(originAABB);\r\n    const extension = b2Math.b2AABB_Extents(originAABB);\r\n\r\n    // v is perpendicular to the segment.\r\n    const r = input.translation;\r\n    const v = b2Math.b2CrossSV(1.0, r);\r\n    const abs_v = b2Math.b2Abs(v);\r\n\r\n    // Separating axis for segment (Gino, p80).\r\n    // |dot(v, p1 - c)| > dot(|v|, h)\r\n\r\n    let maxFraction = input.maxFraction;\r\n\r\n    // Build total box for the shape cast\r\n    let t = b2Math.b2MulSV(maxFraction, input.translation);\r\n\r\n    // let totalAABB = new b2Math.b2AABB(b2Math.b2Min(originAABB.lowerBound, b2Math.b2Add(originAABB.lowerBound, t)),b2Math.b2Max(originAABB.upperBound, b2Math.b2Add(originAABB.upperBound, t)));\r\n    const totalAABB = new b2Math.b2AABB(\r\n        Math.min(originAABB.lowerBoundX, originAABB.lowerBoundX + t.x),\r\n        Math.min(originAABB.lowerBoundY, originAABB.lowerBoundY + t.y),\r\n        Math.max(originAABB.upperBoundX, originAABB.upperBoundX + t.x),\r\n        Math.max(originAABB.upperBoundY, originAABB.upperBoundY + t.y)\r\n    );\r\n\r\n    const subInput = input;\r\n\r\n    const stack = []; // new Array(B2_TREE_STACK_SIZE);\r\n    stack.push(tree.root);\r\n\r\n    while (stack.length > 0)\r\n    {\r\n        const nodeId = stack.pop();\r\n\r\n        if (nodeId == B2_NULL_INDEX)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const node = tree.nodes[nodeId];\r\n\r\n        if (b2AABB_Overlaps(node.aabb, totalAABB) == false || (node.categoryBits & maskBits) == 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        // Separating axis for segment (Gino, p80).\r\n        // |dot(v, p1 - c)| > dot(|v|, h)\r\n        // radius extension is added to the node in this case\r\n        const c = b2Math.b2AABB_Center(node.aabb);\r\n        const h = b2Math.b2Add(b2Math.b2AABB_Extents(node.aabb), extension);\r\n        const term1 = Math.abs(b2Math.b2Dot(v, b2Math.b2Sub(p1, c)));\r\n        const term2 = b2Math.b2Dot(abs_v, h);\r\n\r\n        if (term2 < term1)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (node.height == 0)   // b2IsLeaf(node))\r\n        {\r\n            subInput.maxFraction = maxFraction;\r\n\r\n            const value = callback(subInput, nodeId, node.userData, context);\r\n\r\n            if (value == 0.0)\r\n            {\r\n                // The client has terminated the ray cast.\r\n                return;\r\n            }\r\n\r\n            if (0.0 < value && value < maxFraction)\r\n            {\r\n                // Update segment bounding box.\r\n                maxFraction = value;\r\n                t = b2Math.b2MulSV(maxFraction, input.translation);\r\n\r\n                // totalAABB.lowerBound = b2Math.b2Min(originAABB.lowerBound, b2Math.b2Add(originAABB.lowerBound, t));\r\n                // totalAABB.upperBound = b2Math.b2Max(originAABB.upperBound, b2Math.b2Add(originAABB.upperBound, t));\r\n                totalAABB.lowerBoundX = Math.min(originAABB.lowerBoundX, originAABB.lowerBoundX + t.x);\r\n                totalAABB.lowerBoundY = Math.min(originAABB.lowerBoundY, originAABB.lowerBoundY + t.y);\r\n                totalAABB.upperBoundX = Math.max(originAABB.upperBoundX, originAABB.upperBoundX + t.x);\r\n                totalAABB.upperBoundY = Math.max(originAABB.upperBoundY, originAABB.upperBoundY + t.y);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // TODO_ERIN just put one node on the stack, continue on a child node\r\n            // TODO_ERIN test ordering children by nearest to ray origin\r\n            stack.push(node.child1);\r\n            stack.push(node.child2);\r\n        }\r\n    }\r\n}\r\n\r\n// Median split heuristic\r\nfunction b2PartitionMid(indices, centers, startIndex, endIndex, count)\r\n{\r\n    // Handle trivial case\r\n    if (count <= 2)\r\n    {\r\n        return startIndex + (count >> 1);\r\n    }\r\n\r\n    // Create bounding box enclosing all centers\r\n    let lowerBoundX = centers[startIndex].x;\r\n    let upperBoundX = centers[startIndex].x;\r\n    let lowerBoundY = centers[startIndex].y;\r\n    let upperBoundY = centers[startIndex].y;\r\n\r\n    for (let i = startIndex + 1; i < endIndex; ++i)\r\n    {\r\n        const x = centers[i].x;\r\n        const y = centers[i].y;\r\n\r\n        if (x < lowerBoundX) { lowerBoundX = x; }\r\n        else if (x > upperBoundX) { upperBoundX = x; }\r\n\r\n        if (y < lowerBoundY) { lowerBoundY = y; }\r\n        else if (y > upperBoundY) { upperBoundY = y; }\r\n    }\r\n\r\n    // Find the longer box dimension\r\n    const dX = upperBoundX - lowerBoundX;\r\n    const dY = upperBoundY - lowerBoundY;\r\n    const dirX = dX > dY;\r\n\r\n    // Partition using the Hoare partition scheme\r\n    let left = startIndex;\r\n    let right = endIndex - 1;\r\n\r\n    if (dirX)\r\n    {\r\n        const pivot = 0.5 * (lowerBoundX + upperBoundX);\r\n\r\n        while (true)\r\n        {\r\n            while (left <= right && centers[left].x < pivot) { left++; }\r\n\r\n            while (left <= right && centers[right].x > pivot) { right--; }\r\n\r\n            if (left >= right) { break; }\r\n\r\n            // Swap indices and centers\r\n            let temp = indices[left];\r\n            indices[left] = indices[right];\r\n            indices[right] = temp;\r\n\r\n            temp = centers[left];\r\n            centers[left] = centers[right];\r\n            centers[right] = temp;\r\n\r\n            left++;\r\n            right--;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const pivot = 0.5 * (lowerBoundY + upperBoundY);\r\n\r\n        while (true)\r\n        {\r\n            while (left <= right && centers[left].y < pivot)\r\n            {\r\n                left++;\r\n            }\r\n\r\n            while (left <= right && centers[right].y > pivot)\r\n            {\r\n                right--;\r\n            }\r\n\r\n            if (left >= right)\r\n            {\r\n                break;\r\n            }\r\n\r\n            // Swap indices and centers\r\n            let temp = indices[left];\r\n            indices[left] = indices[right];\r\n            indices[right] = temp;\r\n\r\n            temp = centers[left];\r\n            centers[left] = centers[right];\r\n            centers[right] = temp;\r\n\r\n            left++;\r\n            right--;\r\n        }\r\n    }\r\n\r\n    return left > startIndex && left < endIndex ? left : (startIndex + (count >> 1));\r\n}\r\n\r\nfunction b2BuildTree(tree, leafCount)\r\n{\r\n    const { nodes, leafIndices, leafCenters } = tree;\r\n\r\n    if (leafCount === 1)\r\n    {\r\n        nodes[leafIndices[0]].parent_next = B2_NULL_INDEX;\r\n\r\n        return leafIndices[0];\r\n    }\r\n\r\n    const stack = new Array(B2_TREE_STACK_SIZE);\r\n    let top = 0;\r\n\r\n    stack[0] = {\r\n        nodeIndex: b2AllocateNode(tree),\r\n        childCount: -1,\r\n        startIndex: 0,\r\n        endIndex: leafCount,\r\n        splitIndex: b2PartitionMid(leafIndices, leafCenters, 0, leafCount, leafCount)\r\n    };\r\n\r\n    while (true)\r\n    {\r\n        const item = stack[top];\r\n        item.childCount++;\r\n\r\n        if (item.childCount === 2)\r\n        {\r\n            if (top === 0) { break; }\r\n\r\n            const parentItem = stack[top - 1];\r\n            const parentNode = nodes[parentItem.nodeIndex];\r\n            const childIndex = item.nodeIndex;\r\n\r\n            if (parentItem.childCount === 0)\r\n            {\r\n                parentNode.child1 = childIndex;\r\n            }\r\n            else\r\n            {\r\n                parentNode.child2 = childIndex;\r\n            }\r\n\r\n            const node = nodes[childIndex];\r\n            node.parent_next = parentItem.nodeIndex;\r\n\r\n            const child1 = nodes[node.child1];\r\n            const child2 = nodes[node.child2];\r\n\r\n            node.aabb = b2Math.b2AABB_Union(child1.aabb, child2.aabb);\r\n            node.height = 1 + Math.max(child1.height, child2.height);\r\n            node.categoryBits = child1.categoryBits | child2.categoryBits;\r\n\r\n            top--;\r\n        }\r\n        else\r\n        {\r\n            const [ startIndex, endIndex ] = item.childCount === 0\r\n                ? [ item.startIndex, item.splitIndex ]\r\n                : [ item.splitIndex, item.endIndex ];\r\n\r\n            const count = endIndex - startIndex;\r\n\r\n            if (count === 1)\r\n            {\r\n                const childIndex = leafIndices[startIndex];\r\n                const node = nodes[item.nodeIndex];\r\n                \r\n                node[item.childCount === 0 ? 'child1' : 'child2'] = childIndex;\r\n\r\n                nodes[childIndex].parent_next = item.nodeIndex;\r\n            }\r\n            else\r\n            {\r\n                stack[++top] = {\r\n                    nodeIndex: b2AllocateNode(tree),\r\n                    childCount: -1,\r\n                    startIndex,\r\n                    endIndex,\r\n                    splitIndex: b2PartitionMid(\r\n                        leafIndices,\r\n                        leafCenters,\r\n                        startIndex, endIndex,\r\n                        count\r\n                    )\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    const rootNode = nodes[stack[0].nodeIndex];\r\n    const child1 = nodes[rootNode.child1];\r\n    const child2 = nodes[rootNode.child2];\r\n\r\n    rootNode.aabb = b2Math.b2AABB_Union(child1.aabb, child2.aabb);\r\n    rootNode.height = 1 + Math.max(child1.height, child2.height);\r\n    rootNode.categoryBits = child1.categoryBits | child2.categoryBits;\r\n\r\n    return stack[0].nodeIndex;\r\n}\r\n\r\n/**\r\n * @function b2DynamicTree_Rebuild\r\n * @description\r\n * Rebuilds a dynamic tree by collecting all leaf nodes and reconstructing the tree structure.\r\n * The function deallocates internal nodes during traversal and builds a new balanced tree\r\n * from the collected leaf nodes.\r\n * @param {b2DynamicTree} tree - The dynamic tree to rebuild\r\n * @returns {number} The number of leaf nodes in the rebuilt tree\r\n * @note If the proxy count exceeds the rebuild capacity, the internal arrays are resized\r\n * to accommodate the new size plus 50% additional capacity. It is not safe to access the tree during this operation because it may grow.\r\n */\r\nexport function b2DynamicTree_Rebuild(tree)\r\n{\r\n    const proxyCount = tree.proxyCount;\r\n\r\n    if (proxyCount === 0)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    // Ensure capacity for rebuild space\r\n    if (proxyCount > tree.rebuildCapacity)\r\n    {\r\n        const newCapacity = proxyCount + Math.floor(proxyCount / 2);\r\n\r\n        tree.leafIndices = Array(newCapacity);\r\n        tree.leafCenters = Array(newCapacity);\r\n        tree.rebuildCapacity = newCapacity;\r\n    }\r\n\r\n    let leafCount = 0;\r\n    const stack = [];   // new Array(B2_TREE_STACK_SIZE);\r\n\r\n    let nodeIndex = tree.root;\r\n    const nodes = tree.nodes;\r\n    let node = nodes[nodeIndex];\r\n\r\n    // These are the nodes that get sorted to rebuild the tree.\r\n    // I'm using indices because the node pool may grow during the build.\r\n    const leafIndices = tree.leafIndices;\r\n    const leafCenters = tree.leafCenters;\r\n\r\n    // Gather all proxy nodes that have grown and all internal nodes that haven't grown. Both are\r\n    // considered leaves in the tree rebuild.\r\n    // Free all internal nodes that have grown.\r\n    while (true)\r\n    {\r\n        if (node.height === 0 || node.enlarged === false)\r\n        {\r\n            leafIndices[leafCount] = nodeIndex;\r\n            leafCenters[leafCount] = b2Math.b2AABB_Center(node.aabb);\r\n            leafCount++;\r\n\r\n            // Detach\r\n            node.parent_next = B2_NULL_INDEX;\r\n        }\r\n        else\r\n        {\r\n            const doomedNodeIndex = nodeIndex;\r\n\r\n            // Handle children, push child2 for later, process child1 immediately\r\n            stack.push(node.child2);\r\n\r\n            nodeIndex = node.child1;\r\n            node = nodes[nodeIndex];\r\n\r\n            // Remove doomed node\r\n            b2FreeNode(tree, doomedNodeIndex);\r\n\r\n            continue;\r\n        }\r\n\r\n        // check here instead of in while, node is carried around to the next iteration\r\n        if (stack.length === 0)\r\n        {\r\n            break;\r\n        }\r\n\r\n        nodeIndex = stack.pop();\r\n        node = nodes[nodeIndex];\r\n    }\r\n\r\n    console.assert(leafCount <= proxyCount);\r\n\r\n    tree.root = b2BuildTree(tree, leafCount);\r\n\r\n    return leafCount;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX } from '../core_c.js';\r\n\r\nexport {\r\n    b2DynamicTree_Create, b2DynamicTree_Destroy, b2DynamicTree_CreateProxy, b2DynamicTree_DestroyProxy,\r\n    b2DynamicTree_GetProxyCount, b2DynamicTree_MoveProxy, b2DynamicTree_EnlargeProxy, b2DynamicTree_GetHeight,\r\n    b2DynamicTree_GetAreaRatio, b2DynamicTree_Validate,\r\n    b2DynamicTree_Query, b2DynamicTree_QueryAll,\r\n    b2DynamicTree_RayCast, b2DynamicTree_ShapeCast, b2DynamicTree_Rebuild, b2RotateNodes,\r\n    b2InsertLeaf, b2RemoveLeaf,\r\n    b2DynamicTree_GetMaxBalance,\r\n    b2DynamicTree_RebuildBottomUp,\r\n    b2DynamicTree_ShiftOrigin,\r\n    b2DynamicTree_GetByteCount\r\n} from '../dynamic_tree_c.js';\r\n\r\n/**\r\n * Get proxy user data\r\n * @param {Object} tree - The dynamic tree object\r\n * @param {number} proxyId - The proxy ID\r\n * @returns {number} The proxy user data or 0 if the id is invalid\r\n */\r\nexport function b2DynamicTree_GetUserData(tree, proxyId)\r\n{\r\n    const node = tree.nodes[proxyId];\r\n\r\n    return node ? node.userData : 0;\r\n}\r\n\r\nexport function b2DynamicTree_GetAABB(tree, proxyId)\r\n{\r\n    return proxyId in tree.nodes ? tree.nodes[proxyId].aabb : null;\r\n\r\n    // PJB - never seems to fail, avoid the branch overhead: this is called a lot\r\n    // return tree.nodes[proxyId].aabb;\r\n}\r\n\r\n/**\r\n * @class b2DynamicTree\r\n * @summary The dynamic tree structure used internally for performance reasons\r\n * @property {b2TreeNode[]} nodes - The tree nodes\r\n * @property {number} root - The root index\r\n * @property {number} nodeCount - The number of nodes\r\n * @property {number} nodeCapacity - The allocated node space\r\n * @property {number} freeList - Node free list\r\n * @property {number} proxyCount - Number of proxies created\r\n * @property {number[]} leafIndices - Leaf indices for rebuild\r\n * @property {b2AABB[]} leafBoxes - Leaf bounding boxes for rebuild\r\n * @property {b2Vec2[]} leafCenters - Leaf bounding box centers for rebuild\r\n * @property {number[]} binIndices - Bins for sorting during rebuild\r\n * @property {number} rebuildCapacity - Allocated space for rebuilding\r\n */\r\nexport class b2DynamicTree\r\n{\r\n    constructor()\r\n    {\r\n        this.nodes = [];\r\n        this.root = 0;\r\n        this.nodeCount = 0;\r\n        this.nodeCapacity = 0;\r\n        this.freeList = B2_NULL_INDEX;\r\n        this.proxyCount = 0;\r\n        this.leafIndices = [];\r\n\r\n        // this.leafBoxes = [];\r\n        this.leafCenters = [];\r\n\r\n        // this.binIndices = [];\r\n        this.rebuildCapacity = 0;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nexport function b2IsPowerOf2(x)\r\n{\r\n    return (x & (x - 1)) === 0;\r\n}\r\n\r\nexport function b2BoundingPowerOf2(x)\r\n{\r\n    if (x <= 1)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    return 32 - Math.clz32(x - 1);\r\n}\r\n\r\nexport function b2RoundUpPowerOf2(x)\r\n{\r\n    if (x <= 1)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    return 1 << (32 - Math.clz32(x - 1));\r\n}\r\n\r\nexport function b2CTZ64(block)\r\n{\r\n    // 64; PJB closer to the _BitScanForward64 implementation\r\n    if (block === 0n)\r\n    {\r\n        return 0;\r\n    }\r\n    \r\n    const low32 = Number(block & 0xFFFFFFFFn);\r\n\r\n    if (low32 !== 0)\r\n    {\r\n        return Math.clz32(low32 & -low32) ^ 31;\r\n    }\r\n    else\r\n    {\r\n        const high32 = Number(block >> 32n);\r\n\r\n        return Math.clz32(high32 & -high32) ^ 31 | 32;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX, b2_graphColorCount } from './include/core_h.js';\r\nimport {\r\n    b2AddBodySim,\r\n    b2AddBodyState,\r\n    b2AddContact,\r\n    b2AddIsland,\r\n    b2AddJoint,\r\n    b2BodySimArray,\r\n    b2BodyStateArray,\r\n    b2ContactArray,\r\n    b2CreateBodySimArray,\r\n    b2CreateContactArray,\r\n    b2CreateJointArray,\r\n    b2IslandArray,\r\n    b2JointArray,\r\n    b2RemoveBodySim,\r\n    b2RemoveBodyState,\r\n    b2RemoveContact,\r\n    b2RemoveIsland,\r\n    b2RemoveJoint,\r\n} from './include/block_array_h.js';\r\nimport { b2AddContactToGraph, b2AddJointToGraph, b2RemoveJointFromGraph, b2_overflowIndex } from './include/constraint_graph_h.js';\r\nimport { b2AllocId, b2FreeId } from './include/id_pool_h.js';\r\nimport { b2ContactFlags, b2ContactSimFlags } from './include/contact_h.js';\r\nimport { b2SetType, b2ValidateSolverSets } from './include/world_h.js';\r\n\r\nimport { b2BodyState } from './include/body_h.js';\r\nimport { b2ClearBit } from './include/bitset_h.js';\r\n\r\n/**\r\n * @namespace SolverSet\r\n */\r\n\r\n/**\r\n * @import {b2World} from './include/world_h.js'\r\n */\r\n\r\n// This holds solver set data. The following sets are used:\r\n// - static set for all static bodies (no contacts or joints)\r\n// - active set for all active bodies with body states (no contacts or joints)\r\n// - disabled set for disabled bodies and their joints\r\n// - all further sets are sleeping island sets along with their contacts and joints\r\n// The purpose of solver sets is to achieve high memory locality.\r\n// https://www.youtube.com/watch?v=nZNd5FjSquk\r\nexport class b2SolverSet\r\n{\r\n    constructor()\r\n    {\r\n        // Body array. Empty for unused set.\r\n        this.sims = new b2BodySimArray();\r\n\r\n        // Body state only exists for active set\r\n        this.states = new b2BodyStateArray();\r\n\r\n        // This holds sleeping/disabled joints. Empty for static/active set.\r\n        this.joints = new b2JointArray();\r\n\r\n        // This holds all contacts for sleeping sets.\r\n        // This holds non-touching contacts for the awake set.\r\n        this.contacts = new b2ContactArray();\r\n\r\n        // The awake set has an array of islands. Sleeping sets normally have a single islands. However, joints\r\n        // created between sleeping sets causes the sets to merge, leaving them with multiple islands. These sleeping\r\n        // islands will be naturally merged with the set is woken.\r\n        // The static and disabled sets have no islands.\r\n        // Islands live in the solver sets to limit the number of islands that need to be considered for sleeping.\r\n        this.islands = new b2IslandArray();\r\n\r\n        // Aligns with b2World::solverSetIdPool. Used to create a stable id for body/contact/joint/islands.\r\n        this.setIndex = 0;\r\n        \r\n    }\r\n}\r\n\r\nexport function b2DestroySolverSet(world, setIndex)\r\n{\r\n    console.assert(setIndex >= 0);\r\n    let set = world.solverSetArray[setIndex];\r\n    set.sims = null;\r\n    set.states = null;\r\n    set.contacts = null;\r\n    set.joints = null;\r\n    set.islands = null;\r\n    b2FreeId(world.solverSetIdPool, setIndex);\r\n    set = new b2SolverSet();\r\n    set.setIndex = B2_NULL_INDEX;\r\n    world.solverSetArray[setIndex] = set;\r\n}\r\n\r\n/**\r\n * @param {b2World} world\r\n * @param {number} setIndex\r\n */\r\nexport function b2WakeSolverSet(world, setIndex)\r\n{\r\n    console.assert(setIndex >= b2SetType.b2_firstSleepingSet);\r\n\r\n    // b2CheckIndex(world.solverSetArray, setIndex);\r\n    const set = world.solverSetArray[setIndex];\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const disabledSet = world.solverSetArray[b2SetType.b2_disabledSet];\r\n\r\n    const bodies = world.bodyArray;\r\n    const contacts = world.contactArray;\r\n\r\n    const bodyCount = set.sims.count;\r\n\r\n    for (let i = 0; i < bodyCount; ++i)\r\n    {\r\n        const simSrc = set.sims.data[i];\r\n\r\n        const body = bodies[simSrc.bodyId];\r\n        console.assert(body.setIndex === setIndex);\r\n        body.setIndex = b2SetType.b2_awakeSet;\r\n        body.localIndex = awakeSet.sims.count;\r\n\r\n        body.sleepTime = 0.0;\r\n\r\n        const simDst = b2AddBodySim(awakeSet.sims);\r\n        Object.assign(simDst, simSrc);\r\n\r\n        const state = b2AddBodyState(awakeSet.states);\r\n        Object.assign(state, new b2BodyState());\r\n\r\n        // move non-touching contacts from disabled set to awake set\r\n        let contactKey = body.headContactKey;\r\n\r\n        while (contactKey !== B2_NULL_INDEX)\r\n        {\r\n            const edgeIndex = contactKey & 1;\r\n            const contactId = contactKey >> 1;\r\n\r\n            // b2CheckIndex(contacts, contactId);\r\n            const contact = contacts[contactId];\r\n\r\n            contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n            if (contact.setIndex !== b2SetType.b2_disabledSet)\r\n            {\r\n                console.assert(contact.setIndex === b2SetType.b2_awakeSet || contact.setIndex === setIndex);\r\n\r\n                continue;\r\n            }\r\n\r\n            const localIndex = contact.localIndex;\r\n            console.assert(0 <= localIndex && localIndex < disabledSet.contacts.count);\r\n            const contactSim = disabledSet.contacts.data[localIndex];\r\n\r\n            console.assert((contact.flags & b2ContactFlags.b2_contactTouchingFlag) === 0 && contactSim.manifold.pointCount === 0);\r\n\r\n            contact.setIndex = b2SetType.b2_awakeSet;\r\n            contact.localIndex = awakeSet.contacts.count;\r\n            const awakeContactSim = b2AddContact(awakeSet.contacts);\r\n            awakeContactSim.set(contactSim);\r\n\r\n            const movedLocalIndex = b2RemoveContact(disabledSet.contacts, localIndex);\r\n\r\n            if (movedLocalIndex !== B2_NULL_INDEX)\r\n            {\r\n                const movedContact = disabledSet.contacts.data[localIndex];\r\n                const movedId = movedContact.contactId;\r\n\r\n                // b2CheckIndex(contacts, movedId);\r\n                console.assert(contacts[movedId].localIndex === movedLocalIndex);\r\n                contacts[movedId].localIndex = localIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    const contactCount = set.contacts.count;\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const contactSim = set.contacts.data[i];\r\n        const contact = contacts[contactSim.contactId];\r\n        console.assert(!!(contact.flags & b2ContactFlags.b2_contactTouchingFlag));\r\n        console.assert(!!(contactSim.simFlags & b2ContactSimFlags.b2_simTouchingFlag));\r\n        console.assert(contactSim.manifold.pointCount > 0);\r\n        console.assert(contact.setIndex === setIndex);\r\n        b2AddContactToGraph(world, contactSim, contact);\r\n        contact.setIndex = b2SetType.b2_awakeSet;\r\n    }\r\n\r\n    const joints = world.jointArray;\r\n    const jointCount = set.joints.count;\r\n\r\n    for (let i = 0; i < jointCount; ++i)\r\n    {\r\n        const jointSim = set.joints.data[i];\r\n        const joint = joints[jointSim.jointId];\r\n        console.assert(joint.setIndex === setIndex);\r\n        b2AddJointToGraph(world, jointSim, joint);\r\n        joint.setIndex = b2SetType.b2_awakeSet;\r\n    }\r\n\r\n    const islands = world.islandArray;\r\n    const islandCount = set.islands.count;\r\n\r\n    for (let i = 0; i < islandCount; ++i)\r\n    {\r\n        const islandSrc = set.islands.data[i];\r\n\r\n        // b2CheckIndex(islands, islandSrc.islandId);\r\n        const island = islands[islandSrc.islandId];\r\n        island.setIndex = b2SetType.b2_awakeSet;\r\n        island.localIndex = awakeSet.islands.count;\r\n        const islandDst = b2AddIsland(awakeSet.islands);\r\n        Object.assign(islandDst, islandSrc);\r\n    }\r\n\r\n    b2DestroySolverSet(world, setIndex);\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\nexport function b2TrySleepIsland(world, islandId)\r\n{\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n    console.assert(island.setIndex === b2SetType.b2_awakeSet, `b2TrySleepIsland island.setIndex is not awakeSet: ${island.setIndex}`);\r\n\r\n    if (island.constraintRemoveCount > 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const moveEvents = world.bodyMoveEventArray;\r\n\r\n    const sleepSetId = b2AllocId(world.solverSetIdPool);\r\n\r\n    if (sleepSetId === world.solverSetArray.length)\r\n    {\r\n        const set = new b2SolverSet();\r\n        set.setIndex = B2_NULL_INDEX;\r\n        world.solverSetArray.push(set);\r\n    }\r\n\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    console.assert(0 <= island.localIndex && island.localIndex < awakeSet.islands.count);\r\n\r\n    const sleepSet = world.solverSetArray[sleepSetId];\r\n    sleepSet.setIndex = sleepSetId;\r\n    sleepSet.sims = b2CreateBodySimArray(island.bodyCount);\r\n    sleepSet.contacts = b2CreateContactArray(island.contactCount);\r\n    sleepSet.joints = b2CreateJointArray(island.jointCount);\r\n\r\n    const disabledSet = world.solverSetArray[b2SetType.b2_disabledSet];\r\n    const bodies = world.bodyArray;\r\n    const contacts = world.contactArray;\r\n    let bodyId = island.headBody;\r\n\r\n    // (\"headBody \" + island.headBody + \" tailBody \" + island.tailBody + \" bodyCount \" + island.bodyCount);\r\n    while (bodyId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(bodies, bodyId);\r\n        const body = bodies[bodyId];\r\n        console.assert(body.setIndex === b2SetType.b2_awakeSet);\r\n        console.assert(body.islandId === islandId);\r\n\r\n        if (body.bodyMoveIndex !== B2_NULL_INDEX)\r\n        {\r\n            // b2CheckIndex(moveEvents, body.bodyMoveIndex);\r\n            console.assert(moveEvents[body.bodyMoveIndex].bodyId.index1 - 1 === bodyId);\r\n            console.assert(moveEvents[body.bodyMoveIndex].bodyId.revision === body.revision);\r\n            moveEvents[body.bodyMoveIndex].fellAsleep = true;\r\n            body.bodyMoveIndex = B2_NULL_INDEX;\r\n        }\r\n\r\n        const awakeBodyIndex = body.localIndex;\r\n        console.assert(0 <= awakeBodyIndex && awakeBodyIndex < awakeSet.sims.count);\r\n\r\n        const awakeSim = awakeSet.sims.data[awakeBodyIndex];\r\n\r\n        const sleepBodyIndex = sleepSet.sims.count;\r\n        const sleepBodySim = b2AddBodySim(sleepSet.sims);\r\n        awakeSim.copyTo(sleepBodySim);\r\n\r\n        // Object.assign(sleepBodySim, awakeSim);\r\n\r\n        // console.warn(\"b \" + (world.solverSetArray[2].sims.data[0].transform != null));\r\n\r\n        const movedIndex = b2RemoveBodySim(awakeSet.sims, awakeBodyIndex);\r\n\r\n        // console.warn(\"movedIndex \" + movedIndex);\r\n\r\n        // console.warn(\"b2 \" + (world.solverSetArray[2].sims.data[0].transform != null));\r\n        console.assert(world.solverSetArray[2].sims.data[0].transform != null, \"1 transform is null\");\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            const movedSim = awakeSet.sims.data[awakeBodyIndex];\r\n            const movedId = movedSim.bodyId;\r\n\r\n            // b2CheckIndex(bodies, movedId);\r\n            const movedBody = bodies[movedId];\r\n            console.assert(movedBody.localIndex === movedIndex);\r\n            movedBody.localIndex = awakeBodyIndex;\r\n        }\r\n\r\n        b2RemoveBodyState(awakeSet.states, awakeBodyIndex);\r\n\r\n        body.setIndex = sleepSetId;\r\n        body.localIndex = sleepBodyIndex;\r\n\r\n        let contactKey = body.headContactKey;\r\n\r\n        while (contactKey !== B2_NULL_INDEX)\r\n        {\r\n            const contactId = contactKey >> 1;\r\n            const edgeIndex = contactKey & 1;\r\n\r\n            // b2CheckIndex(contacts, contactId);\r\n            const contact = contacts[contactId];\r\n\r\n            console.assert(contact.setIndex === b2SetType.b2_awakeSet || contact.setIndex === b2SetType.b2_disabledSet);\r\n            contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n            if (contact.setIndex === b2SetType.b2_disabledSet)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (contact.colorIndex !== B2_NULL_INDEX)\r\n            {\r\n                console.assert((contact.flags & b2ContactFlags.b2_contactTouchingFlag) !== 0);\r\n\r\n                continue;\r\n            }\r\n\r\n            const otherEdgeIndex = edgeIndex ^ 1;\r\n            const otherBodyId = contact.edges[otherEdgeIndex].bodyId;\r\n\r\n            // b2CheckIndex(bodies, otherBodyId);\r\n            const otherBody = bodies[otherBodyId];\r\n\r\n            if (otherBody.setIndex === b2SetType.b2_awakeSet)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const localIndex = contact.localIndex;\r\n            console.assert(0 <= localIndex && localIndex < awakeSet.contacts.count);\r\n            const contactSim = awakeSet.contacts.data[localIndex];\r\n\r\n            console.assert(contactSim.manifold.pointCount === 0);\r\n            console.assert((contact.flags & b2ContactFlags.b2_contactTouchingFlag) === 0 || (contact.flags & b2ContactFlags.b2_contactSensorFlag) !== 0);\r\n\r\n            contact.setIndex = b2SetType.b2_disabledSet;\r\n            contact.localIndex = disabledSet.contacts.count;\r\n            const disabledContactSim = b2AddContact(disabledSet.contacts);\r\n            disabledContactSim.set(contactSim);\r\n\r\n            const movedContactIndex = b2RemoveContact(awakeSet.contacts, localIndex);\r\n\r\n            if (movedContactIndex !== B2_NULL_INDEX)\r\n            {\r\n                const movedContactSim = awakeSet.contacts.data[localIndex];\r\n                const movedId = movedContactSim.contactId;\r\n\r\n                // b2CheckIndex(contacts, movedId);\r\n                console.assert(contacts[movedId].localIndex === movedContactIndex);\r\n                contacts[movedId].localIndex = localIndex;\r\n            }\r\n        }\r\n\r\n        bodyId = body.islandNext;\r\n    }\r\n\r\n    let contactId = island.headContact;\r\n\r\n    while (contactId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(contacts, contactId);\r\n        const contact = contacts[contactId];\r\n        console.assert(contact.setIndex === b2SetType.b2_awakeSet);\r\n        console.assert(contact.islandId === islandId);\r\n        const colorIndex = contact.colorIndex;\r\n        console.assert(0 <= colorIndex && colorIndex < b2_graphColorCount);\r\n\r\n        const color = world.constraintGraph.colors[colorIndex];\r\n\r\n        if (colorIndex !== b2_overflowIndex)\r\n        {\r\n            b2ClearBit(color.bodySet, contact.edges[0].bodyId);\r\n            b2ClearBit(color.bodySet, contact.edges[1].bodyId);\r\n        }\r\n\r\n        const awakeContactIndex = contact.localIndex;\r\n        console.assert(0 <= awakeContactIndex && awakeContactIndex < color.contacts.count);\r\n        const awakeContactSim = color.contacts.data[awakeContactIndex];\r\n\r\n        const sleepContactIndex = sleepSet.contacts.count;\r\n        const sleepContactSim = b2AddContact(sleepSet.contacts);\r\n        sleepContactSim.set(awakeContactSim);\r\n\r\n        const movedIndex = b2RemoveContact(color.contacts, awakeContactIndex);\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            const movedContactSim = color.contacts.data[awakeContactIndex];\r\n            const movedId = movedContactSim.contactId;\r\n\r\n            // b2CheckIndex(contacts, movedId);\r\n            const movedContact = contacts[movedId];\r\n            console.assert(movedContact.localIndex === movedIndex);\r\n            movedContact.localIndex = awakeContactIndex;\r\n        }\r\n\r\n        contact.setIndex = sleepSetId;\r\n        contact.colorIndex = B2_NULL_INDEX;\r\n        contact.localIndex = sleepContactIndex;\r\n\r\n        contactId = contact.islandNext;\r\n    }\r\n\r\n    const joints = world.jointArray;\r\n    let jointId = island.headJoint;\r\n\r\n    while (jointId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(joints, jointId);\r\n        const joint = joints[jointId];\r\n        console.assert(joint.setIndex === b2SetType.b2_awakeSet);\r\n        console.assert(joint.islandId === islandId);\r\n        const colorIndex = joint.colorIndex;\r\n        const localIndex = joint.localIndex;\r\n\r\n        console.assert(0 <= colorIndex && colorIndex < b2_graphColorCount);\r\n\r\n        const color = world.constraintGraph.colors[colorIndex];\r\n\r\n        console.assert(0 <= localIndex && localIndex < color.joints.count);\r\n        const awakeJointSim = color.joints.data[localIndex];\r\n\r\n        if (colorIndex !== b2_overflowIndex)\r\n        {\r\n            b2ClearBit(color.bodySet, joint.edges[0].bodyId);\r\n            b2ClearBit(color.bodySet, joint.edges[1].bodyId);\r\n        }\r\n\r\n        const sleepJointIndex = sleepSet.joints.count;\r\n        const sleepJointSim = b2AddJoint(sleepSet.joints);\r\n        awakeJointSim.copyTo(sleepJointSim);\r\n\r\n        const movedIndex = b2RemoveJoint(color.joints, localIndex);\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            const movedJointSim = color.joints.data[localIndex];\r\n            const movedId = movedJointSim.jointId;\r\n\r\n            // b2CheckIndex(joints, movedId);\r\n            const movedJoint = joints[movedId];\r\n            console.assert(movedJoint.localIndex === movedIndex);\r\n            movedJoint.localIndex = localIndex;\r\n        }\r\n\r\n        joint.setIndex = sleepSetId;\r\n        joint.colorIndex = B2_NULL_INDEX;\r\n        joint.localIndex = sleepJointIndex;\r\n\r\n        jointId = joint.islandNext;\r\n    }\r\n\r\n    console.assert(island.setIndex === b2SetType.b2_awakeSet);\r\n\r\n    const islandIndex = island.localIndex;\r\n    const sleepIsland = b2AddIsland(sleepSet.islands);\r\n    sleepIsland.islandId = islandId;\r\n\r\n    const movedIslandIndex = b2RemoveIsland(awakeSet.islands, islandIndex);\r\n\r\n    if (movedIslandIndex !== B2_NULL_INDEX)\r\n    {\r\n        const movedIslandSim = awakeSet.islands.data[islandIndex];\r\n        const movedIslandId = movedIslandSim.islandId;\r\n\r\n        // b2CheckIndex(world.islandArray, movedIslandId);\r\n        const movedIsland = world.islandArray[movedIslandId];\r\n        console.assert(movedIsland.localIndex === movedIslandIndex);\r\n        movedIsland.localIndex = islandIndex;\r\n    }\r\n\r\n    island.setIndex = sleepSetId;\r\n    island.localIndex = 0;\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\nexport function b2MergeSolverSets(world, setId1, setId2)\r\n{\r\n    console.assert(setId1 >= b2SetType.b2_firstSleepingSet);\r\n    console.assert(setId2 >= b2SetType.b2_firstSleepingSet);\r\n\r\n    // b2CheckIndex(world.solverSetArray, setId1);\r\n    // b2CheckIndex(world.solverSetArray, setId2);\r\n    let set1 = world.solverSetArray[setId1];\r\n    let set2 = world.solverSetArray[setId2];\r\n\r\n    if (set1.sims.count < set2.sims.count)\r\n    {\r\n        [ set1, set2 ] = [ set2, set1 ];\r\n        [ setId1, setId2 ] = [ setId2, setId1 ];\r\n    }\r\n\r\n    const bodies = world.bodyArray;\r\n    const bodyCount = set2.sims.count;\r\n\r\n    for (let i = 0; i < bodyCount; ++i)\r\n    {\r\n        const simSrc = set2.sims.data[i];\r\n\r\n        const body = bodies[simSrc.bodyId];\r\n        console.assert(body.setIndex === setId2);\r\n        body.setIndex = setId1;\r\n        body.localIndex = set1.sims.count;\r\n\r\n        const simDst = b2AddBodySim(set1.sims);\r\n        Object.assign(simDst, simSrc);\r\n    }\r\n\r\n    const contacts = world.contactArray;\r\n    const contactCount = set2.contacts.count;\r\n\r\n    for (let i = 0; i < contactCount; ++i)\r\n    {\r\n        const contactSrc = set2.contacts.data[i];\r\n\r\n        const contact = contacts[contactSrc.contactId];\r\n        console.assert(contact.setIndex === setId2);\r\n        contact.setIndex = setId1;\r\n        contact.localIndex = set1.contacts.count;\r\n\r\n        const contactDst = b2AddContact(set1.contacts);\r\n        contactDst.set(contactSrc);\r\n    }\r\n\r\n    const joints = world.jointArray;\r\n    const jointCount = set2.joints.count;\r\n\r\n    for (let i = 0; i < jointCount; ++i)\r\n    {\r\n        const jointSrc = set2.joints.data[i];\r\n\r\n        const joint = joints[jointSrc.jointId];\r\n        console.assert(joint.setIndex === setId2);\r\n        joint.setIndex = setId1;\r\n        joint.localIndex = set1.joints.count;\r\n\r\n        const jointDst = b2AddJoint(set1.joints);\r\n        Object.assign(jointDst, jointSrc);\r\n    }\r\n\r\n    const islands = world.islandArray;\r\n    const islandCount = set2.islands.count;\r\n\r\n    for (let i = 0; i < islandCount; ++i)\r\n    {\r\n        const islandSrc = set2.islands.data[i];\r\n        const islandId = islandSrc.islandId;\r\n\r\n        // b2CheckIndex(islands, islandId);\r\n        const island = islands[islandId];\r\n        island.setIndex = setId1;\r\n        island.localIndex = set1.islands.count;\r\n\r\n        const islandDst = b2AddIsland(set1.islands);\r\n        Object.assign(islandDst, islandSrc);\r\n    }\r\n\r\n    b2DestroySolverSet(world, setId2);\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\nexport function b2TransferBody(world, targetSet, sourceSet, body)\r\n{\r\n    console.assert(targetSet !== sourceSet);\r\n\r\n    const sourceIndex = body.localIndex;\r\n    console.assert(0 <= sourceIndex && sourceIndex <= sourceSet.sims.count);\r\n    const sourceSim = sourceSet.sims.data[sourceIndex];\r\n\r\n    const targetIndex = targetSet.sims.count;\r\n    const targetSim = b2AddBodySim(targetSet.sims);\r\n    Object.assign(targetSim, sourceSim);\r\n\r\n    const movedIndex = b2RemoveBodySim(sourceSet.sims, sourceIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        const movedSim = sourceSet.sims.data[sourceIndex];\r\n        const movedId = movedSim.bodyId;\r\n        const movedBody = world.bodyArray[movedId];\r\n        console.assert(movedBody.localIndex === movedIndex);\r\n        movedBody.localIndex = sourceIndex;\r\n    }\r\n\r\n    if (sourceSet.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        b2RemoveBodyState(sourceSet.states, sourceIndex);\r\n    }\r\n    else if (targetSet.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const state = b2AddBodyState(targetSet.states);\r\n        Object.assign(state, new b2BodyState());\r\n    }\r\n\r\n    body.setIndex = targetSet.setIndex;\r\n    body.localIndex = targetIndex;\r\n}\r\n\r\nexport function b2TransferJoint(world, targetSet, sourceSet, joint)\r\n{\r\n    console.assert(targetSet !== sourceSet);\r\n\r\n    const localIndex = joint.localIndex;\r\n    const colorIndex = joint.colorIndex;\r\n\r\n    let sourceSim;\r\n\r\n    if (sourceSet.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        console.assert(0 <= colorIndex && colorIndex < b2_graphColorCount);\r\n        const color = world.constraintGraph.colors[colorIndex];\r\n\r\n        console.assert(0 <= localIndex && localIndex < color.joints.count);\r\n        sourceSim = color.joints.data[localIndex];\r\n    }\r\n    else\r\n    {\r\n        console.assert(colorIndex === B2_NULL_INDEX);\r\n        console.assert(0 <= localIndex && localIndex < sourceSet.joints.count);\r\n        sourceSim = sourceSet.joints.data[localIndex];\r\n    }\r\n\r\n    if (targetSet.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        b2AddJointToGraph(world, sourceSim, joint);\r\n        joint.setIndex = b2SetType.b2_awakeSet;\r\n    }\r\n    else\r\n    {\r\n        joint.setIndex = targetSet.setIndex;\r\n        joint.localIndex = targetSet.joints.count;\r\n        joint.colorIndex = B2_NULL_INDEX;\r\n\r\n        const targetSim = b2AddJoint(targetSet.joints);\r\n        Object.assign(targetSim, sourceSim);\r\n    }\r\n\r\n    if (sourceSet.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        b2RemoveJointFromGraph(world, joint.edges[0].bodyId, joint.edges[1].bodyId, colorIndex, localIndex);\r\n    }\r\n    else\r\n    {\r\n        const movedIndex = b2RemoveJoint(sourceSet.joints, localIndex);\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            const movedJointSim = sourceSet.joints.data[localIndex];\r\n            const movedId = movedJointSim.jointId;\r\n\r\n            // b2CheckIndex(world.jointArray, movedId);\r\n            const movedJoint = world.jointArray[movedId];\r\n            movedJoint.localIndex = localIndex;\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport * as bitset_h from './include/bitset_h.js';\r\nimport * as body_h from './include/body_h.js';\r\nimport * as constraint_graph_h from './include/constraint_graph_h.js';\r\nimport * as contact_solver_h from './include/contact_solver_h.js';\r\nimport * as core_h from './include/core_h.js';\r\nimport * as joint_h from './include/joint_h.js';\r\nimport * as shape_h from './include/shape_h.js';\r\n\r\nimport { B2_DEFAULT_MASK_BITS, b2Manifold, b2Sweep, b2TOIInput } from './include/collision_h.js';\r\nimport { B2_NULL_INDEX, b2_graphColorCount } from './include/core_h.js';\r\nimport {\r\n    B2_PI,\r\n    b2AABB,\r\n    b2AABB_Contains,\r\n    b2AABB_Union,\r\n    b2IntegrateRotationOut,\r\n    b2InvMagRot,\r\n    b2IsValid,\r\n    b2Length,\r\n    b2Lerp,\r\n    b2MulRotC,\r\n    b2MulRotS,\r\n    b2NLerp,\r\n    b2Rot,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2TransformPointOut,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\nimport { B2_PROXY_ID, B2_PROXY_TYPE, b2BroadPhase_EnlargeProxy, b2BufferMove } from './include/broad_phase_h.js';\r\nimport { b2AllocateStackItem, b2FreeStackItem } from './include/stack_allocator_h.js';\r\nimport { b2BodyId, b2ShapeId } from './include/id_h.js';\r\nimport { b2BodyMoveEvent, b2BodyType, b2ContactHitEvent, b2ShapeType } from './include/types_h.js';\r\nimport { b2ContactSimFlags, b2ShouldShapesCollide } from './include/contact_h.js';\r\nimport { b2DynamicTree_EnlargeProxy, b2DynamicTree_Query } from './include/dynamic_tree_h.js';\r\nimport { b2GetSweepTransform, b2MakeProxy, b2TimeOfImpact } from './include/distance_h.js';\r\nimport { b2MergeAwakeIslands, b2SplitIsland } from './include/island_h.js';\r\nimport { b2SetType, b2ValidateSolverSets, b2_maxWorkers } from './include/world_h.js';\r\n\r\nimport { b2CTZ64 } from './include/ctz_h.js';\r\nimport { b2ComputeManifold } from './contact_c.js';\r\nimport { b2TrySleepIsland } from './include/solver_set_h.js';\r\n\r\n/**\r\n * @namespace Solver\r\n */\r\n\r\nexport const b2SolverStageType = {\r\n    b2_stagePrepareJoints: 0,\r\n    b2_stagePrepareContacts: 1,\r\n    b2_stageIntegrateVelocities: 2,\r\n    b2_stageWarmStart: 3,\r\n    b2_stageSolve: 4,\r\n    b2_stageIntegratePositions: 5,\r\n    b2_stageRelax: 6,\r\n    b2_stageRestitution: 7,\r\n    b2_stageStoreImpulses: 8\r\n};\r\n\r\nexport const b2SolverBlockType = {\r\n    b2_bodyBlock: 0,\r\n    b2_jointBlock: 1,\r\n    b2_contactBlock: 2,\r\n    b2_graphJointBlock: 3,\r\n    b2_graphContactBlock: 4\r\n};\r\n\r\nexport class b2SolverBlock\r\n{\r\n    constructor()\r\n    {\r\n        this.startIndex = 0;\r\n        this.count = 0;\r\n        this.blockType = 0;\r\n        this.syncIndex = 0;\r\n        \r\n    }\r\n}\r\n\r\nexport class b2SolverStage\r\n{\r\n    constructor()\r\n    {\r\n        this.type = 0;\r\n        this.blocks = null;\r\n        this.blockCount = 0;\r\n        this.colorIndex = 0;\r\n        this.completionCount = 0;\r\n        \r\n    }\r\n}\r\n\r\nexport class b2WorkerContext\r\n{\r\n    constructor()\r\n    {\r\n        this.context = new b2StepContext();\r\n        this.workerIndex = 0;\r\n        this.userTask = null;\r\n        \r\n    }\r\n}\r\n\r\nexport class b2Softness\r\n{\r\n    constructor(biasRate = 0, massScale = 0, impulseScale = 0)\r\n    {\r\n        this.biasRate = biasRate;\r\n        this.massScale = massScale;\r\n        this.impulseScale = impulseScale;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        return new b2Softness(this.biasRate, this.massScale, this.impulseScale);\r\n    }\r\n}\r\n\r\nexport class b2StepContext\r\n{\r\n    constructor()\r\n    {\r\n        this.dt = 0;\r\n        this.inv_dt = 0;\r\n        this.h = 0;\r\n        this.inv_h = 0;\r\n        this.subStepCount = 0;\r\n        this.jointSoftness = new b2Softness(0, 0, 0);\r\n        this.contactSoftness = new b2Softness(0, 0, 0);\r\n        this.staticSoftness = new b2Softness(0, 0, 0);\r\n        this.restitutionThreshold = 0;\r\n        this.maxLinearVelocity = 0;\r\n        this.world = null;\r\n        this.graph = null;\r\n        this.states = null;\r\n        this.sims = null;\r\n        this.enlargedShapes = null;\r\n        this.enlargedShapeCount = 0;\r\n        this.fastBodies = null;\r\n        this.fastBodyCount = 0;\r\n        this.bulletBodies = null;\r\n        this.bulletBodyCount = 0;\r\n        this.joints = null;\r\n        this.contacts = null;\r\n        this.simdContactConstraints = null;\r\n        this.activeColorCount = 0;\r\n        this.workerCount = 0;\r\n        this.stages = null;\r\n        this.stageCount = 0;\r\n        this.enableWarmStarting = false;\r\n        this.atomicSyncBits = 0;\r\n        \r\n    }\r\n}\r\n\r\nexport function b2MakeSoft(hertz, zeta, h)\r\n{\r\n    if (hertz === 0.0)\r\n    {\r\n        return new b2Softness(0.0, 1.0, 0.0);\r\n    }\r\n\r\n    const omega = 2.0 * B2_PI * hertz;\r\n    const a1 = 2.0 * zeta + h * omega;\r\n    const a2 = h * omega * a1;\r\n    const a3 = 1.0 / (1.0 + a2);\r\n\r\n    return new b2Softness(omega / a1, a2 * a3, a3);\r\n}\r\n\r\n\r\n// Integrate velocities and apply damping\r\nfunction b2IntegrateVelocitiesTask(startIndex, endIndex, context)\r\n{\r\n    const states = context.states;\r\n    const sims = context.sims;\r\n\r\n    const gravity = context.world.gravity;\r\n    const h = context.h;\r\n    const maxLinearSpeed = context.maxLinearVelocity;\r\n    const maxAngularSpeed = core_h.B2_MAX_ROTATION * context.inv_dt;\r\n    const maxLinearSpeedSquared = maxLinearSpeed * maxLinearSpeed;\r\n    const maxAngularSpeedSquared = maxAngularSpeed * maxAngularSpeed;\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const sim = sims[i];\r\n        const state = states[i];\r\n\r\n        const v = state.linearVelocity;   // .clone();\r\n        let w = state.angularVelocity;\r\n\r\n        // Apply forces, torque, gravity, and damping\r\n        // Apply damping.\r\n        // Differential equation: dv/dt + c * v = 0\r\n        // Solution: v(t) = v0 * exp(-c * t)\r\n        // Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v(t) * exp(-c * dt)\r\n        // v2 = exp(-c * dt) * v1\r\n        // Pade approximation:\r\n        // v2 = v1 * 1 / (1 + c * dt)\r\n        const linearDamping = 1.0 / (1.0 + h * sim.linearDamping);\r\n        const angularDamping = 1.0 / (1.0 + h * sim.angularDamping);\r\n\r\n        // const linearVelocityDelta = b2MulSV(h * sim.invMass, b2MulAdd(sim.force, sim.mass * sim.gravityScale, gravity));\r\n        const m = sim.mass * sim.gravityScale;\r\n        const im = h * sim.invMass;\r\n        const lvdX = im * (sim.force.x + m * gravity.x);\r\n        const lvdY = im * (sim.force.y + m * gravity.y);\r\n        const angularVelocityDelta = h * sim.invInertia * sim.torque;\r\n\r\n        // v = b2MulAdd(linearVelocityDelta, linearDamping, v);\r\n        v.x = lvdX + linearDamping * v.x;\r\n        v.y = lvdY + linearDamping * v.y;\r\n        w = angularVelocityDelta + angularDamping * w;\r\n\r\n        // Clamp to max linear speed\r\n        // b2Dot(v, v)\r\n        const l = v.x * v.x + v.y * v.y;\r\n\r\n        if (l > maxLinearSpeedSquared)\r\n        {\r\n            const ratio = maxLinearSpeed / Math.sqrt(l);    // b2Length(v);\r\n            // v = b2MulSV(ratio, v);\r\n            v.x *= ratio;\r\n            v.y *= ratio;\r\n            sim.isSpeedCapped = true;\r\n        }\r\n\r\n        // Clamp to max angular speed\r\n        if (w * w > maxAngularSpeedSquared && sim.allowFastRotation === false)\r\n        {\r\n            const ratio = maxAngularSpeed / Math.abs(w);\r\n            w *= ratio;\r\n            sim.isSpeedCapped = true;\r\n        }\r\n\r\n        state.linearVelocity = v;\r\n        state.angularVelocity = w;\r\n    }\r\n}\r\n\r\n//  PJB: 19/11/2024 another unused function (SIMD related?)\r\n\r\n/**\r\nfunction b2PrepareJointsTask(startIndex, endIndex, context)\r\n{\r\n    const joints = context.joints;\r\n\r\n    for (let i = startIndex; i < endIndex; ++i) {\r\n        const joint = joints[i];\r\n        joint_h.b2PrepareJoint(joint, context);\r\n    }\r\n}\r\n*/\r\n\r\nfunction b2IntegratePositionsTask(startIndex, endIndex, context)\r\n{\r\n    const states = context.states;\r\n    const h = context.h;\r\n\r\n    console.assert(startIndex <= endIndex);\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const state = states[i];\r\n\r\n        // state.deltaRotation = b2IntegrateRotation(state.deltaRotation, h * state.angularVelocity);\r\n        b2IntegrateRotationOut(state.deltaRotation, h * state.angularVelocity, state.deltaRotation);\r\n\r\n        // state.deltaPosition = b2MulAdd(state.deltaPosition, h, state.linearVelocity);\r\n        state.deltaPosition.x = state.deltaPosition.x + h * state.linearVelocity.x;\r\n        state.deltaPosition.y = state.deltaPosition.y + h * state.linearVelocity.y;\r\n        console.assert(state.deltaPosition != null);\r\n    }\r\n}\r\n\r\nfunction b2FinalizeBodiesTask(startIndex, endIndex, threadIndex, context)\r\n{\r\n    const stepContext = context;\r\n    const world = stepContext.world;\r\n    const enableSleep = world.enableSleep;\r\n    const states = stepContext.states;\r\n    const sims = stepContext.sims;\r\n    const bodies = world.bodyArray;\r\n    const timeStep = stepContext.dt;\r\n    const invTimeStep = stepContext.inv_dt;\r\n\r\n    const worldId = world.worldId;\r\n    const moveEvents = world.bodyMoveEventArray;\r\n\r\n    const islands = world.islandArray;\r\n\r\n    const enlargedSimBitSet = world.taskContextArray[threadIndex].enlargedSimBitSet;\r\n    const awakeIslandBitSet = world.taskContextArray[threadIndex].awakeIslandBitSet;\r\n    const taskContext = world.taskContextArray[threadIndex];\r\n\r\n    const enableContinuous = world.enableContinuous;\r\n\r\n    const speculativeDistance = core_h.b2_speculativeDistance;\r\n    const aabbMargin = core_h.b2_aabbMargin;\r\n\r\n    console.assert(startIndex <= endIndex);\r\n\r\n    for (let simIndex = startIndex; simIndex < endIndex; ++simIndex)\r\n    {\r\n        const state = states[simIndex];\r\n        const sim = sims[simIndex];\r\n\r\n        const v = state.linearVelocity;\r\n        const w = state.angularVelocity;\r\n\r\n        console.assert(b2IsValid(v.x) && b2IsValid(v.y));\r\n        console.assert(Number.isFinite(w));\r\n        sim.center.x += state.deltaPosition.x;\r\n        sim.center.y += state.deltaPosition.y;\r\n\r\n        const c = b2MulRotC(state.deltaRotation, sim.transform.q);\r\n        const s = b2MulRotS(state.deltaRotation, sim.transform.q);\r\n        const im = b2InvMagRot(c, s);\r\n\r\n        // sim.transform.q.c = im * c; //b2NormalizeRot(b2MulRot(state.deltaRotation, sim.transform.q));\r\n        // sim.transform.q.s = im * s;\r\n        sim.transform.q = new b2Rot(im * c, im * s);        // PJB: REQUIRES a new b2Rot here to prevent breaking tests e.g. \"drive\"\r\n\r\n        const maxVelocity = b2Length(v) + Math.abs(w) * sim.maxExtent;\r\n\r\n        const maxDeltaPosition = b2Length(state.deltaPosition) + Math.abs(state.deltaRotation.s) * sim.maxExtent;\r\n\r\n        const positionSleepFactor = 0.5;\r\n\r\n        const sleepVelocity = Math.max(maxVelocity, positionSleepFactor * invTimeStep * maxDeltaPosition);\r\n\r\n        state.deltaPosition.x = 0;  // new b2Vec2(0, 0);\r\n        state.deltaPosition.y = 0;\r\n        state.deltaRotation.c = 1;  // new b2Rot(1, 0);\r\n        state.deltaRotation.s = 0;\r\n\r\n        sim.transform.p.x = sim.center.x - (sim.transform.q.c * sim.localCenter.x - sim.transform.q.s * sim.localCenter.y);  // b2Sub(sim.center, b2RotateVector(sim.transform.q, sim.localCenter));\r\n        sim.transform.p.y = sim.center.y - (sim.transform.q.s * sim.localCenter.x + sim.transform.q.c * sim.localCenter.y);\r\n\r\n        const body = bodies[sim.bodyId];\r\n        body.bodyMoveIndex = simIndex;\r\n        moveEvents[simIndex].transform = sim.transform;\r\n        moveEvents[simIndex].bodyId = new b2BodyId(sim.bodyId + 1, worldId, body.revision);   // { id: sim.bodyId + 1, worldId: worldId, revision: body.revision };\r\n        moveEvents[simIndex].userData = body.userData;\r\n        moveEvents[simIndex].fellAsleep = false;\r\n\r\n        sim.force.x = 0;    // new b2Vec2(0, 0);\r\n        sim.force.y = 0;\r\n        sim.torque = 0.0;\r\n\r\n        body.isSpeedCapped = sim.isSpeedCapped;\r\n        sim.isSpeedCapped = false;\r\n\r\n        sim.isFast = false;\r\n\r\n        if (enableSleep === false || body.enableSleep === false || sleepVelocity > body.sleepThreshold)\r\n        {\r\n            body.sleepTime = 0.0;\r\n\r\n            const safetyFactor = 0.5;\r\n\r\n            if (body.type === b2BodyType.b2_dynamicBody && enableContinuous && maxVelocity * timeStep > safetyFactor * sim.minExtent)\r\n            {\r\n                if (sim.isBullet)\r\n                {\r\n                    stepContext.bulletBodyCount++;\r\n                    stepContext.bulletBodies[stepContext.bulletBodyCount - 1] = simIndex;\r\n                }\r\n                else\r\n                {\r\n                    stepContext.fastBodyCount++;\r\n                    stepContext.fastBodies[stepContext.fastBodyCount - 1] = simIndex;\r\n                }\r\n\r\n                sim.isFast = true;\r\n            }\r\n            else\r\n            {\r\n                sim.center0X = sim.center.x;\r\n                sim.center0Y = sim.center.y;\r\n                sim.rotation0.x = sim.transform.q.x;\r\n                sim.rotation0.y = sim.transform.q.y;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // console.warn(\"sleeping \" + body.setIndex + \" \" + body.id);\r\n            sim.center0X = sim.center.x;\r\n            sim.center0Y = sim.center.y;\r\n            sim.rotation0.x = sim.transform.q.x;\r\n            sim.rotation0.y = sim.transform.q.y;\r\n            body.sleepTime += timeStep;\r\n        }\r\n\r\n        // b2CheckIndex(islands, body.islandId);\r\n        const island = islands[body.islandId];\r\n\r\n        if (body.sleepTime < core_h.b2_timeToSleep)\r\n        {\r\n            const islandIndex = island.localIndex;\r\n            bitset_h.b2SetBit(awakeIslandBitSet, islandIndex);\r\n        }\r\n        else if (island.constraintRemoveCount > 0)\r\n        {\r\n            if (body.sleepTime > taskContext.splitSleepTime)\r\n            {\r\n                taskContext.splitIslandId = body.islandId;\r\n                taskContext.splitSleepTime = body.sleepTime;\r\n            }\r\n        }\r\n\r\n        const transform = sim.transform;\r\n        const isFast = sim.isFast;\r\n        let shapeId = body.headShapeId;\r\n\r\n        while (shapeId !== core_h.B2_NULL_INDEX)\r\n        {\r\n            const shape = world.shapeArray[shapeId];\r\n\r\n            console.assert(shape.isFast === false);\r\n\r\n            if (isFast)\r\n            {\r\n                shape.isFast = true;\r\n                bitset_h.b2SetBit(enlargedSimBitSet, simIndex);\r\n            }\r\n            else\r\n            {\r\n                const aabb = shape_h.b2ComputeShapeAABB(shape, transform);\r\n                aabb.lowerBoundX -= speculativeDistance;\r\n                aabb.lowerBoundY -= speculativeDistance;\r\n                aabb.upperBoundX += speculativeDistance;\r\n                aabb.upperBoundY += speculativeDistance;\r\n                shape.aabb = aabb;\r\n\r\n                console.assert(shape.enlargedAABB === false);\r\n\r\n                if (b2AABB_Contains(shape.fatAABB, aabb) === false)\r\n                {\r\n                    const fatAABB = new b2AABB(aabb.lowerBoundX - aabbMargin, aabb.lowerBoundY - aabbMargin,\r\n                        aabb.upperBoundX + aabbMargin, aabb.upperBoundY + aabbMargin);\r\n                    shape.fatAABB = fatAABB;\r\n\r\n                    shape.enlargedAABB = true;\r\n\r\n                    bitset_h.b2SetBit(enlargedSimBitSet, simIndex);\r\n                }\r\n            }\r\n\r\n            shapeId = shape.nextShapeId;\r\n        }\r\n    }\r\n}\r\n\r\nfunction b2ExecuteBlock(stage, context, block)\r\n{\r\n    const stageType = stage.type;\r\n    const startIndex = block.startIndex;\r\n    const endIndex = startIndex + block.count;\r\n\r\n    if (stageType === b2SolverStageType.b2_stageIntegrateVelocities)\r\n    {\r\n        b2IntegrateVelocitiesTask(startIndex, endIndex, context);\r\n    }\r\n    else if (stageType === b2SolverStageType.b2_stageIntegratePositions)\r\n    {\r\n        b2IntegratePositionsTask(startIndex, endIndex, context);\r\n    }\r\n    else\r\n    {\r\n        /*\r\n        console.log(\"block stage \" + [\r\n            \"b2_stagePrepareJoints: 0\",\r\n            \"b2_stagePrepareContacts: 1\",\r\n            \"b2_stageIntegrateVelocities: 2\",\r\n            \"b2_stageWarmStart: 3\",\r\n            \"b2_stageSolve: 4\",\r\n            \"b2_stageIntegratePositions: 5\",\r\n            \"b2_stageRelax: 6\",\r\n            \"b2_stageRestitution: 7\",\r\n            \"b2_stageStoreImpulses: 8\"\r\n        ][stageType]);\r\n        */\r\n\r\n        console.warn(\"unsupported stage type: \" + stageType);\r\n    }\r\n\r\n    // PJB: many of these stages handle SIMD data preparation or processing, all of which has been removed for the JS translation\r\n    // RD: Swapped for faster if/else block above\r\n}\r\n\r\nfunction b2ExecuteMainStage(stage, context)\r\n{\r\n    // PJB: we're not multi-threading for the JS, we simply iterate the work blocks (0..4 seems typical)\r\n    const blockCount = stage.blockCount;\r\n\r\n    for (let i = 0; i < blockCount; i++)\r\n    {\r\n        b2ExecuteBlock(stage, context, stage.blocks[i]);\r\n    }\r\n}\r\n\r\nexport function b2SolverTask(workerContext)\r\n{\r\n    const workerIndex = workerContext.workerIndex;\r\n    const context = workerContext.context;\r\n    const activeColorCount = context.activeColorCount;\r\n    const stages = context.stages;\r\n\r\n    if (workerIndex === 0)\r\n    {\r\n        // let bodySyncIndex = 1; // un-used except in debugging\r\n        let stageIndex = 0;\r\n\r\n        b2ExecuteMainStage(stages[stageIndex], context);\r\n        stageIndex += 1;\r\n\r\n        //  unused except for debugging\r\n        // let contactSyncIndex = 1;\r\n\r\n        // syncBits = (contactSyncIndex << 16) | stageIndex;\r\n        b2ExecuteMainStage(stages[stageIndex], context);\r\n        stageIndex += 1;\r\n\r\n        // contactSyncIndex += 1;\r\n\r\n        //  unused except for debugging\r\n        // let graphSyncIndex = 1;\r\n\r\n        joint_h.b2PrepareOverflowJoints(context);\r\n        contact_solver_h.b2PrepareOverflowContacts(context);\r\n\r\n        const subStepCount = context.subStepCount;\r\n\r\n        for (let i = 0; i < subStepCount; ++i)\r\n        {\r\n            let iterStageIndex = stageIndex;\r\n\r\n            // syncBits = (bodySyncIndex << 16) | iterStageIndex;\r\n            b2ExecuteMainStage(stages[iterStageIndex], context);\r\n            iterStageIndex += 1;\r\n\r\n            // bodySyncIndex += 1;\r\n\r\n            joint_h.b2WarmStartOverflowJoints(context);\r\n            contact_solver_h.b2WarmStartOverflowContacts(context);\r\n\r\n            for (let colorIndex = 0; colorIndex < activeColorCount; ++colorIndex)\r\n            {\r\n                // syncBits = (graphSyncIndex << 16) | iterStageIndex;\r\n                b2ExecuteMainStage(stages[iterStageIndex], context);\r\n                iterStageIndex += 1;\r\n            }\r\n\r\n            // graphSyncIndex += 1;\r\n\r\n            let useBias = true;\r\n            joint_h.b2SolveOverflowJoints(context, useBias);\r\n            contact_solver_h.b2SolveOverflowContacts(context, useBias);\r\n\r\n            for (let colorIndex = 0; colorIndex < activeColorCount; ++colorIndex)\r\n            {\r\n                // syncBits = (graphSyncIndex << 16) | iterStageIndex;\r\n                b2ExecuteMainStage(stages[iterStageIndex], context);\r\n                iterStageIndex += 1;\r\n            }\r\n\r\n            // graphSyncIndex += 1;\r\n\r\n            // syncBits = (bodySyncIndex << 16) | iterStageIndex;\r\n            b2ExecuteMainStage(stages[iterStageIndex], context);\r\n            iterStageIndex += 1;\r\n\r\n            // bodySyncIndex += 1;\r\n\r\n            useBias = false;\r\n            joint_h.b2SolveOverflowJoints(context, useBias);\r\n            contact_solver_h.b2SolveOverflowContacts(context, useBias);\r\n\r\n            for (let colorIndex = 0; colorIndex < activeColorCount; ++colorIndex)\r\n            {\r\n                // syncBits = (graphSyncIndex << 16) | iterStageIndex;\r\n                b2ExecuteMainStage(stages[iterStageIndex], context);\r\n                iterStageIndex += 1;\r\n            }\r\n\r\n            // graphSyncIndex += 1;\r\n        }\r\n\r\n        stageIndex += 1 + activeColorCount + activeColorCount + 1 + activeColorCount;\r\n\r\n        {\r\n            contact_solver_h.b2ApplyOverflowRestitution(context);\r\n\r\n            let iterStageIndex = stageIndex;\r\n\r\n            for (let colorIndex = 0; colorIndex < activeColorCount; ++colorIndex)\r\n            {\r\n                // syncBits = (graphSyncIndex << 16) | iterStageIndex;\r\n                b2ExecuteMainStage(stages[iterStageIndex], context);\r\n                iterStageIndex += 1;\r\n            }\r\n            stageIndex += activeColorCount;\r\n        }\r\n\r\n        contact_solver_h.b2StoreOverflowImpulses(context);\r\n\r\n        // syncBits = (contactSyncIndex << 16) | stageIndex;\r\n        console.assert( stages[stageIndex].type == b2SolverStageType.b2_stageStoreImpulses );\r\n        b2ExecuteMainStage(stages[stageIndex], context);\r\n\r\n        context.atomicSyncBits = Number.MAX_SAFE_INTEGER;\r\n        console.assert( stageIndex + 1 == context.stageCount );\r\n\r\n        return;\r\n    }\r\n\r\n    console.error(\"b2SolverTask workerIndex = \" + workerIndex);\r\n}\r\n\r\nconst constSweep = new b2Sweep(new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Rot(), new b2Rot());\r\n\r\nexport function b2ContinuousQueryCallback(proxyId, shapeId, context)\r\n{\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n\r\n    const continuousContext = context;\r\n    const fastShape = continuousContext.fastShape;\r\n    const fastBodySim = continuousContext.fastBodySim;\r\n\r\n    // skip same shape\r\n    if (shapeId === fastShape.id)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const world = continuousContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    // skip same body\r\n    if (shape.bodyId === fastShape.bodyId)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // skip sensors\r\n    if (shape.isSensor === true)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // skip filtered shapes\r\n    let canCollide = b2ShouldShapesCollide(fastShape.filter, shape.filter);\r\n\r\n    if (canCollide === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // b2CheckIndex(world.bodyArray, shape.bodyId);\r\n    const body = world.bodyArray[shape.bodyId];\r\n    const bodySim = body_h.b2GetBodySim(world, body);\r\n    console.assert(body.type === b2BodyType.b2_staticBody || fastBodySim.isBullet);\r\n\r\n    if (bodySim.isBullet)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // b2CheckIndex(world.bodyArray, fastBodySim.bodyId);\r\n    const fastBody = world.bodyArray[fastBodySim.bodyId];\r\n    canCollide = body_h.b2ShouldBodiesCollide(world, fastBody, body);\r\n\r\n    if (canCollide === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const customFilterFcn = world.customFilterFcn;\r\n\r\n    if (customFilterFcn != null)\r\n    {\r\n        const idA = new b2ShapeId(shape.id + 1, world.worldId, shape.revision);\r\n        const idB = new b2ShapeId(fastShape.id + 1, world.worldId, fastShape.revision);\r\n        canCollide = customFilterFcn(idA, idB, world.customFilterContext);\r\n\r\n        if (canCollide === false)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if (shape.type === b2ShapeType.b2_chainSegmentShape)\r\n    {\r\n        const transform = bodySim.transform;\r\n        const p1 = b2TransformPoint(transform, shape.chainSegment.segment.point1);\r\n        const p2 = b2TransformPoint(transform, shape.chainSegment.segment.point2);\r\n\r\n        // let e = b2Sub(p2, p1);\r\n        const eX = p2.x - p1.x;\r\n        const eY = p2.y - p1.y;\r\n        const c1X = continuousContext.centroid1X;\r\n        const c1Y = continuousContext.centroid1Y;\r\n        const c2X = continuousContext.centroid2X;\r\n        const c2Y = continuousContext.centroid2Y;\r\n\r\n        // let offset1 = b2Cross(b2Sub(c1, p1), e);\r\n        let dx = c1X - p1.x;\r\n        let dy = c1Y - p1.y;\r\n        const offset1 = dx * eY - dy * eX;\r\n\r\n        // let offset2 = b2Cross(b2Sub(c2, p1), e);\r\n        dx = c2X - p1.x;\r\n        dy = c2Y - p1.y;\r\n        const offset2 = dx * eY - dy * eX;\r\n\r\n        if (offset1 < 0.0 || offset2 > 0.0)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    const input = new b2TOIInput();\r\n    input.proxyA = shape_h.b2MakeShapeDistanceProxy(shape);\r\n    input.proxyB = shape_h.b2MakeShapeDistanceProxy(fastShape);\r\n    input.sweepA = body_h.b2MakeSweep(bodySim, constSweep);\r\n    input.sweepB = continuousContext.sweep;\r\n    input.tMax = continuousContext.fraction;\r\n\r\n    let hitFraction = continuousContext.fraction;\r\n\r\n    let didHit = false;\r\n    let output = b2TimeOfImpact(input);\r\n\r\n    if (0.0 < output.t && output.t < continuousContext.fraction)\r\n    {\r\n        hitFraction = output.t;\r\n        didHit = true;\r\n    }\r\n    else if (0.0 === output.t)\r\n    {\r\n        const centroid = shape_h.b2GetShapeCentroid(fastShape);\r\n        input.proxyB = b2MakeProxy([ centroid ], 1, core_h.b2_speculativeDistance);\r\n        output = b2TimeOfImpact(input);\r\n\r\n        if (0.0 < output.t && output.t < continuousContext.fraction)\r\n        {\r\n            hitFraction = output.t;\r\n            didHit = true;\r\n        }\r\n    }\r\n\r\n    if (didHit && (shape.enablePreSolveEvents || fastShape.enablePreSolveEvents))\r\n    {\r\n        // Pre-solve is expensive because I need to compute a temporary manifold\r\n        const transformA = b2GetSweepTransform( input.sweepA, hitFraction );\r\n        const transformB = b2GetSweepTransform( input.sweepB, hitFraction );\r\n        const manifold = new b2Manifold();\r\n        b2ComputeManifold( shape, transformA, fastShape, transformB, manifold );\r\n        const shapeIdA = new b2ShapeId( shape.id + 1, world.worldId, shape.revision );\r\n        const shapeIdB = new b2ShapeId( fastShape.id + 1, world.worldId, fastShape.revision );\r\n\r\n        // The user may modify the temporary manifold here but it doesn't matter. They will be able to\r\n        // modify the real manifold in the discrete solver.\r\n        didHit = world.preSolveFcn( shapeIdA, shapeIdB, manifold, world.preSolveContext );\r\n    }\r\n\r\n    if (didHit)\r\n    {\r\n        continuousContext.fraction = hitFraction;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nclass b2ContinuousContext\r\n{\r\n    constructor()\r\n    {\r\n        this.world = null;\r\n        this.fastBodySim = null;\r\n        this.fastShape = null;\r\n        this.centroid1X = 0;\r\n        this.centroid1Y = 0;\r\n        this.centroid2X = 0;\r\n        this.centroid2Y = 0;\r\n        this.sweep = null;\r\n        this.fraction = 0.0;\r\n    }\r\n}\r\n\r\nconst p = new b2Vec2();\r\nconst p1 = new b2Vec2();\r\nconst constSweep2 = new b2Sweep(new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Rot(), new b2Rot());\r\n\r\n// Continuous collision of dynamic versus static\r\nexport function b2SolveContinuous(world, bodySimIndex)\r\n{\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    console.assert(0 <= bodySimIndex && bodySimIndex < awakeSet.sims.count);\r\n    const fastBodySim = awakeSet.sims.data[bodySimIndex];\r\n    console.assert(fastBodySim.isFast);\r\n\r\n    const shapes = world.shapeArray;\r\n\r\n    const sweep = body_h.b2MakeSweep(fastBodySim, constSweep2);\r\n\r\n    // let xf1 = new b2Transform(b2Sub(sweep.c1, b2RotateVector(sweep.q1, sweep.localCenter)), sweep.q1);\r\n    p.x = sweep.c1.x - (sweep.q1.c * sweep.localCenter.x - sweep.q1.s * sweep.localCenter.y);\r\n    p.y = sweep.c1.y - (sweep.q1.s * sweep.localCenter.x + sweep.q1.c * sweep.localCenter.y);\r\n    const xf1 = new b2Transform(p, sweep.q1);\r\n\r\n    // let xf2 = new b2Transform(b2Sub(sweep.c2, b2RotateVector(sweep.q2, sweep.localCenter)), sweep.q2);\r\n    p1.x = sweep.c2.x - (sweep.q2.c * sweep.localCenter.x - sweep.q2.s * sweep.localCenter.y);\r\n    p1.y = sweep.c2.y - (sweep.q2.s * sweep.localCenter.x + sweep.q2.c * sweep.localCenter.y);\r\n    const xf2 = new b2Transform(p1, sweep.q2);\r\n\r\n    const staticTree = world.broadPhase.trees[b2BodyType.b2_staticBody];\r\n    const kinematicTree = world.broadPhase.trees[b2BodyType.b2_kinematicBody];\r\n    const dynamicTree = world.broadPhase.trees[b2BodyType.b2_dynamicBody];\r\n    const fastBody = world.bodyArray[fastBodySim.bodyId];\r\n\r\n    const context = new b2ContinuousContext();\r\n    context.world = world;\r\n    context.sweep = sweep;\r\n    context.fastBodySim = fastBodySim;\r\n    context.fraction = 1.0;\r\n\r\n    const isBullet = fastBodySim.isBullet;\r\n\r\n    let shapeId = fastBody.headShapeId;\r\n\r\n    while (shapeId != B2_NULL_INDEX)\r\n    {\r\n        // b2CheckId(shapes, shapeId);\r\n        const fastShape = shapes[shapeId];\r\n        console.assert(fastShape.isFast == true);\r\n\r\n        shapeId = fastShape.nextShapeId;\r\n\r\n        // Clear flag (keep set on body)\r\n        fastShape.isFast = false;\r\n\r\n        context.fastShape = fastShape;\r\n\r\n        // context.centroid1 = b2TransformPoint(xf1, fastShape.localCentroid);\r\n        b2TransformPointOut(xf1, fastShape.localCentroid, p);\r\n        context.centroid1X = p.x;\r\n        context.centroid1Y = p.y;\r\n\r\n        // context.centroid2 = b2TransformPoint(xf2, fastShape.localCentroid);\r\n        b2TransformPointOut(xf2, fastShape.localCentroid, p);\r\n        context.centroid2X = p.x;\r\n        context.centroid2Y = p.y;\r\n\r\n        const box1 = fastShape.aabb;\r\n        const box2 = shape_h.b2ComputeShapeAABB(fastShape, xf2);\r\n        const box = b2AABB_Union(box1, box2);\r\n\r\n        // Store this for later\r\n        fastShape.aabb = box2;\r\n\r\n        // No continuous collision for sensors\r\n        if (fastShape.isSensor)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        b2DynamicTree_Query(staticTree, box, B2_DEFAULT_MASK_BITS, b2ContinuousQueryCallback, context);\r\n\r\n        if (isBullet)\r\n        {\r\n            b2DynamicTree_Query(kinematicTree, box, B2_DEFAULT_MASK_BITS, b2ContinuousQueryCallback, context);\r\n            b2DynamicTree_Query(dynamicTree, box, B2_DEFAULT_MASK_BITS, b2ContinuousQueryCallback, context);\r\n        }\r\n    }\r\n\r\n    const speculativeDistance = core_h.b2_speculativeDistance;\r\n    const aabbMargin = core_h.b2_aabbMargin;\r\n\r\n    if (context.fraction < 1.0)\r\n    {\r\n        // Handle time of impact event\r\n        const q = b2NLerp(sweep.q1, sweep.q2, context.fraction);\r\n        const c = b2Lerp(sweep.c1, sweep.c2, context.fraction);\r\n        const origin = b2Sub(c, b2RotateVector(q, sweep.localCenter));\r\n\r\n        // Advance body\r\n        const transform = new b2Transform(origin, q);\r\n        fastBodySim.transform = transform;\r\n        fastBodySim.center = c;\r\n        fastBodySim.rotation0 = q;\r\n        fastBodySim.center0X = c.x;\r\n        fastBodySim.center0Y = c.y;\r\n\r\n        // Prepare AABBs for broad-phase\r\n        shapeId = fastBody.headShapeId;\r\n\r\n        while (shapeId != B2_NULL_INDEX)\r\n        {\r\n            const shape = shapes[shapeId];\r\n\r\n            // Must recompute aabb at the interpolated transform\r\n            const aabb = shape_h.b2ComputeShapeAABB(shape, transform);\r\n            aabb.lowerBoundX -= speculativeDistance;\r\n            aabb.lowerBoundY -= speculativeDistance;\r\n            aabb.upperBoundX += speculativeDistance;\r\n            aabb.upperBoundY += speculativeDistance;\r\n            shape.aabb = aabb;\r\n\r\n            if (!b2AABB_Contains(shape.fatAABB, aabb))\r\n            {\r\n                const fatAABB = new b2AABB(aabb.lowerBoundX - aabbMargin, aabb.lowerBoundY - aabbMargin,\r\n                    aabb.upperBoundX + aabbMargin, aabb.upperBoundY + aabbMargin);\r\n                shape.fatAABB = fatAABB;\r\n\r\n                shape.enlargedAABB = true;\r\n                fastBodySim.enlargeAABB = true;\r\n            }\r\n\r\n            shapeId = shape.nextShapeId;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // No time of impact event\r\n\r\n        // Advance body\r\n        fastBodySim.rotation0 = fastBodySim.transform.q;\r\n        fastBodySim.center0X = fastBodySim.center.x;\r\n        fastBodySim.center0Y = fastBodySim.center.y;\r\n\r\n        // Prepare AABBs for broad-phase\r\n        shapeId = fastBody.headShapeId;\r\n\r\n        while (shapeId != B2_NULL_INDEX)\r\n        {\r\n            const shape = shapes[shapeId];\r\n\r\n            // shape.aabb is still valid\r\n\r\n            if (!b2AABB_Contains(shape.fatAABB, shape.aabb))\r\n            {\r\n                const fatAABB = new b2AABB(shape.aabb.lowerBoundX - aabbMargin, shape.aabb.lowerBoundY - aabbMargin,\r\n                    shape.aabb.upperBoundX + aabbMargin, shape.aabb.upperBoundY + aabbMargin);\r\n                shape.fatAABB = fatAABB;\r\n\r\n                shape.enlargedAABB = true;\r\n                fastBodySim.enlargeAABB = true;\r\n            }\r\n\r\n            shapeId = shape.nextShapeId;\r\n        }\r\n    }\r\n}\r\n\r\nexport function b2FastBodyTask(startIndex, endIndex, taskContext)\r\n{\r\n    // B2_MAYBE_UNUSED(threadIndex);\r\n\r\n    const stepContext = taskContext;\r\n\r\n    console.assert(startIndex <= endIndex);\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const simIndex = stepContext.fastBodies[i];\r\n        b2SolveContinuous(stepContext.world, simIndex);\r\n    }\r\n}\r\n\r\nexport function b2BulletBodyTask(startIndex, endIndex, taskContext)\r\n{\r\n    // B2_MAYBE_UNUSED(threadIndex);\r\n\r\n    const stepContext = taskContext;\r\n\r\n    console.assert(startIndex <= endIndex);\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const simIndex = stepContext.bulletBodies[i];\r\n        b2SolveContinuous(stepContext.world, simIndex);\r\n    }\r\n}\r\n\r\n// Solve with graph coloring\r\nexport function b2Solve(world, stepContext)\r\n{\r\n    // const timer = b2CreateTimer();\r\n\r\n    world.stepIndex += 1;\r\n\r\n    b2MergeAwakeIslands(world);\r\n\r\n    // world.profile.buildIslands = b2GetMillisecondsAndReset(timer);\r\n\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const awakeBodyCount = awakeSet.sims.count;\r\n\r\n    if (awakeBodyCount === 0)\r\n    {\r\n        // b2ValidateNoEnlarged(world.broadPhase);\r\n        return;\r\n    }\r\n\r\n    // Prepare buffers for continuous collision (fast bodies)\r\n    stepContext.fastBodyCount = 0;\r\n    stepContext.fastBodies = b2AllocateStackItem(world.stackAllocator, awakeBodyCount, \"fast bodies\");\r\n    stepContext.bulletBodyCount = 0;\r\n    stepContext.bulletBodies = b2AllocateStackItem(world.stackAllocator, awakeBodyCount, \"bullet bodies\");\r\n\r\n    // Solve constraints using graph coloring\r\n    {\r\n        const graph = world.constraintGraph;\r\n        const colors = graph.colors;\r\n\r\n        stepContext.sims = awakeSet.sims.data;\r\n        stepContext.states = awakeSet.states.data;\r\n\r\n        // count contacts, joints, and colors\r\n        // let awakeContactCount = 0;\r\n        let awakeJointCount = 0;\r\n        let activeColorCount = 0;\r\n\r\n        for (let i = 0; i < b2_graphColorCount - 1; ++i)\r\n        {\r\n            const perColorContactCount = colors[i].contacts.count;\r\n            const perColorJointCount = colors[i].joints.count;\r\n            const occupancyCount = perColorContactCount + perColorJointCount;\r\n            activeColorCount += occupancyCount > 0 ? 1 : 0;\r\n\r\n            // awakeContactCount += perColorContactCount;\r\n            awakeJointCount += perColorJointCount;\r\n        }\r\n\r\n        // Deal with void**\r\n        {\r\n            const bodyMoveEventArray = world.bodyMoveEventArray;\r\n\r\n            // b2Array_Resize(bodyMoveEventArray, awakeBodyCount);\r\n            // if (bodyMoveEventArray.length < awakeBodyCount) {\r\n            while (bodyMoveEventArray.length < awakeBodyCount)\r\n            {\r\n                bodyMoveEventArray.push(new b2BodyMoveEvent());\r\n            }\r\n\r\n            // }\r\n        }\r\n\r\n        const workerCount = world.workerCount;\r\n        const blocksPerWorker = 4;\r\n        const maxBlockCount = blocksPerWorker * workerCount;\r\n\r\n        // PJB TODO: is ANY of this parallel stuff used in the JS? It should all be handled by 'overflow' cases...\r\n\r\n        // Configure blocks for tasks that parallel-for bodies\r\n        let bodyBlockSize = 1 << 5;\r\n        let bodyBlockCount;\r\n\r\n        if (awakeBodyCount > bodyBlockSize * maxBlockCount)\r\n        {\r\n            // Too many blocks, increase block size\r\n            bodyBlockSize = Math.floor(awakeBodyCount / maxBlockCount);\r\n            bodyBlockCount = maxBlockCount;\r\n        }\r\n        else\r\n        {\r\n            bodyBlockCount = Math.floor((awakeBodyCount - 1) >> 5) + 1;\r\n        }\r\n\r\n        // Configure blocks for tasks parallel-for each active graph color\r\n        // The blocks are a mix of SIMD contact blocks and joint blocks\r\n\r\n        const colorContactCounts = new Array(b2_graphColorCount);\r\n        const colorContactBlockSizes = new Array(b2_graphColorCount);\r\n        const colorContactBlockCounts = new Array(b2_graphColorCount);\r\n\r\n        const colorJointCounts = new Array(b2_graphColorCount);\r\n        const colorJointBlockSizes = new Array(b2_graphColorCount);\r\n        const colorJointBlockCounts = new Array(b2_graphColorCount);\r\n\r\n        const graphBlockCount = 0;\r\n        const simdContactCount = 0;\r\n\r\n        const overflowContactCount = colors[constraint_graph_h.b2_overflowIndex].contacts.count;\r\n        const overflowContactConstraints = b2AllocateStackItem(\r\n            world.stackAllocator,\r\n            overflowContactCount,\r\n            \"overflow contact constraint\",\r\n            () => { return new contact_solver_h.b2ContactConstraint(); }\r\n        );\r\n       \r\n        graph.colors[constraint_graph_h.b2_overflowIndex].overflowConstraints = overflowContactConstraints;\r\n\r\n        // Define work blocks for preparing contacts and storing contact impulses\r\n        let contactBlockSize = blocksPerWorker;\r\n        let contactBlockCount = simdContactCount > 0 ? Math.floor((simdContactCount - 1) >> 2) + 1 : 0;\r\n\r\n        if (simdContactCount > contactBlockSize * maxBlockCount)\r\n        {\r\n            // Too many blocks, increase block size\r\n            contactBlockSize = Math.floor(simdContactCount / maxBlockCount);\r\n            contactBlockCount = maxBlockCount;\r\n        }\r\n\r\n        // Define work blocks for preparing joints\r\n        let jointBlockSize = blocksPerWorker;\r\n        let jointBlockCount = awakeJointCount > 0 ? Math.floor((awakeJointCount - 1) >> 2) + 1 : 0;\r\n\r\n        if (awakeJointCount > jointBlockSize * maxBlockCount)\r\n        {\r\n            // Too many blocks, increase block size\r\n            jointBlockSize = Math.floor(awakeJointCount / maxBlockCount);\r\n            jointBlockCount = maxBlockCount;\r\n        }\r\n       \r\n        let stageCount = 0;\r\n\r\n        // b2_stagePrepareJoints\r\n        stageCount += 1;\r\n\r\n        // b2_stagePrepareContacts\r\n        stageCount += 1;\r\n\r\n        // b2_stageIntegrateVelocities\r\n        stageCount += 1;\r\n\r\n        // b2_stageWarmStart\r\n        stageCount += activeColorCount;\r\n\r\n        // b2_stageSolve\r\n        stageCount += activeColorCount;\r\n\r\n        // b2_stageIntegratePositions\r\n        stageCount += 1;\r\n\r\n        // b2_stageRelax\r\n        stageCount += activeColorCount;\r\n\r\n        // b2_stageRestitution\r\n        stageCount += activeColorCount;\r\n\r\n        // b2_stageStoreImpulses\r\n        stageCount += 1;\r\n\r\n        const stages = Array.from({ length: stageCount }, () => new b2SolverStage());   // b2AllocateStackItem(world.stackAllocator, stageCount, \"stages\", () => { return new b2SolverStage(); });\r\n        const bodyBlocks = b2AllocateStackItem(world.stackAllocator, bodyBlockCount, \"body blocks\");\r\n        const contactBlocks = b2AllocateStackItem(world.stackAllocator, contactBlockCount, \"contact blocks\");\r\n        const jointBlocks = b2AllocateStackItem(world.stackAllocator, jointBlockCount, \"joint blocks\");\r\n        const graphBlocks = b2AllocateStackItem(world.stackAllocator, graphBlockCount, \"graph blocks\");\r\n\r\n        // Split an awake island. This modifies:\r\n        // - stack allocator\r\n        // - world island array and solver set\r\n        // - island indices on bodies, contacts, and joints\r\n        if (world.splitIslandId != B2_NULL_INDEX)\r\n        {\r\n            b2SplitIsland(world, world.splitIslandId);\r\n        }\r\n\r\n        // Prepare body work blocks\r\n        for (let i = 0; i < bodyBlockCount; ++i)\r\n        {\r\n            const block = new b2SolverBlock();\r\n            block.startIndex = i * bodyBlockSize;\r\n            block.count = bodyBlockSize;\r\n            block.blockType = b2SolverBlockType.b2_bodyBlock;\r\n            block.syncIndex = 0;\r\n            bodyBlocks[i] = block;\r\n        }\r\n        bodyBlocks[bodyBlockCount - 1].count = awakeBodyCount - (bodyBlockCount - 1) * bodyBlockSize;\r\n\r\n        // Prepare joint work blocks\r\n        for (let i = 0; i < jointBlockCount; ++i)\r\n        {\r\n            const block = new b2SolverBlock();\r\n            block.startIndex = i * jointBlockSize;\r\n            block.count = jointBlockSize;\r\n            block.blockType = b2SolverBlockType.b2_jointBlock;\r\n            block.syncIndex = 0;\r\n            jointBlocks[i] = block;\r\n        }\r\n\r\n        if (jointBlockCount > 0)\r\n        {\r\n            jointBlocks[jointBlockCount - 1].count = awakeJointCount - (jointBlockCount - 1) * jointBlockSize;\r\n        }\r\n\r\n        // Prepare contact work blocks\r\n        for (let i = 0; i < contactBlockCount; ++i)\r\n        {\r\n            const block = new b2SolverBlock();\r\n            block.startIndex = i * contactBlockSize;\r\n            block.count = contactBlockSize;\r\n            block.blockType = b2SolverBlockType.b2_contactBlock;\r\n            block.syncIndex = 0;\r\n            contactBlocks[i] = block;\r\n        }\r\n\r\n        if (contactBlockCount > 0)\r\n        {\r\n            contactBlocks[contactBlockCount - 1].count = simdContactCount - (contactBlockCount - 1) * contactBlockSize;\r\n        }\r\n\r\n        // Prepare graph work blocks\r\n        const graphColorBlocks = new Array(b2_graphColorCount);\r\n        let baseGraphBlock = 0; // Index into graphBlocks\r\n\r\n        for (let i = 0; i < activeColorCount; ++i)\r\n        {\r\n            graphColorBlocks[i] = baseGraphBlock;\r\n            const colorJointBlockCount = colorJointBlockCounts[i];\r\n            const colorJointBlockSize = colorJointBlockSizes[i];\r\n\r\n            for (let j = 0; j < colorJointBlockCount; ++j)\r\n            {\r\n                const block = new b2SolverBlock();\r\n                block.startIndex = j * colorJointBlockSize;\r\n                block.count = colorJointBlockSize;\r\n                block.blockType = b2SolverBlockType.b2_graphJointBlock;\r\n                block.syncIndex = 0;\r\n                graphBlocks[baseGraphBlock + j] = block;\r\n            }\r\n\r\n            if (colorJointBlockCount > 0)\r\n            {\r\n                graphBlocks[baseGraphBlock + colorJointBlockCount - 1].count =\r\n                    colorJointCounts[i] - (colorJointBlockCount - 1) * colorJointBlockSize;\r\n                baseGraphBlock += colorJointBlockCount;\r\n            }\r\n            const colorContactBlockCount = colorContactBlockCounts[i];\r\n            const colorContactBlockSize = colorContactBlockSizes[i];\r\n\r\n            for (let j = 0; j < colorContactBlockCount; ++j)\r\n            {\r\n                const block = new b2SolverBlock();\r\n                block.startIndex = j * colorContactBlockSize;\r\n                block.count = colorContactBlockSize;\r\n                block.blockType = b2SolverBlockType.b2_graphContactBlock;\r\n                block.syncIndex = 0;\r\n                graphBlocks[baseGraphBlock + j] = block;\r\n            }\r\n\r\n            if (colorContactBlockCount > 0)\r\n            {\r\n                graphBlocks[baseGraphBlock + colorContactBlockCount - 1].count =\r\n                    colorContactCounts[i] - (colorContactBlockCount - 1) * colorContactBlockSize;\r\n                baseGraphBlock += colorContactBlockCount;\r\n            }\r\n        }\r\n        const blockDiff = baseGraphBlock;\r\n        console.assert(blockDiff === graphBlockCount, `Block count mismatch: ${blockDiff} !== ${graphBlockCount}`);\r\n\r\n        // modified stage builder\r\n        let si = 0;\r\n\r\n        // Helper function to set stage properties\r\n        const setStageProperties = (stage, type, blocks, blockCount, colorIndex = -1) =>\r\n        {\r\n            stage.type = type;\r\n            stage.blocks = blocks;\r\n            stage.blockCount = blockCount;\r\n            stage.colorIndex = colorIndex;\r\n            stage.completionCount = 0;\r\n        };\r\n        \r\n        // Prepare joints\r\n        setStageProperties(stages[si++], b2SolverStageType.b2_stagePrepareJoints, jointBlocks, jointBlockCount);\r\n\r\n        // Prepare contacts\r\n        setStageProperties(stages[si++], b2SolverStageType.b2_stagePrepareContacts, contactBlocks, contactBlockCount);\r\n\r\n        // Integrate velocities\r\n        setStageProperties(stages[si++], b2SolverStageType.b2_stageIntegrateVelocities, bodyBlocks, bodyBlockCount);\r\n\r\n        // Warm start\r\n        /*\r\n        console.log(\"activeColorCount \" + activeColorCount);\r\n        for (let i = 0; i < activeColorCount; ++i) {\r\n            setStageProperties(\r\n                stages[si++],\r\n                b2SolverStageType.b2_stageWarmStart,\r\n                graphBlocks.slice(graphColorBlocks[i], graphColorBlocks[i] + colorJointBlockCounts[i] + colorContactBlockCounts[i]),\r\n                colorJointBlockCounts[i] + colorContactBlockCounts[i],\r\n                activeColorIndices[i]\r\n            );\r\n        }\r\n        */\r\n        \r\n        // Solve graph\r\n        /*\r\n        for (let i = 0; i < activeColorCount; ++i) {\r\n            setStageProperties(\r\n                stages[si++],\r\n                b2SolverStageType.b2_stageSolve,\r\n                graphBlocks.slice(graphColorBlocks[i], graphColorBlocks[i] + colorJointBlockCounts[i] + colorContactBlockCounts[i]),\r\n                colorJointBlockCounts[i] + colorContactBlockCounts[i],\r\n                activeColorIndices[i]\r\n            );\r\n        }\r\n        */\r\n        \r\n        // Integrate positions\r\n        setStageProperties(stages[si++], b2SolverStageType.b2_stageIntegratePositions, bodyBlocks, bodyBlockCount);\r\n        \r\n        // Relax constraints\r\n        /*\r\n        for (let i = 0; i < activeColorCount; ++i) {\r\n            setStageProperties(\r\n                stages[si++],\r\n                b2SolverStageType.b2_stageRelax,\r\n                graphBlocks.slice(graphColorBlocks[i], graphColorBlocks[i] + colorJointBlockCounts[i] + colorContactBlockCounts[i]),\r\n                colorJointBlockCounts[i] + colorContactBlockCounts[i],\r\n                activeColorIndices[i]\r\n            );\r\n        }\r\n        */\r\n        \r\n        // Restitution\r\n        // Note: joint blocks mixed in, could have joint limit restitution\r\n        /*\r\n        for (let i = 0; i < activeColorCount; ++i) {\r\n            setStageProperties(\r\n                stages[si++],\r\n                b2SolverStageType.b2_stageRestitution,\r\n                graphBlocks.slice(graphColorBlocks[i], graphColorBlocks[i] + colorJointBlockCounts[i] + colorContactBlockCounts[i]),\r\n                colorJointBlockCounts[i] + colorContactBlockCounts[i],\r\n                activeColorIndices[i]\r\n            );\r\n        }\r\n        */\r\n        \r\n        // Store impulses\r\n        setStageProperties(stages[si++], b2SolverStageType.b2_stageStoreImpulses, contactBlocks, contactBlockCount);\r\n        \r\n        console.assert(si === stageCount, \"Stage count mismatch\");\r\n            \r\n        console.assert(workerCount <= b2_maxWorkers);\r\n\r\n        stepContext.graph = graph;\r\n        stepContext.joints = null;  // joints;\r\n        stepContext.contacts = null;    // contacts;\r\n        stepContext.simdContactConstraints = null;  // simdContactConstraints;\r\n        stepContext.activeColorCount = activeColorCount;\r\n        stepContext.workerCount = workerCount;\r\n        stepContext.stageCount = stageCount;\r\n        stepContext.stages = stages;\r\n\r\n        {\r\n            const workerContext = new b2WorkerContext();\r\n            workerContext.context = stepContext;\r\n            workerContext.workerIndex = 0;\r\n            b2SolverTask(workerContext);\r\n        }\r\n\r\n        world.splitIslandId = B2_NULL_INDEX;\r\n\r\n        // Prepare contact, enlarged body, and island bit sets used in body finalization.\r\n        const awakeIslandCount = awakeSet.islands.count;\r\n\r\n        for (let i = 0; i < world.workerCount; ++i)\r\n        {\r\n            const taskContext = world.taskContextArray[i];\r\n            taskContext.enlargedSimBitSet = bitset_h.b2SetBitCountAndClear(taskContext.enlargedSimBitSet, awakeBodyCount);\r\n            taskContext.awakeIslandBitSet = bitset_h.b2SetBitCountAndClear(taskContext.awakeIslandBitSet, awakeIslandCount);\r\n            taskContext.splitIslandId = B2_NULL_INDEX;\r\n            taskContext.splitSleepTime = 0.0;\r\n        }\r\n\r\n\r\n        // Finalize bodies. Must happen after the constraint solver and after island splitting.\r\n        b2FinalizeBodiesTask(0, awakeBodyCount, 0, stepContext);\r\n\r\n        b2FreeStackItem(world.stackAllocator, graphBlocks);\r\n        b2FreeStackItem(world.stackAllocator, jointBlocks);\r\n        b2FreeStackItem(world.stackAllocator, contactBlocks);\r\n        b2FreeStackItem(world.stackAllocator, bodyBlocks);\r\n\r\n        // b2FreeStackItem(world.stackAllocator, stages);\r\n        b2FreeStackItem(world.stackAllocator, overflowContactConstraints);\r\n\r\n        // b2FreeStackItem(world.stackAllocator, joints);\r\n        // b2FreeStackItem(world.stackAllocator, contacts);\r\n    }\r\n\r\n    // Report hit events\r\n    // todo perhaps optimize this with a bitset\r\n    {\r\n        console.assert(world.contactHitArray.length === 0);\r\n\r\n        const threshold = world.hitEventThreshold;\r\n        const colors = world.constraintGraph.colors;\r\n\r\n        for (let i = 0; i < b2_graphColorCount; ++i)\r\n        {\r\n            const color = colors[i];\r\n            const contactCount = color.contacts.count;\r\n            const contactSims = color.contacts.data;\r\n\r\n            for (let j = 0; j < contactCount; ++j)\r\n            {\r\n                const contactSim = contactSims[j];\r\n\r\n                if ((contactSim.simFlags & b2ContactSimFlags.b2_simEnableHitEvent) === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                const event = new b2ContactHitEvent();\r\n                event.approachSpeed = threshold;\r\n                event.shapeIdA = new b2ShapeId(0, 0, 0);\r\n                event.shapeIdB = new b2ShapeId(0, 0, 0);\r\n\r\n                let hit = false;\r\n                const pointCount = contactSim.manifold.pointCount;\r\n\r\n                for (let k = 0; k < pointCount; ++k)\r\n                {\r\n                    const mp = contactSim.manifold.points[k];\r\n                    const approachSpeed = -mp.normalVelocity;\r\n\r\n                    // Need to check max impulse because the point may be speculative and not colliding\r\n                    if (approachSpeed > event.approachSpeed && mp.maxNormalImpulse > 0.0)\r\n                    {\r\n                        event.approachSpeed = approachSpeed;\r\n                        event.pointX = mp.pointX;\r\n                        event.pointY = mp.pointY;\r\n                        hit = true;\r\n                    }\r\n                }\r\n\r\n                if (hit === true)\r\n                {\r\n                    event.normalX = contactSim.manifold.normalX;\r\n                    event.normalY = contactSim.manifold.normalY;\r\n\r\n                    // b2CheckId(world.shapeArray, contactSim.shapeIdA);\r\n                    // b2CheckId(world.shapeArray, contactSim.shapeIdB);\r\n                    const shapeA = world.shapeArray[contactSim.shapeIdA];\r\n                    const shapeB = world.shapeArray[contactSim.shapeIdB];\r\n\r\n                    event.shapeIdA = new b2ShapeId(shapeA.id + 1, world.worldId, shapeA.revision);\r\n                    event.shapeIdB = new b2ShapeId(shapeB.id + 1, world.worldId, shapeB.revision);\r\n\r\n                    world.contactHitArray.push(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Gather bits for all sim bodies that have enlarged AABBs\r\n    const simBitSet = world.taskContextArray[0].enlargedSimBitSet;\r\n\r\n    for (let i = 1; i < world.workerCount; ++i)\r\n    {\r\n        bitset_h.b2InPlaceUnion(simBitSet, world.taskContextArray[i].enlargedSimBitSet);\r\n    }\r\n\r\n    // Enlarge broad-phase proxies and build move array\r\n    // Apply shape AABB changes to broad-phase. This also creates the move array which must be\r\n    // in deterministic order. I'm tracking sim bodies because the number of shape ids can be huge.\r\n    {\r\n        const broadPhase = world.broadPhase;\r\n        const shapes = world.shapeArray;\r\n        const wordCount = simBitSet.blockCount;\r\n        const bits = simBitSet.bits;\r\n\r\n        for (let k = 0; k < wordCount; ++k)\r\n        {\r\n            let word = bits[k];\r\n\r\n            while (word !== 0n)\r\n            {\r\n                const ctz = b2CTZ64(word);              // 0..63\r\n                const bodySimIndex = 64 * k + ctz;\r\n\r\n                // cache misses\r\n                console.assert(bodySimIndex < awakeSet.sims.count);\r\n                const bodySim = awakeSet.sims.data[bodySimIndex];\r\n\r\n                // b2CheckIndex(world.bodyArray, bodySim.bodyId);\r\n                const body = world.bodyArray[bodySim.bodyId];\r\n\r\n                let shapeId = body.headShapeId;\r\n\r\n                while (shapeId !== B2_NULL_INDEX)\r\n                {\r\n                    // b2CheckId(shapes, shapeId);\r\n                    const shape = shapes[shapeId];\r\n\r\n                    if (shape.enlargedAABB)\r\n                    {\r\n                        console.assert(shape.isFast === false);\r\n\r\n                        b2BroadPhase_EnlargeProxy(broadPhase, shape.proxyKey, shape.fatAABB);\r\n                        shape.enlargedAABB = false;\r\n                    }\r\n                    else if (shape.isFast)\r\n                    {\r\n                        // Shape is fast. It's aabb will be enlarged in continuous collision.\r\n                        b2BufferMove(broadPhase, shape.proxyKey);\r\n                    }\r\n\r\n                    shapeId = shape.nextShapeId;\r\n                }\r\n\r\n                // Clear the smallest set bit\r\n                word = word & (word - 1n);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Continuous collision\r\n    if (stepContext.fastBodyCount > 0)\r\n    {\r\n        // fast bodies\r\n        b2FastBodyTask(0, stepContext.fastBodyCount, stepContext);\r\n    }\r\n\r\n    // Serially enlarge broad-phase proxies for fast shapes\r\n    // Doing this here so that bullet shapes see them\r\n    {\r\n        const broadPhase = world.broadPhase;\r\n        const dynamicTree = broadPhase.trees[b2BodyType.b2_dynamicBody];\r\n        const bodies = world.bodyArray;\r\n        const shapes = world.shapeArray;\r\n\r\n        const fastBodies = stepContext.fastBodies;\r\n        const fastBodyCount = stepContext.fastBodyCount;\r\n\r\n        // This loop has non-deterministic order but it shouldn't affect the result\r\n        for (let i = 0; i < fastBodyCount; ++i)\r\n        {\r\n            console.assert(0 <= fastBodies[i] && fastBodies[i] < awakeSet.sims.count);\r\n            const fastBodySim = awakeSet.sims.data[fastBodies[i]];\r\n\r\n            if (fastBodySim.enlargeAABB === false)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // clear flag\r\n            fastBodySim.enlargeAABB = false;\r\n\r\n            // b2CheckIndex(bodies, fastBodySim.bodyId);\r\n            const fastBody = bodies[fastBodySim.bodyId];\r\n\r\n            let shapeId = fastBody.headShapeId;\r\n\r\n            while (shapeId !== B2_NULL_INDEX)\r\n            {\r\n                const shape = shapes[shapeId];\r\n\r\n                if (shape.enlargedAABB === false)\r\n                {\r\n                    shapeId = shape.nextShapeId;\r\n\r\n                    continue;\r\n                }\r\n\r\n                // clear flag\r\n                shape.enlargedAABB = false;\r\n\r\n                const proxyKey = shape.proxyKey;\r\n                const proxyId = B2_PROXY_ID(proxyKey);\r\n                console.assert(B2_PROXY_TYPE(proxyKey) === b2BodyType.b2_dynamicBody);\r\n\r\n                // all fast shapes should already be in the move buffer\r\n                // console.assert(b2ContainsKey(broadPhase.moveSet, proxyKey + 1));\r\n\r\n                b2DynamicTree_EnlargeProxy(dynamicTree, proxyId, shape.fatAABB);\r\n\r\n                shapeId = shape.nextShapeId;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    if (stepContext.bulletBodyCount > 0)\r\n    {\r\n        // bullet bodies\r\n        b2BulletBodyTask(0, stepContext.bulletBodyCount, stepContext);\r\n    }\r\n\r\n    // Serially enlarge broad-phase proxies for bullet shapes\r\n    {\r\n        const broadPhase = world.broadPhase;\r\n        const dynamicTree = broadPhase.trees[b2BodyType.b2_dynamicBody];\r\n        const bodies = world.bodyArray;\r\n        const shapes = world.shapeArray;\r\n\r\n        const bulletBodies = stepContext.bulletBodies;\r\n        const bulletBodyCount = stepContext.bulletBodyCount;\r\n\r\n        // This loop has non-deterministic order but it shouldn't affect the result\r\n        for (let i = 0; i < bulletBodyCount; ++i)\r\n        {\r\n            console.assert(0 <= bulletBodies[i] && bulletBodies[i] < awakeSet.sims.count);\r\n            const bulletBodySim = awakeSet.sims.data[bulletBodies[i]];\r\n\r\n            if (bulletBodySim.enlargeAABB === false)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // clear flag\r\n            bulletBodySim.enlargeAABB = false;\r\n\r\n            // b2CheckIndex(bodies, bulletBodySim.bodyId);\r\n            const bulletBody = bodies[bulletBodySim.bodyId];\r\n\r\n            let shapeId = bulletBody.headShapeId;\r\n\r\n            while (shapeId !== B2_NULL_INDEX)\r\n            {\r\n                const shape = shapes[shapeId];\r\n\r\n                if (shape.enlargedAABB === false)\r\n                {\r\n                    shapeId = shape.nextShapeId;\r\n\r\n                    continue;\r\n                }\r\n\r\n                // clear flag\r\n                shape.enlargedAABB = false;\r\n\r\n                const proxyKey = shape.proxyKey;\r\n                const proxyId = B2_PROXY_ID(proxyKey);\r\n                console.assert(B2_PROXY_TYPE(proxyKey) === b2BodyType.b2_dynamicBody);\r\n\r\n                // all fast shapes should already be in the move buffer\r\n                // console.assert(b2ContainsKey(broadPhase.moveSet, proxyKey + 1));\r\n\r\n                b2DynamicTree_EnlargeProxy(dynamicTree, proxyId, shape.fatAABB);\r\n\r\n                shapeId = shape.nextShapeId;\r\n            }\r\n        }\r\n    }\r\n\r\n    b2FreeStackItem(world.stackAllocator, stepContext.bulletBodies);\r\n    stepContext.bulletBodies = null;\r\n    stepContext.bulletBodyCount = 0;\r\n\r\n    b2FreeStackItem(world.stackAllocator, stepContext.fastBodies);\r\n    stepContext.fastBodies = null;\r\n    stepContext.fastBodyCount = 0;\r\n\r\n    // Island sleeping\r\n    // This must be done last because putting islands to sleep invalidates the enlarged body bits.\r\n    if (world.enableSleep === true)\r\n    {\r\n\r\n        // Collect split island candidate for the next time step. No need to split if sleeping is disabled.\r\n        console.assert(world.splitIslandId === B2_NULL_INDEX);\r\n        let splitSleepTimer = 0.0;\r\n\r\n        for (let i = 0; i < world.workerCount; ++i)\r\n        {\r\n            const taskContext = world.taskContextArray[i];\r\n\r\n            if (taskContext.splitIslandId !== B2_NULL_INDEX && taskContext.splitSleepTime > splitSleepTimer)\r\n            {\r\n                world.splitIslandId = taskContext.splitIslandId;\r\n                splitSleepTimer = taskContext.splitSleepTime;\r\n            }\r\n        }\r\n\r\n        const awakeIslandBitSet = world.taskContextArray[0].awakeIslandBitSet;\r\n\r\n        for (let i = 1; i < world.workerCount; ++i)\r\n        {\r\n            bitset_h.b2InPlaceUnion(awakeIslandBitSet, world.taskContextArray[i].awakeIslandBitSet);\r\n        }\r\n\r\n        // Need to process in reverse because this moves islands to sleeping solver sets.\r\n        const islands = awakeSet.islands.data;\r\n        const count = awakeSet.islands.count;\r\n\r\n        for (let islandIndex = count - 1; islandIndex >= 0; islandIndex -= 1)\r\n        {\r\n            if (bitset_h.b2GetBit(awakeIslandBitSet, islandIndex) === true)\r\n            {\r\n                // this island is still awake\r\n                continue;\r\n            }\r\n\r\n            const island = islands[islandIndex];\r\n            const islandId = island.islandId;\r\n\r\n            // console.warn(\"move island \" + islandIndex + \" \" + island.islandId + \" to sleeping solver set\");\r\n\r\n            b2TrySleepIsland(world, islandId);\r\n        }\r\n\r\n        b2ValidateSolverSets(world);\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_HUGE, B2_NULL_INDEX, b2_lengthUnitsPerMeter, b2_linearSlop } from './include/core_h.js';\r\nimport {\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2CrossSV,\r\n    b2Dot,\r\n    b2Length,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2Normalize,\r\n    b2RightPerp,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2TransformPoint\r\n} from './include/math_functions_h.js';\r\nimport { b2BodyState, b2GetBodyTransform } from './include/body_h.js';\r\nimport { b2GetWorld, b2SetType } from './include/world_h.js';\r\nimport { b2HexColor, b2JointType } from './include/types_h.js';\r\n\r\nimport { b2GetJointSimCheckType } from './include/joint_h.js';\r\nimport { b2MakeSoft } from './include/solver_h.js';\r\n\r\n/**\r\n * @namespace DistanceJoint\r\n*/\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h'\r\n */\r\n\r\n/**\r\n * @function b2DistanceJoint_SetLength\r\n * @summary Sets the target length of a distance joint and resets its impulses.\r\n * @param {b2JointId} jointId - The identifier of the distance joint to modify.\r\n * @param {number} length - The desired length of the joint, clamped between b2_linearSlop and B2_HUGE.\r\n * @returns {void}\r\n * @description\r\n * Sets the target length of a distance joint. The length value is automatically\r\n * clamped between b2_linearSlop and B2_HUGE. After setting the length,\r\n * the joint's impulse values are reset to zero.\r\n * @throws {Error} Throws if the joint type is not b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_SetLength(jointId, length)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    joint.length = b2ClampFloat(length, b2_linearSlop, B2_HUGE);\r\n    joint.impulse = 0.0;\r\n    joint.lowerImpulse = 0.0;\r\n    joint.upperImpulse = 0.0;\r\n}\r\n\r\n/**\r\n * @summary Gets the length of a distance joint.\r\n * @function b2DistanceJoint_GetLength\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The current length of the distance joint.\r\n * @description\r\n * Returns the current length of a distance joint. The joint must be of type b2_distanceJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_GetLength(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    return joint.length;\r\n}\r\n\r\n/**\r\n * @summary Enables or disables the limit constraint on a distance joint.\r\n * @function b2DistanceJoint_EnableLimit\r\n * @param {b2JointId} jointId - The identifier for the distance joint to modify.\r\n * @param {boolean} enableLimit - True to enable the joint's limit, false to disable it.\r\n * @returns {void}\r\n * @description\r\n * Sets the enable/disable state of the limit constraint for a distance joint.\r\n * The joint must be of type b2_distanceJoint or an error will occur.\r\n * @throws {Error} Throws an error if the joint type is not b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_EnableLimit(jointId, enableLimit)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n    joint.enableLimit = enableLimit;\r\n}\r\n\r\n/**\r\n * @summary Checks if the limit is enabled for a distance joint.\r\n * @function b2DistanceJoint_IsLimitEnabled\r\n * @param {b2JointId} jointId - The identifier for the distance joint to check.\r\n * @returns {boolean} True if the limit is enabled, false otherwise.\r\n * @throws {Error} Throws an error if the joint is not a distance joint.\r\n */\r\nexport function b2DistanceJoint_IsLimitEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return joint.distanceJoint.enableLimit;\r\n}\r\n\r\n/**\r\n * @function b2DistanceJoint_SetLengthRange\r\n * @description\r\n * Sets the minimum and maximum length constraints for a distance joint.\r\n * The values are clamped between b2_linearSlop and B2_HUGE.\r\n * The function resets all impulse values to zero after updating the length range.\r\n * @param {b2JointId} jointId - The identifier for the distance joint\r\n * @param {number} minLength - The minimum allowed length of the joint\r\n * @param {number} maxLength - The maximum allowed length of the joint\r\n * @returns {void}\r\n * @throws {Error} If the joint type is not b2_distanceJoint\r\n */\r\nexport function b2DistanceJoint_SetLengthRange(jointId, minLength, maxLength)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    minLength = b2ClampFloat(minLength, b2_linearSlop, B2_HUGE);\r\n    maxLength = b2ClampFloat(maxLength, b2_linearSlop, B2_HUGE);\r\n    joint.minLength = Math.min(minLength, maxLength);\r\n    joint.maxLength = Math.max(minLength, maxLength);\r\n    joint.impulse = 0.0;\r\n    joint.lowerImpulse = 0.0;\r\n    joint.upperImpulse = 0.0;\r\n}\r\n\r\n/**\r\n * Gets the minimum length of a distance joint.\r\n * @function b2DistanceJoint_GetMinLength\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The minimum length value of the distance joint.\r\n * @throws {Error} If the joint type is not b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_GetMinLength(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    return joint.minLength;\r\n}\r\n\r\n/**\r\n * Gets the maximum length of a distance joint.\r\n * @function b2DistanceJoint_GetMaxLength\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The maximum length value of the distance joint.\r\n * @throws {Error} If the joint is not of type b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_GetMaxLength(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    return joint.maxLength;\r\n}\r\n\r\n/**\r\n * @function b2DistanceJoint_GetCurrentLength\r\n * @param {b2JointId} jointId - The identifier for the distance joint\r\n * @returns {number} The current length between the two anchor points of the distance joint\r\n * @description\r\n * Calculates the current distance between the two anchor points of a distance joint\r\n * in world coordinates. The function transforms the local anchor points of both bodies\r\n * to world coordinates and computes the distance between them.\r\n * @throws {Error} Returns 0 if the world is locked\r\n */\r\nexport function b2DistanceJoint_GetCurrentLength(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    const world = b2GetWorld(jointId.world0);\r\n\r\n    if (world.locked)\r\n    {\r\n        return 0.0;\r\n    }\r\n\r\n    const transformA = b2GetBodyTransform(world, base.bodyIdA);\r\n    const transformB = b2GetBodyTransform(world, base.bodyIdB);\r\n\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n    const d = b2Sub(pB, pA);\r\n    const length = b2Length(d);\r\n\r\n    return length;\r\n}\r\n\r\n/**\r\n * @summary Enables or disables the spring behavior of a distance joint.\r\n * @function b2DistanceJoint_EnableSpring\r\n * @param {b2JointId} jointId - The identifier of the distance joint to modify.\r\n * @param {boolean} enableSpring - True to enable spring behavior, false to disable it.\r\n * @returns {void}\r\n * @description\r\n * Sets the spring behavior state of a distance joint. When enabled, the joint acts like\r\n * a spring between two bodies. When disabled, the joint maintains a fixed distance\r\n * between the connected bodies.\r\n * @throws {Error} Throws an error if the joint is not of type b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_EnableSpring(jointId, enableSpring)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    base.distanceJoint.enableSpring = enableSpring;\r\n}\r\n\r\n/**\r\n * @summary Checks if the spring mechanism is enabled for a distance joint.\r\n * @function b2DistanceJoint_IsSpringEnabled\r\n * @param {b2JointId} jointId - The identifier for the distance joint to check.\r\n * @returns {boolean} True if the spring mechanism is enabled, false otherwise.\r\n * @description\r\n * Returns the state of the spring enable flag for the specified distance joint.\r\n * The function validates that the joint is of type b2_distanceJoint before\r\n * accessing the spring enable property.\r\n * @throws {Error} Throws an error if the joint is not of type b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_IsSpringEnabled(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return base.distanceJoint.enableSpring;\r\n}\r\n\r\n/**\r\n * @summary Sets the spring frequency (hertz) of a distance joint.\r\n * @function b2DistanceJoint_SetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the distance joint to modify.\r\n * @param {number} hertz - The spring frequency in Hertz (oscillations per second).\r\n * @returns {void}\r\n * @description\r\n * Sets the spring oscillation frequency for a distance joint. The frequency\r\n * determines how quickly the spring oscillates when disturbed from equilibrium.\r\n * @throws {Error} Throws an error if the joint is not a distance joint.\r\n */\r\nexport function b2DistanceJoint_SetSpringHertz(jointId, hertz)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    base.distanceJoint.hertz = hertz;\r\n}\r\n\r\n/**\r\n * Sets the damping ratio for a distance joint's spring.\r\n * @function b2DistanceJoint_SetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the distance joint to modify\r\n * @param {number} dampingRatio - The damping ratio for the spring (0 = no damping, 1 = critical damping)\r\n * @returns {void}\r\n * @description\r\n * Sets the damping ratio parameter for a distance joint's spring mechanism.\r\n * The joint must be of type b2_distanceJoint.\r\n * @throws {Error} Throws if the joint type is not b2_distanceJoint\r\n */\r\nexport function b2DistanceJoint_SetSpringDampingRatio(jointId, dampingRatio)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    base.distanceJoint.dampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the hertz frequency parameter of a distance joint.\r\n * @function b2DistanceJoint_GetSpringHertz\r\n * @param {number} jointId - The identifier for the distance joint.\r\n * @returns {number} The hertz frequency value of the distance joint.\r\n * @throws {Error} If the joint is not a distance joint or the jointId is invalid.\r\n */\r\nexport function b2DistanceJoint_GetSpringHertz(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    return joint.hertz;\r\n}\r\n\r\n/**\r\n * Gets the damping ratio of a distance joint.\r\n * @function b2DistanceJoint_GetSpringDampingRatio\r\n * @param {number} jointId - The identifier for the distance joint.\r\n * @returns {number} The damping ratio of the distance joint.\r\n * @throws {Error} If the joint is not a distance joint or the jointId is invalid.\r\n */\r\nexport function b2DistanceJoint_GetSpringDampingRatio(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    const joint = base.distanceJoint;\r\n\r\n    return joint.dampingRatio;\r\n}\r\n\r\n/**\r\n * @function b2DistanceJoint_EnableMotor\r\n * @description\r\n * Enables or disables the motor on a distance joint. When the motor state changes,\r\n * the motor impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the distance joint\r\n * @param {boolean} enableMotor - True to enable the motor, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint is not a distance joint type\r\n */\r\nexport function b2DistanceJoint_EnableMotor(jointId, enableMotor)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    if (enableMotor !== joint.distanceJoint.enableMotor)\r\n    {\r\n        joint.distanceJoint.enableMotor = enableMotor;\r\n        joint.distanceJoint.motorImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the motor is enabled on a distance joint.\r\n * @function b2DistanceJoint_IsMotorEnabled\r\n * @param {b2JointId} jointId - The identifier for the distance joint to check.\r\n * @returns {boolean} True if the motor is enabled, false otherwise.\r\n * @throws {Error} Throws an error if the joint is not a distance joint.\r\n */\r\nexport function b2DistanceJoint_IsMotorEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return joint.distanceJoint.enableMotor;\r\n}\r\n\r\n/**\r\n * Sets the motor speed for a distance joint.\r\n * @function b2DistanceJoint_SetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the distance joint to modify.\r\n * @param {number} motorSpeed - The new motor speed value to set.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not a distance joint type.\r\n */\r\nexport function b2DistanceJoint_SetMotorSpeed(jointId, motorSpeed)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    joint.distanceJoint.motorSpeed = motorSpeed;\r\n}\r\n\r\n/**\r\n * Gets the motor speed of a distance joint.\r\n * @function b2DistanceJoint_GetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The current motor speed of the distance joint in radians per second.\r\n * @throws {Error} If the joint is not a distance joint or the joint ID is invalid.\r\n */\r\nexport function b2DistanceJoint_GetMotorSpeed(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return joint.distanceJoint.motorSpeed;\r\n}\r\n\r\n/**\r\n * Gets the current motor force for a distance joint.\r\n * @function b2DistanceJoint_GetMotorForce\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The current motor force in Newtons, calculated as the motor impulse divided by the step time.\r\n * @description\r\n * Calculates the motor force by dividing the joint's motor impulse by the inverse time step (inv_h).\r\n * The joint must be of type b2_distanceJoint.\r\n * @throws {Error} Throws if the joint type is not b2_distanceJoint.\r\n */\r\nexport function b2DistanceJoint_GetMotorForce(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return world.inv_h * base.distanceJoint.motorImpulse;\r\n}\r\n\r\n/**\r\n * Sets the maximum motor force for a distance joint.\r\n * @function b2DistanceJoint_SetMaxMotorForce\r\n * @param {b2JointId} jointId - The identifier for the distance joint to modify.\r\n * @param {number} force - The maximum force the motor can generate.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not a distance joint type.\r\n */\r\nexport function b2DistanceJoint_SetMaxMotorForce(jointId, force)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n    joint.distanceJoint.maxMotorForce = force;\r\n}\r\n\r\n/**\r\n * Gets the maximum motor force of a distance joint.\r\n * @function b2DistanceJoint_GetMaxMotorForce\r\n * @param {b2JointId} jointId - The identifier for the distance joint.\r\n * @returns {number} The maximum force that can be applied by the joint's motor.\r\n * @throws {Error} If the joint is not a distance joint or the joint ID is invalid.\r\n */\r\nexport function b2DistanceJoint_GetMaxMotorForce(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_distanceJoint);\r\n\r\n    return joint.distanceJoint.maxMotorForce;\r\n}\r\n\r\nexport function b2GetDistanceJointForce(world, base)\r\n{\r\n    const joint = base.distanceJoint;\r\n\r\n    const transformA = b2GetBodyTransform(world, base.bodyIdA);\r\n    const transformB = b2GetBodyTransform(world, base.bodyIdB);\r\n\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n    const d = b2Sub(pB, pA);\r\n    const axis = b2Normalize(d);\r\n    const force = (joint.impulse + joint.lowerImpulse - joint.upperImpulse + joint.motorImpulse) * world.inv_h;\r\n\r\n    return b2MulSV(force, axis);\r\n}\r\n\r\nexport function b2PrepareDistanceJoint(base, context)\r\n{\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n\r\n    const joint = base.distanceJoint;\r\n\r\n    joint.indexA = bodyA.setIndex === b2SetType.b2_awakeSet ? bodyA.localIndex : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex === b2SetType.b2_awakeSet ? bodyB.localIndex : B2_NULL_INDEX;\r\n\r\n    joint.anchorA = b2RotateVector(bodySimA.transform.q, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(bodySimB.transform.q, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.deltaCenter = b2Sub(bodySimB.center, bodySimA.center);\r\n\r\n    const rA = joint.anchorA;\r\n    const rB = joint.anchorB;\r\n    const separation = b2Add(b2Sub(rB, rA), joint.deltaCenter);\r\n    const axis = b2Normalize(separation);\r\n\r\n    const crA = b2Cross(rA, axis);\r\n    const crB = b2Cross(rB, axis);\r\n    const k = mA + mB + iA * crA * crA + iB * crB * crB;\r\n    joint.axialMass = k > 0.0 ? 1.0 / k : 0.0;\r\n\r\n    joint.distanceSoftness = b2MakeSoft(joint.hertz, joint.dampingRatio, context.h);\r\n\r\n    if (context.enableWarmStarting === false)\r\n    {\r\n        joint.impulse = 0.0;\r\n        joint.lowerImpulse = 0.0;\r\n        joint.upperImpulse = 0.0;\r\n        joint.motorImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartDistanceJoint(base, context)\r\n{\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.distanceJoint;\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const ds = b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), b2Sub(rB, rA));\r\n    const separation = b2Add(joint.deltaCenter, ds);\r\n    const axis = b2Normalize(separation);\r\n\r\n    const axialImpulse = joint.impulse + joint.lowerImpulse - joint.upperImpulse + joint.motorImpulse;\r\n    const P = b2MulSV(axialImpulse, axis);\r\n\r\n    stateA.linearVelocity = b2MulSub(stateA.linearVelocity, mA, P);\r\n    stateA.angularVelocity -= iA * b2Cross(rA, P);\r\n    stateB.linearVelocity = b2MulAdd(stateB.linearVelocity, mB, P);\r\n    stateB.angularVelocity += iB * b2Cross(rB, P);\r\n}\r\n\r\nexport function b2SolveDistanceJoint(base, context, useBias)\r\n{\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.distanceJoint;\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    let vA = stateA.linearVelocity;\r\n    let wA = stateA.angularVelocity;\r\n    let vB = stateB.linearVelocity;\r\n    let wB = stateB.angularVelocity;\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const ds = b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), b2Sub(rB, rA));\r\n    const separation = b2Add(joint.deltaCenter, ds);\r\n\r\n    const length = b2Length(separation);\r\n    const axis = b2Normalize(separation);\r\n\r\n    if (joint.enableSpring && (joint.minLength < joint.maxLength || joint.enableLimit === false))\r\n    {\r\n        if (joint.hertz > 0.0)\r\n        {\r\n            const vr = b2Add(b2Sub(vB, vA), b2Sub(b2CrossSV(wB, rB), b2CrossSV(wA, rA)));\r\n            const Cdot = b2Dot(axis, vr);\r\n            const C = length - joint.length;\r\n            const bias = joint.distanceSoftness.biasRate * C;\r\n\r\n            const m = joint.distanceSoftness.massScale * joint.axialMass;\r\n            const impulse = -m * (Cdot + bias) - joint.distanceSoftness.impulseScale * joint.impulse;\r\n            joint.impulse += impulse;\r\n\r\n            const P = b2MulSV(impulse, axis);\r\n            vA = b2MulSub(vA, mA, P);\r\n            wA -= iA * b2Cross(rA, P);\r\n            vB = b2MulAdd(vB, mB, P);\r\n            wB += iB * b2Cross(rB, P);\r\n        }\r\n\r\n        if (joint.enableLimit)\r\n        {\r\n            {\r\n                const vr = b2Add(b2Sub(vB, vA), b2Sub(b2CrossSV(wB, rB), b2CrossSV(wA, rA)));\r\n                const Cdot = b2Dot(axis, vr);\r\n\r\n                const C = length - joint.minLength;\r\n\r\n                let bias = 0.0;\r\n                let massCoeff = 1.0;\r\n                let impulseCoeff = 0.0;\r\n\r\n                if (C > 0.0)\r\n                {\r\n                    bias = C * context.inv_h;\r\n                }\r\n                else if (useBias)\r\n                {\r\n                    bias = context.jointSoftness.biasRate * C;\r\n                    massCoeff = context.jointSoftness.massScale;\r\n                    impulseCoeff = context.jointSoftness.impulseScale;\r\n                }\r\n\r\n                const impulse = -massCoeff * joint.axialMass * (Cdot + bias) - impulseCoeff * joint.lowerImpulse;\r\n                const newImpulse = Math.max(0.0, joint.lowerImpulse + impulse);\r\n                const deltaImpulse = newImpulse - joint.lowerImpulse;\r\n                joint.lowerImpulse = newImpulse;\r\n\r\n                const P = b2MulSV(deltaImpulse, axis);\r\n                vA = b2MulSub(vA, mA, P);\r\n                wA -= iA * b2Cross(rA, P);\r\n                vB = b2MulAdd(vB, mB, P);\r\n                wB += iB * b2Cross(rB, P);\r\n            }\r\n\r\n            {\r\n                const vr = b2Add(b2Sub(vA, vB), b2Sub(b2CrossSV(wA, rA), b2CrossSV(wB, rB)));\r\n                const Cdot = b2Dot(axis, vr);\r\n\r\n                const C = joint.maxLength - length;\r\n\r\n                let bias = 0.0;\r\n                let massScale = 1.0;\r\n                let impulseScale = 0.0;\r\n\r\n                if (C > 0.0)\r\n                {\r\n                    bias = C * context.inv_h;\r\n                }\r\n                else if (useBias)\r\n                {\r\n                    bias = context.jointSoftness.biasRate * C;\r\n                    massScale = context.jointSoftness.massScale;\r\n                    impulseScale = context.jointSoftness.impulseScale;\r\n                }\r\n\r\n                const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.upperImpulse;\r\n                const newImpulse = Math.max(0.0, joint.upperImpulse + impulse);\r\n                const deltaImpulse = newImpulse - joint.upperImpulse;\r\n                joint.upperImpulse = newImpulse;\r\n\r\n                const P = b2MulSV(-deltaImpulse, axis);\r\n                vA = b2MulSub(vA, mA, P);\r\n                wA -= iA * b2Cross(rA, P);\r\n                vB = b2MulAdd(vB, mB, P);\r\n                wB += iB * b2Cross(rB, P);\r\n            }\r\n        }\r\n\r\n        if (joint.enableMotor)\r\n        {\r\n            const vr = b2Add(b2Sub(vB, vA), b2Sub(b2CrossSV(wB, rB), b2CrossSV(wA, rA)));\r\n            const Cdot = b2Dot(axis, vr);\r\n            const impulse = joint.axialMass * (joint.motorSpeed - Cdot);\r\n            const oldImpulse = joint.motorImpulse;\r\n            const maxImpulse = context.h * joint.maxMotorForce;\r\n            joint.motorImpulse = b2ClampFloat(joint.motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n            const deltaImpulse = joint.motorImpulse - oldImpulse;\r\n\r\n            const P = b2MulSV(deltaImpulse, axis);\r\n            vA = b2MulSub(vA, mA, P);\r\n            wA -= iA * b2Cross(rA, P);\r\n            vB = b2MulAdd(vB, mB, P);\r\n            wB += iB * b2Cross(rB, P);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const vr = b2Add(b2Sub(vB, vA), b2Sub(b2CrossSV(wB, rB), b2CrossSV(wA, rA)));\r\n        const Cdot = b2Dot(axis, vr);\r\n\r\n        const C = length - joint.length;\r\n\r\n        let bias = 0.0;\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias)\r\n        {\r\n            bias = context.jointSoftness.biasRate * C;\r\n            massScale = context.jointSoftness.massScale;\r\n            impulseScale = context.jointSoftness.impulseScale;\r\n        }\r\n\r\n        const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.impulse;\r\n        joint.impulse += impulse;\r\n\r\n        const P = b2MulSV(impulse, axis);\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * b2Cross(rA, P);\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * b2Cross(rB, P);\r\n    }\r\n\r\n    stateA.linearVelocity = vA;\r\n    stateA.angularVelocity = wA;\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n\r\nexport function b2DrawDistanceJoint(draw, base, transformA, transformB)\r\n{\r\n    const joint = base.distanceJoint;\r\n\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n\r\n    const axis = b2Normalize(b2Sub(pB, pA));\r\n\r\n    if (joint.minLength < joint.maxLength && joint.enableLimit)\r\n    {\r\n        const pMin = b2MulAdd(pA, joint.minLength, axis);\r\n        const pMax = b2MulAdd(pA, joint.maxLength, axis);\r\n        const offset = b2MulSV(0.05 * b2_lengthUnitsPerMeter, b2RightPerp(axis));\r\n\r\n        if (joint.minLength > b2_linearSlop)\r\n        {\r\n            draw.DrawSegment(b2Sub(pMin, offset), b2Add(pMin, offset), b2HexColor.b2_colorLightGreen, draw.context);\r\n        }\r\n\r\n        if (joint.maxLength < B2_HUGE)\r\n        {\r\n            draw.DrawSegment(b2Sub(pMax, offset), b2Add(pMax, offset), b2HexColor.b2_colorRed, draw.context);\r\n        }\r\n\r\n        if (joint.minLength > b2_linearSlop && joint.maxLength < B2_HUGE)\r\n        {\r\n            draw.DrawSegment(pMin, pMax, b2HexColor.b2_colorGray, draw.context);\r\n        }\r\n    }\r\n\r\n    draw.DrawSegment(pA, pB, b2HexColor.b2_colorWhite, draw.context);\r\n    draw.DrawPoint(pA.x, pA.y, 4.0, b2HexColor.b2_colorWhite, draw.context);\r\n    draw.DrawPoint(pB.x, pB.y, 4.0, b2HexColor.b2_colorWhite, draw.context);\r\n\r\n    if (joint.hertz > 0.0 && joint.enableSpring)\r\n    {\r\n        const pRest = b2MulAdd(pA, joint.length, axis);\r\n        draw.DrawPoint(pRest.x, pRest.y, 4.0, b2HexColor.b2_colorBlue, draw.context);\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2Dot,\r\n    b2LeftPerp,\r\n    b2Mat22,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2RelativeAngle,\r\n    b2RotateVector,\r\n    b2Solve22,\r\n    b2Sub,\r\n    b2TransformPoint,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\nimport { b2BodyState, b2GetBodyTransform } from './include/body_h.js';\r\nimport { b2GetWorld, b2SetType } from './include/world_h.js';\r\nimport { b2HexColor, b2JointType } from './include/types_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2GetJointSimCheckType } from './include/joint_h.js';\r\nimport { b2MakeSoft } from './include/solver_h.js';\r\n\r\n/**\r\n * @namespace PrismaticJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * @function b2PrismaticJoint_EnableSpring\r\n * @summary Enables or disables the spring functionality of a prismatic joint.\r\n * @param {b2JointId} jointId - The identifier of the prismatic joint to modify.\r\n * @param {boolean} enableSpring - Whether to enable (true) or disable (false) the spring.\r\n * @returns {void}\r\n * @description\r\n * Sets the spring state of a prismatic joint. When the spring state changes,\r\n * the spring impulse is reset to zero. If the state doesn't change, no action is taken.\r\n * @throws {Error} Throws if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_EnableSpring(jointId, enableSpring)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    if (enableSpring !== joint.prismaticJoint.enableSpring)\r\n    {\r\n        joint.prismaticJoint.enableSpring = enableSpring;\r\n        joint.prismaticJoint.springImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the spring mechanism is enabled for a prismatic joint.\r\n * @function b2PrismaticJoint_IsSpringEnabled\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint to check.\r\n * @returns {boolean} True if the spring mechanism is enabled, false otherwise.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_IsSpringEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.enableSpring;\r\n}\r\n\r\n/**\r\n * @summary Sets the spring frequency (in Hertz) for a prismatic joint.\r\n * @function b2PrismaticJoint_SetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint to modify.\r\n * @param {number} hertz - The spring frequency in Hertz.\r\n * @returns {void}\r\n * @description\r\n * Updates the spring frequency of a prismatic joint. The joint must be of type b2_prismaticJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_SetSpringHertz(jointId, hertz)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n    joint.prismaticJoint.hertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the spring frequency in Hertz for a prismatic joint.\r\n * @function b2PrismaticJoint_GetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The spring frequency in Hertz.\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetSpringHertz(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.hertz;\r\n}\r\n\r\n/**\r\n * @summary Sets the damping ratio for a prismatic joint's spring.\r\n * @function b2PrismaticJoint_SetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @param {number} dampingRatio - The damping ratio for the spring.\r\n * @returns {void}\r\n * @description\r\n * Sets the spring damping ratio for a prismatic joint. The joint must be of type b2_prismaticJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_SetSpringDampingRatio(jointId, dampingRatio)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n    joint.prismaticJoint.dampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the spring damping ratio of a prismatic joint.\r\n * @function b2PrismaticJoint_GetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The spring damping ratio value.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetSpringDampingRatio(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.dampingRatio;\r\n}\r\n\r\n/**\r\n * @function b2PrismaticJoint_EnableLimit\r\n * @description\r\n * Enables or disables the translation limits on a prismatic joint. When the limit is disabled,\r\n * the joint's limit impulses are reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint\r\n * @param {boolean} enableLimit - True to enable the translation limit, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint identified by jointId is not a prismatic joint\r\n */\r\nexport function b2PrismaticJoint_EnableLimit(jointId, enableLimit)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    if (enableLimit !== joint.prismaticJoint.enableLimit)\r\n    {\r\n        joint.prismaticJoint.enableLimit = enableLimit;\r\n        joint.prismaticJoint.lowerImpulse = 0.0;\r\n        joint.prismaticJoint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the limit is enabled for a prismatic joint.\r\n * @function b2PrismaticJoint_IsLimitEnabled\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint to check.\r\n * @returns {boolean} True if the limit is enabled for the joint, false otherwise.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_IsLimitEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.enableLimit;\r\n}\r\n\r\n/**\r\n * @summary Gets the lower translation limit of a prismatic joint.\r\n * @function b2PrismaticJoint_GetLowerLimit\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The lower translation limit of the prismatic joint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetLowerLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.lowerTranslation;\r\n}\r\n\r\n/**\r\n * @function b2PrismaticJoint_GetUpperLimit\r\n * @summary Gets the upper translation limit of a prismatic joint.\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The upper translation limit of the prismatic joint.\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetUpperLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.upperTranslation;\r\n}\r\n\r\n/**\r\n * Sets the translation limits for a prismatic joint.\r\n * @function b2PrismaticJoint_SetLimits\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @param {number} lower - The lower translation limit.\r\n * @param {number} upper - The upper translation limit.\r\n * @returns {void}\r\n * @description\r\n * Sets new translation limits for a prismatic joint. The function automatically\r\n * orders the limits so that the lower value is always less than or equal to\r\n * the upper value. When the limits change, the joint's impulses are reset to zero.\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_SetLimits(jointId, lower, upper)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    if (lower !== joint.prismaticJoint.lowerTranslation || upper !== joint.prismaticJoint.upperTranslation)\r\n    {\r\n        joint.prismaticJoint.lowerTranslation = Math.min(lower, upper);\r\n        joint.prismaticJoint.upperTranslation = Math.max(lower, upper);\r\n        joint.prismaticJoint.lowerImpulse = 0.0;\r\n        joint.prismaticJoint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2PrismaticJoint_EnableMotor\r\n * @description\r\n * Enables or disables the motor on a prismatic joint. When the motor is disabled,\r\n * the motor impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint\r\n * @param {boolean} enableMotor - True to enable the motor, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint\r\n */\r\nexport function b2PrismaticJoint_EnableMotor(jointId, enableMotor)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    if (enableMotor !== joint.prismaticJoint.enableMotor)\r\n    {\r\n        joint.prismaticJoint.enableMotor = enableMotor;\r\n        joint.prismaticJoint.motorImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the motor is enabled on a prismatic joint.\r\n * @function b2PrismaticJoint_IsMotorEnabled\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint to check.\r\n * @returns {boolean} True if the motor is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_IsMotorEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.enableMotor;\r\n}\r\n\r\n/**\r\n * @summary Sets the motor speed for a prismatic joint.\r\n * @function b2PrismaticJoint_SetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint to modify.\r\n * @param {number} motorSpeed - The desired motor speed in radians per second.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_SetMotorSpeed(jointId, motorSpeed)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n    joint.prismaticJoint.motorSpeed = motorSpeed;\r\n}\r\n\r\n/**\r\n * Gets the motor speed of a prismatic joint.\r\n * @function b2PrismaticJoint_GetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The current motor speed of the prismatic joint.\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetMotorSpeed(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.motorSpeed;\r\n}\r\n\r\n/**\r\n * @function b2PrismaticJoint_GetMotorForce\r\n * @param {b2JointId} jointId - The ID of the prismatic joint\r\n * @returns {number} The current motor force in Newtons\r\n * @description\r\n * Gets the current motor force of a prismatic joint. The force is calculated by\r\n * multiplying the joint's motor impulse by the inverse of the world's time step.\r\n * @throws {Error} Throws if the joint type is not a prismatic joint\r\n */\r\nexport function b2PrismaticJoint_GetMotorForce(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return world.inv_h * base.prismaticJoint.motorImpulse;\r\n}\r\n\r\n/**\r\n * Sets the maximum motor force for a prismatic joint.\r\n * @function b2PrismaticJoint_SetMaxMotorForce\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @param {number} force - The maximum force the motor can apply.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_SetMaxMotorForce(jointId, force)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n    joint.prismaticJoint.maxMotorForce = force;\r\n}\r\n\r\n/**\r\n * Gets the maximum motor force of a prismatic joint.\r\n * @function b2PrismaticJoint_GetMaxMotorForce\r\n * @param {b2JointId} jointId - The identifier for the prismatic joint.\r\n * @returns {number} The maximum force that can be applied by the joint's motor.\r\n * @throws {Error} If the joint is not of type b2_prismaticJoint.\r\n */\r\nexport function b2PrismaticJoint_GetMaxMotorForce(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_prismaticJoint);\r\n\r\n    return joint.prismaticJoint.maxMotorForce;\r\n}\r\n\r\nexport function b2GetPrismaticJointForce(world, base)\r\n{\r\n    const idA = base.bodyIdA;\r\n    const transformA = b2GetBodyTransform(world, idA);\r\n\r\n    const joint = base.prismaticJoint;\r\n\r\n    const axisA = b2RotateVector(transformA.q, joint.localAxisA);\r\n    const perpA = b2LeftPerp(axisA);\r\n\r\n    const inv_h = world.inv_h;\r\n    const perpForce = inv_h * joint.impulse.x;\r\n    const axialForce = inv_h * (joint.motorImpulse + joint.lowerImpulse - joint.upperImpulse);\r\n\r\n    const force = b2Add(b2MulSV(perpForce, perpA), b2MulSV(axialForce, axisA));\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetPrismaticJointTorque(world, base)\r\n{\r\n    return world.inv_h * base.prismaticJoint.impulse.y;\r\n}\r\n\r\n// Linear constraint (point-to-line)\r\n// d = p2 - p1 = x2 + r2 - x1 - r1\r\n// C = dot(perp, d)\r\n// Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 - cross(w1, r1))\r\n//      = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) + dot(cross(r2, perp), v2)\r\n// J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\r\n//\r\n// Angular constraint\r\n// C = a2 - a1 + a_initial\r\n// Cdot = w2 - w1\r\n// J = [0 0 -1 0 0 1]\r\n//\r\n// K = J * invM * JT\r\n//\r\n// J = [-a -s1 a s2]\r\n//     [0  -1  0  1]\r\n// a = perp\r\n// s1 = cross(d + r1, a) = cross(p2 - x1, a)\r\n// s2 = cross(r2, a) = cross(p2 - x2, a)\r\n\r\n// Motor/Limit linear constraint\r\n// C = dot(ax1, d)\r\n// Cdot = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)\r\n// J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\r\n\r\n// Predictive limit is applied even when the limit is not active.\r\n// Prevents a constraint speed that can lead to a constraint error in one time step.\r\n// Want C2 = C1 + h * Cdot >= 0\r\n// Or:\r\n// Cdot + C1/h >= 0\r\n// I do not apply a negative constraint error because that is handled in position correction.\r\n// So:\r\n// Cdot + max(C1, 0)/h >= 0\r\n\r\n// Block Solver\r\n// We develop a block solver that includes the angular and linear constraints. This makes the limit stiffer.\r\n//\r\n// The Jacobian has 2 rows:\r\n// J = [-uT -s1 uT s2] // linear\r\n//     [0   -1   0  1] // angular\r\n//\r\n// u = perp\r\n// s1 = cross(d + r1, u), s2 = cross(r2, u)\r\n// a1 = cross(d + r1, v), a2 = cross(r2, v)\r\n\r\nexport function b2PreparePrismaticJoint(base, context)\r\n{\r\n    // Comment out B2_ASSERT\r\n    console.assert(base.type == b2JointType.b2_prismaticJoint);\r\n\r\n    // chase body id to the solver set where the body lives\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    // Comment out b2CheckIndex\r\n    // b2CheckIndex(bodies, idA);\r\n    // b2CheckIndex(bodies, idB);\r\n\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n\r\n    // Comment out B2_ASSERT\r\n    console.assert(bodyA.setIndex == b2SetType.b2_awakeSet || bodyB.setIndex == b2SetType.b2_awakeSet);\r\n\r\n    // b2CheckIndex(world.solverSetArray, bodyA.setIndex);\r\n    // b2CheckIndex(world.solverSetArray, bodyB.setIndex);\r\n\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n\r\n    const localIndexA = bodyA.localIndex;\r\n    const localIndexB = bodyB.localIndex;\r\n\r\n    // Comment out B2_ASSERT\r\n    console.assert(0 <= localIndexA && localIndexA <= setA.sims.count);\r\n    console.assert(0 <= localIndexB && localIndexB <= setB.sims.count);\r\n\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n\r\n    const joint = base.prismaticJoint;\r\n    joint.indexA = bodyA.setIndex == b2SetType.b2_awakeSet ? localIndexA : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex == b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n\r\n    const qA = bodySimA.transform.q;\r\n    const qB = bodySimB.transform.q;\r\n\r\n    joint.anchorA = b2RotateVector(qA, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(qB, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.axisA = b2RotateVector(qA, joint.localAxisA);\r\n    joint.deltaCenter = b2Sub(bodySimB.center, bodySimA.center);\r\n    joint.deltaAngle = b2RelativeAngle(qB, qA) - joint.referenceAngle;\r\n\r\n    const rA = joint.anchorA;\r\n    const rB = joint.anchorB;\r\n\r\n    const d = b2Add(joint.deltaCenter, b2Sub(rB, rA));\r\n    const a1 = b2Cross(b2Add(d, rA), joint.axisA);\r\n    const a2 = b2Cross(rB, joint.axisA);\r\n\r\n    // effective masses\r\n    const k = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n    joint.axialMass = k > 0.0 ? 1.0 / k : 0.0;\r\n\r\n    joint.springSoftness = b2MakeSoft(joint.hertz, joint.dampingRatio, context.h);\r\n\r\n    if (context.enableWarmStarting == false)\r\n    {\r\n        joint.impulse = new b2Vec2(0, 0);\r\n        joint.springImpulse = 0.0;\r\n        joint.motorImpulse = 0.0;\r\n        joint.lowerImpulse = 0.0;\r\n        joint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartPrismaticJoint(base, context)\r\n{\r\n    // Comment out B2_ASSERT\r\n    console.assert(base.type == b2JointType.b2_prismaticJoint);\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.prismaticJoint;\r\n\r\n    const stateA = joint.indexA == B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB == B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const d = b2Add(b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), joint.deltaCenter), b2Sub(rB, rA));\r\n    const axisA = b2RotateVector(stateA.deltaRotation, joint.axisA);\r\n\r\n    // impulse is applied at anchor point on body B\r\n    const a1 = b2Cross(b2Add(d, rA), axisA);\r\n    const a2 = b2Cross(rB, axisA);\r\n    const axialImpulse = joint.springImpulse + joint.motorImpulse + joint.lowerImpulse - joint.upperImpulse;\r\n\r\n    // perpendicular constraint\r\n    const perpA = b2LeftPerp(axisA);\r\n    const s1 = b2Cross(b2Add(d, rA), perpA);\r\n    const s2 = b2Cross(rB, perpA);\r\n    const perpImpulse = joint.impulse.x;\r\n    const angleImpulse = joint.impulse.y;\r\n\r\n    const P = b2Add(b2MulSV(axialImpulse, axisA), b2MulSV(perpImpulse, perpA));\r\n    const LA = axialImpulse * a1 + perpImpulse * s1 + angleImpulse;\r\n    const LB = axialImpulse * a2 + perpImpulse * s2 + angleImpulse;\r\n\r\n    stateA.linearVelocity = b2MulSub(stateA.linearVelocity, mA, P);\r\n    stateA.angularVelocity -= iA * LA;\r\n    stateB.linearVelocity = b2MulAdd(stateB.linearVelocity, mB, P);\r\n    stateB.angularVelocity += iB * LB;\r\n}\r\n\r\nexport function b2SolvePrismaticJoint(base, context, useBias)\r\n{\r\n    console.assert(base.type == b2JointType.b2_prismaticJoint);\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.prismaticJoint;\r\n\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    let vA = stateA.linearVelocity;\r\n    let wA = stateA.angularVelocity;\r\n    let vB = stateB.linearVelocity;\r\n    let wB = stateB.angularVelocity;\r\n\r\n    // current anchors\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const d = b2Add(b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), joint.deltaCenter), b2Sub(rB, rA));\r\n    const axisA = b2RotateVector(stateA.deltaRotation, joint.axisA);\r\n    const translation = b2Dot(axisA, d);\r\n\r\n    // These scalars are for torques generated by axial forces\r\n    const a1 = b2Cross(b2Add(d, rA), axisA);\r\n    const a2 = b2Cross(rB, axisA);\r\n\r\n    // spring constraint\r\n    if (joint.enableSpring)\r\n    {\r\n        const C = translation;\r\n        const bias = joint.springSoftness.biasRate * C;\r\n        const massScale = joint.springSoftness.massScale;\r\n        const impulseScale = joint.springSoftness.impulseScale;\r\n\r\n        const Cdot = b2Dot(axisA, b2Sub(vB, vA)) + a2 * wB - a1 * wA;\r\n        const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.springImpulse;\r\n        joint.springImpulse += impulse;\r\n\r\n        const P = b2MulSV(impulse, axisA);\r\n        const LA = impulse * a1;\r\n        const LB = impulse * a2;\r\n\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * LA;\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * LB;\r\n    }\r\n\r\n    // Solve motor constraint\r\n    if (joint.enableMotor)\r\n    {\r\n        const Cdot = b2Dot(axisA, b2Sub(vB, vA)) + a2 * wB - a1 * wA;\r\n        let impulse = joint.axialMass * (joint.motorSpeed - Cdot);\r\n        const oldImpulse = joint.motorImpulse;\r\n        const maxImpulse = context.h * joint.maxMotorForce;\r\n        joint.motorImpulse = b2ClampFloat(joint.motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n        impulse = joint.motorImpulse - oldImpulse;\r\n\r\n        const P = b2MulSV(impulse, axisA);\r\n        const LA = impulse * a1;\r\n        const LB = impulse * a2;\r\n\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * LA;\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * LB;\r\n    }\r\n\r\n    if (joint.enableLimit)\r\n    {\r\n        // Lower limit\r\n        {\r\n            const C = translation - joint.lowerTranslation;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            const oldImpulse = joint.lowerImpulse;\r\n            const Cdot = b2Dot(axisA, b2Sub(vB, vA)) + a2 * wB - a1 * wA;\r\n            let impulse = -joint.axialMass * massScale * (Cdot + bias) - impulseScale * oldImpulse;\r\n            joint.lowerImpulse = Math.max(oldImpulse + impulse, 0.0);\r\n            impulse = joint.lowerImpulse - oldImpulse;\r\n\r\n            const P = b2MulSV(impulse, axisA);\r\n            const LA = impulse * a1;\r\n            const LB = impulse * a2;\r\n\r\n            vA = b2MulSub(vA, mA, P);\r\n            wA -= iA * LA;\r\n            vB = b2MulAdd(vB, mB, P);\r\n            wB += iB * LB;\r\n        }\r\n\r\n        // Upper limit\r\n        {\r\n            const C = joint.upperTranslation - translation;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            const oldImpulse = joint.upperImpulse;\r\n            const Cdot = b2Dot(axisA, b2Sub(vA, vB)) + a1 * wA - a2 * wB;\r\n            let impulse = -joint.axialMass * massScale * (Cdot + bias) - impulseScale * oldImpulse;\r\n            joint.upperImpulse = Math.max(oldImpulse + impulse, 0.0);\r\n            impulse = joint.upperImpulse - oldImpulse;\r\n\r\n            const P = b2MulSV(impulse, axisA);\r\n            const LA = impulse * a1;\r\n            const LB = impulse * a2;\r\n\r\n            vA = b2MulAdd(vA, mA, P);\r\n            wA += iA * LA;\r\n            vB = b2MulSub(vB, mB, P);\r\n            wB -= iB * LB;\r\n        }\r\n    }\r\n\r\n    // Solve the prismatic constraint in block form\r\n    {\r\n        const perpA = b2LeftPerp(axisA);\r\n\r\n        // These scalars are for torques generated by the perpendicular constraint force\r\n        const s1 = b2Cross(b2Add(d, rA), perpA);\r\n        const s2 = b2Cross(rB, perpA);\r\n\r\n        const Cdot = new b2Vec2(b2Dot(perpA, b2Sub(vB, vA)) + s2 * wB - s1 * wA, wB - wA);\r\n\r\n        let bias = new b2Vec2();\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias)\r\n        {\r\n            const C = new b2Vec2(b2Dot(perpA, d), b2RelativeAngle(stateB.deltaRotation, stateA.deltaRotation) + joint.deltaAngle);\r\n            bias = b2MulSV(context.jointSoftness.biasRate, C);\r\n            massScale = context.jointSoftness.massScale;\r\n            impulseScale = context.jointSoftness.impulseScale;\r\n        }\r\n\r\n        const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n        const k12 = iA * s1 + iB * s2;\r\n        let k22 = iA + iB;\r\n\r\n        if (k22 === 0.0)\r\n        {\r\n            // For bodies with fixed rotation.\r\n            k22 = 1.0;\r\n        }\r\n\r\n        const K = new b2Mat22(new b2Vec2(k11, k12), new b2Vec2(k12, k22));\r\n\r\n        const b = b2Solve22(K, b2Add(Cdot, bias));\r\n        const impulse = new b2Vec2(-massScale * b.x - impulseScale * joint.impulse.x, -massScale * b.y - impulseScale * joint.impulse.y);\r\n        joint.impulse.x += impulse.x;\r\n        joint.impulse.y += impulse.y;\r\n\r\n        const P = b2MulSV(impulse.x, perpA);\r\n        const LA = impulse.x * s1 + impulse.y;\r\n        const LB = impulse.x * s2 + impulse.y;\r\n\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * LA;\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * LB;\r\n    }\r\n\r\n    stateA.linearVelocity = vA;\r\n    stateA.angularVelocity = wA;\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n\r\nexport function b2DrawPrismaticJoint(draw, base, transformA, transformB)\r\n{\r\n    console.assert(base.type == b2JointType.b2_prismaticJoint);\r\n    const joint = base.prismaticJoint;\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n    const axis = b2RotateVector(transformA.q, joint.localAxisA);\r\n    const c1 = b2HexColor.b2_colorGray7;\r\n    const c2 = b2HexColor.b2_colorGreen;\r\n    const c3 = b2HexColor.b2_colorRed;\r\n    const c4 = b2HexColor.b2_colorBlue;\r\n    const c5 = b2HexColor.b2_colorGray4;\r\n\r\n    draw.DrawSegment(pA, pB, c5, draw.context);\r\n\r\n    if (joint.enableLimit)\r\n    {\r\n        const lower = b2MulAdd(pA, joint.lowerTranslation, axis);\r\n        const upper = b2MulAdd(pA, joint.upperTranslation, axis);\r\n        const perp = b2LeftPerp(axis);\r\n        draw.DrawSegment(lower, upper, c1, draw.context);\r\n        draw.DrawSegment(b2MulSub(lower, 0.1, perp), b2MulAdd(lower, 0.1, perp), c2, draw.context);\r\n        draw.DrawSegment(b2MulSub(upper, 0.1, perp), b2MulAdd(upper, 0.1, perp), c3, draw.context);\r\n    }\r\n    else\r\n    {\r\n        draw.DrawSegment(b2MulSub(pA, 1.0, axis), b2MulAdd(pA, 1.0, axis), c1, draw.context);\r\n    }\r\n\r\n    draw.DrawPoint(pA.x, pA.y, 5.0, c1, draw.context);\r\n    draw.DrawPoint(pB.x, pB.y, 5.0, c4, draw.context);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2CrossSV,\r\n    b2Mat22,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2RelativeAngle,\r\n    b2RotateVector,\r\n    b2Solve22,\r\n    b2Sub,\r\n    b2TransformPoint,\r\n    b2UnwindAngle,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\nimport { b2BodyState, b2GetBodyTransform } from './include/body_h.js';\r\nimport { b2GetWorld, b2SetType } from './include/world_h.js';\r\nimport { b2HexColor, b2JointType } from './include/types_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2GetJointSimCheckType } from './joint_c.js';\r\nimport { b2MakeSoft } from './include/solver_h.js';\r\n\r\n/**\r\n * @namespace RevoluteJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * @function b2RevoluteJoint_EnableSpring\r\n * @description\r\n * Enables or disables the spring functionality of a revolute joint.\r\n * When the spring state changes, the spring impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier of the revolute joint to modify\r\n * @param {boolean} enableSpring - True to enable the spring, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint\r\n */\r\nexport function b2RevoluteJoint_EnableSpring(jointId, enableSpring)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    if (enableSpring !== joint.revoluteJoint.enableSpring)\r\n    {\r\n        joint.revoluteJoint.enableSpring = enableSpring;\r\n        joint.revoluteJoint.springImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if spring functionality is enabled for a revolute joint.\r\n * @function b2RevoluteJoint_IsSpringEnabled\r\n * @param {b2JointId} jointId - The identifier for the revolute joint to check.\r\n * @returns {boolean} True if spring functionality is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_IsSpringEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.enableSpring;\r\n}\r\n\r\n/**\r\n * @summary Sets the spring frequency (in Hertz) for a revolute joint.\r\n * @function b2RevoluteJoint_SetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the revolute joint to modify.\r\n * @param {number} hertz - The spring frequency in Hertz (Hz).\r\n * @returns {void}\r\n * @description\r\n * Sets the spring oscillation frequency for a revolute joint. The joint must be\r\n * of type b2_revoluteJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_SetSpringHertz(jointId, hertz)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n    joint.revoluteJoint.hertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the spring frequency in Hertz for a revolute joint.\r\n * @function b2RevoluteJoint_GetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The spring frequency in Hertz.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetSpringHertz(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.hertz;\r\n}\r\n\r\n/**\r\n * Sets the damping ratio for a revolute joint's spring.\r\n * @function b2RevoluteJoint_SetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @param {number} dampingRatio - The damping ratio for the spring.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_SetSpringDampingRatio(jointId, dampingRatio)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n    joint.revoluteJoint.dampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the spring damping ratio of a revolute joint.\r\n * @function b2RevoluteJoint_GetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier of the revolute joint.\r\n * @returns {number} The spring damping ratio value of the revolute joint.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetSpringDampingRatio(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.dampingRatio;\r\n}\r\n\r\n/**\r\n * @function b2RevoluteJoint_GetAngle\r\n * @summary Gets the current angle between two bodies connected by a revolute joint.\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The current angle in radians between the two connected bodies,\r\n * relative to the reference angle.\r\n * @description\r\n * Calculates the relative angle between two bodies connected by a revolute joint by\r\n * comparing their transforms and subtracting the joint's reference angle. The result\r\n * is unwound to ensure consistent angle representation.\r\n */\r\nexport function b2RevoluteJoint_GetAngle(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const jointSim = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n    const transformA = b2GetBodyTransform(world, jointSim.bodyIdA);\r\n    const transformB = b2GetBodyTransform(world, jointSim.bodyIdB);\r\n\r\n    let angle = b2RelativeAngle(transformB.q, transformA.q) - jointSim.revoluteJoint.referenceAngle;\r\n    angle = b2UnwindAngle(angle);\r\n\r\n    return angle;\r\n}\r\n\r\n/**\r\n * @function b2RevoluteJoint_EnableLimit\r\n * @summary Enables or disables the joint angle limits for a revolute joint.\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @param {boolean} enableLimit - True to enable the joint limits, false to disable them.\r\n * @returns {void}\r\n * @description\r\n * When enabled, the joint will restrict rotation to be between its upper and lower angle limits.\r\n * When the limit state changes, the joint's limit impulses are reset to zero.\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_EnableLimit(jointId, enableLimit)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    if (enableLimit !== joint.revoluteJoint.enableLimit)\r\n    {\r\n        joint.revoluteJoint.enableLimit = enableLimit;\r\n        joint.revoluteJoint.lowerImpulse = 0.0;\r\n        joint.revoluteJoint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the limit is enabled for a revolute joint.\r\n * @function b2RevoluteJoint_IsLimitEnabled\r\n * @param {b2JointId} jointId - The identifier for the revolute joint to check.\r\n * @returns {boolean} True if the joint's limit is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_IsLimitEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.enableLimit;\r\n}\r\n\r\n/**\r\n * Gets the lower angle limit of a revolute joint.\r\n * @function b2RevoluteJoint_GetLowerLimit\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The lower angle limit in radians.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetLowerLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.lowerAngle;\r\n}\r\n\r\n/**\r\n * Gets the upper angle limit of a revolute joint.\r\n * @function b2RevoluteJoint_GetUpperLimit\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The upper angle limit in radians.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetUpperLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.upperAngle;\r\n}\r\n\r\n/**\r\n * @function b2RevoluteJoint_SetLimits\r\n * @description\r\n * Sets the lower and upper angle limits for a revolute joint. The function automatically\r\n * orders the limits so that the lower value is always less than or equal to the upper value.\r\n * When the limits change, the joint impulses are reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the revolute joint to modify\r\n * @param {number} lower - The lower angle limit in radians\r\n * @param {number} upper - The upper angle limit in radians\r\n * @returns {void}\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint\r\n */\r\nexport function b2RevoluteJoint_SetLimits(jointId, lower, upper)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    if (lower !== joint.revoluteJoint.lowerAngle || upper !== joint.revoluteJoint.upperAngle)\r\n    {\r\n        joint.revoluteJoint.lowerAngle = Math.min(lower, upper);\r\n        joint.revoluteJoint.upperAngle = Math.max(lower, upper);\r\n        joint.revoluteJoint.lowerImpulse = 0.0;\r\n        joint.revoluteJoint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2RevoluteJoint_EnableMotor\r\n * @description\r\n * Enables or disables the motor on a revolute joint. When the motor is disabled,\r\n * its accumulated impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the revolute joint\r\n * @param {boolean} enableMotor - True to enable the joint's motor, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint\r\n */\r\nexport function b2RevoluteJoint_EnableMotor(jointId, enableMotor)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    if (enableMotor !== joint.revoluteJoint.enableMotor)\r\n    {\r\n        joint.revoluteJoint.enableMotor = enableMotor;\r\n        joint.revoluteJoint.motorImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the motor is enabled on a revolute joint.\r\n * @function b2RevoluteJoint_IsMotorEnabled\r\n * @param {b2JointId} jointId - The identifier for the revolute joint to check.\r\n * @returns {boolean} True if the motor is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_IsMotorEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.enableMotor;\r\n}\r\n\r\n/**\r\n * @summary Sets the motor speed for a revolute joint.\r\n * @function b2RevoluteJoint_SetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @param {number} motorSpeed - The desired motor speed in radians per second.\r\n * @returns {void}\r\n * @description\r\n * Sets the angular velocity for the motor of a revolute joint. A positive velocity\r\n * means the joint will rotate counterclockwise.\r\n * @throws {Error} Throws an error if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_SetMotorSpeed(jointId, motorSpeed)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n    joint.revoluteJoint.motorSpeed = motorSpeed;\r\n}\r\n\r\n/**\r\n * Gets the motor speed of a revolute joint.\r\n * @function b2RevoluteJoint_GetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier of the revolute joint.\r\n * @returns {number} The current motor speed in radians per second.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetMotorSpeed(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.motorSpeed;\r\n}\r\n\r\n/**\r\n * @function b2RevoluteJoint_GetMotorTorque\r\n * @summary Gets the current motor torque of a revolute joint.\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The current motor torque in Newton-meters.\r\n * @description\r\n * Calculates the motor torque by multiplying the motor impulse by the inverse\r\n * of the time step. The joint must be of type b2_revoluteJoint.\r\n * @throws {Error} If the joint type is not b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetMotorTorque(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return world.inv_h * joint.revoluteJoint.motorImpulse;\r\n}\r\n\r\n/**\r\n * Sets the maximum motor torque for a revolute joint.\r\n * @function b2RevoluteJoint_SetMaxMotorTorque\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @param {number} torque - The maximum motor torque value to set.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_SetMaxMotorTorque(jointId, torque)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n    joint.revoluteJoint.maxMotorTorque = torque;\r\n}\r\n\r\n/**\r\n * Gets the maximum motor torque of a revolute joint.\r\n * @function b2RevoluteJoint_GetMaxMotorTorque\r\n * @param {b2JointId} jointId - The identifier for the revolute joint.\r\n * @returns {number} The maximum motor torque value.\r\n * @throws {Error} If the joint is not of type b2_revoluteJoint.\r\n */\r\nexport function b2RevoluteJoint_GetMaxMotorTorque(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_revoluteJoint);\r\n\r\n    return joint.revoluteJoint.maxMotorTorque;\r\n}\r\n\r\nexport function b2GetRevoluteJointForce(world, base)\r\n{\r\n    const force = b2MulSV(world.inv_h, base.revoluteJoint.linearImpulse);\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetRevoluteJointTorque(world, base)\r\n{\r\n    const revolute = base.revoluteJoint;\r\n    const torque = world.inv_h * (revolute.motorImpulse + revolute.lowerImpulse - revolute.upperImpulse);\r\n\r\n    return torque;\r\n}\r\n\r\n// Point-to-point constraint\r\n// C = p2 - p1\r\n// Cdot = v2 - v1\r\n//      = v2 + cross(w2, r2) - v1 - cross(w1, r1)\r\n// J = [-I -r1_skew I r2_skew ]\r\n// Identity used:\r\n// w k % (rx i + ry j) = w * (-ry i + rx j)\r\n\r\n// Motor constraint\r\n// Cdot = w2 - w1\r\n// J = [0 0 -1 0 0 1]\r\n// K = invI1 + invI2\r\n\r\n// Body State\r\n// The solver operates on the body state. The body state array does not hold static bodies. Static bodies are shared\r\n// across worker threads. It would be okay to read their states, but writing to them would cause cache thrashing across\r\n// workers, even if the values don't change.\r\n// This causes some trouble when computing anchors. I rotate the anchors using the body rotation every sub-step. For static\r\n// bodies the anchor doesn't rotate. Body A or B could be static and this can lead to lots of branching. This branching\r\n// should be minimized.\r\n//\r\n// Solution 1:\r\n// Use delta rotations. This means anchors need to be prepared in world space. The delta rotation for static bodies will be\r\n// identity. Base separation and angles need to be computed. Manifolds will be behind a frame, but that is probably best if bodies\r\n// move fast.\r\n//\r\n// Solution 2:\r\n// Use full rotation. The anchors for static bodies will be in world space while the anchors for dynamic bodies will be in local\r\n// space. Potentially confusing and bug prone.\r\n\r\nexport function b2PrepareRevoluteJoint(base, context)\r\n{\r\n    // chase body id to the solver set where the body lives\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n    console.assert( bodyA.setIndex == b2SetType.b2_awakeSet || bodyB.setIndex == b2SetType.b2_awakeSet, `bodyA.setIndex = ${bodyA.setIndex}, bodyB.setIndex = ${bodyB.setIndex}` );\r\n\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n    const localIndexA = bodyA.localIndex;\r\n    const localIndexB = bodyB.localIndex;\r\n\r\n    console.assert( 0 <= localIndexA && localIndexA <= setA.sims.count );\r\n    console.assert( 0 <= localIndexB && localIndexB <= setB.sims.count );\r\n\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n    const joint = base.revoluteJoint;\r\n    joint.indexA = bodyA.setIndex === b2SetType.b2_awakeSet ? localIndexA : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex === b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n\r\n    // initial anchors in world space\r\n    joint.anchorA = b2RotateVector(bodySimA.transform.q, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(bodySimB.transform.q, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.deltaCenter = b2Sub(bodySimB.center, bodySimA.center);\r\n    joint.deltaAngle = b2RelativeAngle(bodySimB.transform.q, bodySimA.transform.q) - joint.referenceAngle;\r\n    joint.deltaAngle = b2UnwindAngle(joint.deltaAngle); // yes, this does seem to be deliberate reuse (line 254: revolute_joint.c)\r\n\r\n    const k = iA + iB;\r\n    joint.axialMass = k > 0.0 ? 1.0 / k : 0.0;\r\n    joint.springSoftness = b2MakeSoft(joint.hertz, joint.dampingRatio, context.h);\r\n\r\n    if (context.enableWarmStarting === false)\r\n    {\r\n        joint.linearImpulse = new b2Vec2(0, 0);\r\n        joint.springImpulse = 0.0;\r\n        joint.motorImpulse = 0.0;\r\n        joint.lowerImpulse = 0.0;\r\n        joint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartRevoluteJoint(base, context)\r\n{\r\n    console.assert( base.type == b2JointType.b2_revoluteJoint );\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n    const joint = base.revoluteJoint;\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const axialImpulse = joint.springImpulse + joint.motorImpulse + joint.lowerImpulse - joint.upperImpulse;\r\n\r\n    stateA.linearVelocity = b2MulSub(stateA.linearVelocity, mA, joint.linearImpulse);\r\n    stateA.angularVelocity -= iA * (b2Cross(rA, joint.linearImpulse) + axialImpulse);\r\n\r\n    stateB.linearVelocity = b2MulAdd(stateB.linearVelocity, mB, joint.linearImpulse);\r\n    stateB.angularVelocity += iB * (b2Cross(rB, joint.linearImpulse) + axialImpulse);\r\n}\r\n\r\nexport function b2SolveRevoluteJoint(base, context, useBias)\r\n{\r\n    console.assert( base.type == b2JointType.b2_revoluteJoint );\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.revoluteJoint;\r\n\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    let vA = stateA.linearVelocity.clone();\r\n    let wA = stateA.angularVelocity;\r\n    let vB = stateB.linearVelocity.clone();\r\n    let wB = stateB.angularVelocity;\r\n\r\n    const fixedRotation = (iA + iB === 0.0);\r\n\r\n    // const float maxBias = context.maxBiasVelocity;\r\n\r\n    // Solve spring.\r\n    if (joint.enableSpring && fixedRotation === false)\r\n    {\r\n        const C = b2RelativeAngle(stateB.deltaRotation, stateA.deltaRotation) + joint.deltaAngle;\r\n        const bias = joint.springSoftness.biasRate * C;\r\n        const massScale = joint.springSoftness.massScale;\r\n        const impulseScale = joint.springSoftness.impulseScale;\r\n\r\n        const Cdot = wB - wA;\r\n        const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.springImpulse;\r\n        joint.springImpulse += impulse;\r\n\r\n        wA -= iA * impulse;\r\n        wB += iB * impulse;\r\n    }\r\n\r\n    // Solve motor constraint.\r\n    if (joint.enableMotor && fixedRotation === false)\r\n    {\r\n        const Cdot = wB - wA - joint.motorSpeed;\r\n        let impulse = -joint.axialMass * Cdot;\r\n        const oldImpulse = joint.motorImpulse;\r\n        const maxImpulse = context.h * joint.maxMotorTorque;\r\n        joint.motorImpulse = b2ClampFloat(joint.motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n        impulse = joint.motorImpulse - oldImpulse;\r\n\r\n        wA -= iA * impulse;\r\n        wB += iB * impulse;\r\n    }\r\n\r\n    if (joint.enableLimit && fixedRotation === false)\r\n    {\r\n        let jointAngle = b2RelativeAngle(stateB.deltaRotation, stateA.deltaRotation) + joint.deltaAngle;\r\n        jointAngle = b2UnwindAngle(jointAngle);\r\n\r\n        // Lower limit\r\n        {\r\n            const C = jointAngle - joint.lowerAngle;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            const Cdot = wB - wA;\r\n            let impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.lowerImpulse;\r\n            const oldImpulse = joint.lowerImpulse;\r\n            joint.lowerImpulse = Math.max(joint.lowerImpulse + impulse, 0.0);\r\n            impulse = joint.lowerImpulse - oldImpulse;\r\n\r\n            wA -= iA * impulse;\r\n            wB += iB * impulse;\r\n        }\r\n\r\n        // Upper limit\r\n        // Note: signs are flipped to keep C positive when the constraint is satisfied.\r\n        // This also keeps the impulse positive when the limit is active.\r\n        {\r\n            const C = joint.upperAngle - jointAngle;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            // sign flipped on Cdot\r\n            const Cdot = wA - wB;\r\n            let impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.lowerImpulse;\r\n            const oldImpulse = joint.upperImpulse;\r\n            joint.upperImpulse = Math.max(joint.upperImpulse + impulse, 0.0);\r\n            impulse = joint.upperImpulse - oldImpulse;\r\n\r\n            // sign flipped on applied impulse\r\n            wA += iA * impulse;\r\n            wB -= iB * impulse;\r\n        }\r\n    }\r\n\r\n    // Solve point-to-point constraint\r\n    {\r\n        // current anchors\r\n        const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n        const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n        const Cdot = b2Sub(b2Add(vB, b2CrossSV(wB, rB)), b2Add(vA, b2CrossSV(wA, rA)));\r\n\r\n        let bias = new b2Vec2(0, 0);\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias)\r\n        {\r\n            const dcA = stateA.deltaPosition;\r\n            const dcB = stateB.deltaPosition;\r\n\r\n            const separation = b2Add(b2Add(b2Sub(dcB, dcA), b2Sub(rB, rA)), joint.deltaCenter);\r\n            bias = b2MulSV(context.jointSoftness.biasRate, separation);\r\n            massScale = context.jointSoftness.massScale;\r\n            impulseScale = context.jointSoftness.impulseScale;\r\n        }\r\n\r\n        const K = new b2Mat22(\r\n            new b2Vec2(0, 0),\r\n            new b2Vec2(0, 0)\r\n        );\r\n        K.cx.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\r\n        K.cy.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\r\n        K.cx.y = K.cy.x;\r\n        K.cy.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\r\n        const b = b2Solve22(K, b2Add(Cdot, bias));\r\n\r\n        const impulse = new b2Vec2(\r\n            -massScale * b.x - impulseScale * joint.linearImpulse.x,\r\n            -massScale * b.y - impulseScale * joint.linearImpulse.y\r\n        );\r\n        joint.linearImpulse.x += impulse.x;\r\n        joint.linearImpulse.y += impulse.y;\r\n\r\n        vA = b2MulSub(vA, mA, impulse);\r\n        wA -= iA * b2Cross(rA, impulse);\r\n        vB = b2MulAdd(vB, mB, impulse);\r\n        wB += iB * b2Cross(rB, impulse);\r\n    }\r\n\r\n    stateA.linearVelocity = vA;\r\n    stateA.angularVelocity = wA;\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n\r\n/*\r\nNOTE: unconverted C original function\r\n\r\nvoid b2RevoluteJoint::Dump()\r\n{\r\n    int32 indexA = joint.bodyA.joint.islandIndex;\r\n    int32 indexB = joint.bodyB.joint.islandIndex;\r\n\r\n    b2Dump(\"  b2RevoluteJointDef jd;\\n\");\r\n    b2Dump(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n    b2Dump(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n    b2Dump(\"  jd.collideConnected = bool(%d);\\n\", joint.collideConnected);\r\n    b2Dump(\"  jd.localAnchorA.Set(%.9g, %.9g);\\n\", joint.localAnchorA.x, joint.localAnchorA.y);\r\n    b2Dump(\"  jd.localAnchorB.Set(%.9g, %.9g);\\n\", joint.localAnchorB.x, joint.localAnchorB.y);\r\n    b2Dump(\"  jd.referenceAngle = %.9g;\\n\", joint.referenceAngle);\r\n    b2Dump(\"  jd.enableLimit = bool(%d);\\n\", joint.enableLimit);\r\n    b2Dump(\"  jd.lowerAngle = %.9g;\\n\", joint.lowerAngle);\r\n    b2Dump(\"  jd.upperAngle = %.9g;\\n\", joint.upperAngle);\r\n    b2Dump(\"  jd.enableMotor = bool(%d);\\n\", joint.enableMotor);\r\n    b2Dump(\"  jd.motorSpeed = %.9g;\\n\", joint.motorSpeed);\r\n    b2Dump(\"  jd.maxMotorTorque = %.9g;\\n\", joint.maxMotorTorque);\r\n    b2Dump(\"  joints[%d] = joint.world.CreateJoint(&jd);\\n\", joint.,,index);\r\n}\r\n * @memberof RevoluteJoint\r\n */\r\nexport function b2DrawRevoluteJoint(draw, base, transformA, transformB, drawSize)\r\n{\r\n\r\n    console.assert( base.type == b2JointType.b2_revoluteJoint );\r\n\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n\r\n    const c1 = b2HexColor.b2_colorRed;\r\n\r\n    // let c2 = b2HexColor.b2_colorGreen;\r\n    // let c3 = b2HexColor.b2_colorRed;\r\n\r\n    const L = drawSize;\r\n    draw.DrawCircle(pB, L, c1, draw.context);\r\n\r\n    const angle = b2RelativeAngle(transformB.q, transformA.q);\r\n\r\n    const r = new b2Vec2(L * Math.cos(angle), L * Math.sin(angle));\r\n\r\n    const pC = b2Add(pB, r);\r\n    draw.DrawSegment(pB, pC, c1, draw.context);\r\n\r\n    // if (draw.drawJointExtras) {\r\n    //     let jointAngle = b2UnwindAngle(angle - joint.referenceAngle);\r\n    //     let buffer = ` ${(180.0 * jointAngle / Math.PI).toFixed(1)} deg`;\r\n    //     draw.DrawString(pC, buffer, draw.context);\r\n    // }\r\n\r\n    // let lowerAngle = joint.lowerAngle + joint.referenceAngle;\r\n    // let upperAngle = joint.upperAngle + joint.referenceAngle;\r\n\r\n    // if (joint.enableLimit) {\r\n    //     const rlo = new b2Vec2(L * Math.cos(lowerAngle), L * Math.sin(lowerAngle));\r\n    //     const rhi = new b2Vec2(L * Math.cos(upperAngle), L * Math.sin(upperAngle));\r\n\r\n\r\n    //     draw.DrawSegment(pB, b2Add(pB, rlo), c2, draw.context);\r\n    //     draw.DrawSegment(pB, b2Add(pB, rhi), c3, draw.context);\r\n\r\n    //     const ref = new b2Vec2(L * Math.cos(joint.referenceAngle), L * Math.sin(joint.referenceAngle));\r\n\r\n    //     draw.DrawSegment(pB, b2Add(pB, ref), b2HexColor.b2_colorBlue, draw.context);\r\n    // }\r\n\r\n    const color = b2HexColor.b2_colorGold;\r\n    draw.DrawSegment(transformA.p, pA, color, draw.context);\r\n    draw.DrawSegment(pA, pB, color, draw.context);\r\n    draw.DrawSegment(transformB.p, pB, color, draw.context);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Add, b2ClampFloat, b2Cross, b2Dot, b2LeftPerp, b2MulAdd, b2MulSV, b2MulSub, b2RotateVector, b2Sub, b2TransformPoint } from './include/math_functions_h.js';\r\nimport { b2GetWorld, b2SetType } from './include/world_h.js';\r\nimport { b2HexColor, b2JointType } from './include/types_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2BodyState } from './include/body_h.js';\r\nimport { b2GetJointSimCheckType } from './include/joint_h.js';\r\nimport { b2MakeSoft } from './include/solver_h.js';\r\n\r\n/**\r\n * @namespace WheelJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * @function b2WheelJoint_EnableSpring\r\n * @description\r\n * Enables or disables the spring functionality of a wheel joint. When the spring state\r\n * changes, the spring impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to modify\r\n * @param {boolean} enableSpring - True to enable the spring, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint identified by jointId is not a wheel joint\r\n */\r\nexport function b2WheelJoint_EnableSpring(jointId, enableSpring)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    if (enableSpring !== joint.wheelJoint.enableSpring)\r\n    {\r\n        joint.wheelJoint.enableSpring = enableSpring;\r\n        joint.wheelJoint.springImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the spring mechanism is enabled for a wheel joint.\r\n * @function b2WheelJoint_IsSpringEnabled\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to check.\r\n * @returns {boolean} True if the spring is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_IsSpringEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.enableSpring;\r\n}\r\n\r\n/**\r\n * @summary Sets the spring frequency for a wheel joint.\r\n * @function b2WheelJoint_SetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to modify.\r\n * @param {number} hertz - The spring frequency in Hertz (Hz).\r\n * @returns {void}\r\n * @description\r\n * Sets the spring frequency for a wheel joint's oscillation. The frequency is specified\r\n * in Hertz (Hz). The joint must be of type b2_wheelJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_wheelJoint.\r\n */\r\nexport function b2WheelJoint_SetSpringHertz(jointId, hertz)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n    joint.wheelJoint.hertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the spring frequency in Hertz for a wheel joint.\r\n * @function b2WheelJoint_GetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The spring frequency in Hertz.\r\n * @throws {Error} If the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_GetSpringHertz(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.hertz;\r\n}\r\n\r\n/**\r\n * Sets the damping ratio for a wheel joint's spring.\r\n * @function b2WheelJoint_SetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to modify\r\n * @param {number} dampingRatio - The damping ratio for the spring (0 = no damping, 1 = critical damping)\r\n * @returns {void}\r\n * @throws {Error} If the joint is not a wheel joint type\r\n */\r\nexport function b2WheelJoint_SetSpringDampingRatio(jointId, dampingRatio)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n    joint.wheelJoint.dampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the damping ratio of a wheel joint's spring.\r\n * @function b2WheelJoint_GetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The spring damping ratio value.\r\n * @throws {Error} Throws if the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_GetSpringDampingRatio(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.dampingRatio;\r\n}\r\n\r\n/**\r\n * @function b2WheelJoint_EnableLimit\r\n * @summary Enables or disables the joint's translation limit.\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @param {boolean} enableLimit - True to enable the translation limit, false to disable it.\r\n * @returns {void}\r\n * @description\r\n * Sets whether the wheel joint's translation limit is active. When the limit is enabled,\r\n * the joint's translation will be constrained. When the limit state changes, the joint's\r\n * lower and upper impulses are reset to zero.\r\n * @throws {Error} Throws if the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_EnableLimit(jointId, enableLimit)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    if (joint.wheelJoint.enableLimit !== enableLimit)\r\n    {\r\n        joint.wheelJoint.lowerImpulse = 0.0;\r\n        joint.wheelJoint.upperImpulse = 0.0;\r\n        joint.wheelJoint.enableLimit = enableLimit;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the limit is enabled for a wheel joint.\r\n * @function b2WheelJoint_IsLimitEnabled\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to check.\r\n * @returns {boolean} True if the limit is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not a wheel joint.\r\n */\r\nexport function b2WheelJoint_IsLimitEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.enableLimit;\r\n}\r\n\r\n/**\r\n * Gets the lower translation limit of a wheel joint.\r\n * @function b2WheelJoint_GetLowerLimit\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The lower translation limit of the wheel joint.\r\n * @throws {Error} If the joint is not a wheel joint or the jointId is invalid.\r\n */\r\nexport function b2WheelJoint_GetLowerLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.lowerTranslation;\r\n}\r\n\r\n/**\r\n * Gets the upper translation limit of a wheel joint.\r\n * @function b2WheelJoint_GetUpperLimit\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The upper translation limit of the wheel joint.\r\n * @throws {Error} If the joint is not a wheel joint or the joint ID is invalid.\r\n */\r\nexport function b2WheelJoint_GetUpperLimit(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.upperTranslation;\r\n}\r\n\r\n/**\r\n * @function b2WheelJoint_SetLimits\r\n * @summary Sets the translation limits for a wheel joint.\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @param {number} lower - The lower translation limit.\r\n * @param {number} upper - The upper translation limit.\r\n * @returns {void}\r\n * @description\r\n * Sets new translation limits for a wheel joint. The function automatically orders\r\n * the limits so that the lower value is always less than or equal to the upper value.\r\n * When the limits change, the joint's impulses are reset to zero.\r\n * @throws {Error} If the provided jointId does not reference a valid wheel joint.\r\n */\r\nexport function b2WheelJoint_SetLimits(jointId, lower, upper)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    if (lower !== joint.wheelJoint.lowerTranslation || upper !== joint.wheelJoint.upperTranslation)\r\n    {\r\n        joint.wheelJoint.lowerTranslation = Math.min(lower, upper);\r\n        joint.wheelJoint.upperTranslation = Math.max(lower, upper);\r\n        joint.wheelJoint.lowerImpulse = 0.0;\r\n        joint.wheelJoint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2WheelJoint_EnableMotor\r\n * @description\r\n * Enables or disables the motor on a wheel joint. When the motor state changes,\r\n * the motor impulse is reset to zero.\r\n * @param {b2JointId} jointId - The identifier for the wheel joint\r\n * @param {boolean} enableMotor - True to enable the motor, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the joint is not a wheel joint type\r\n */\r\nexport function b2WheelJoint_EnableMotor(jointId, enableMotor)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    if (joint.wheelJoint.enableMotor !== enableMotor)\r\n    {\r\n        joint.wheelJoint.motorImpulse = 0.0;\r\n        joint.wheelJoint.enableMotor = enableMotor;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if the motor is enabled on a wheel joint.\r\n * @function b2WheelJoint_IsMotorEnabled\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to check.\r\n * @returns {boolean} True if the motor is enabled, false otherwise.\r\n * @throws {Error} Throws if the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_IsMotorEnabled(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.enableMotor;\r\n}\r\n\r\n/**\r\n * @summary Sets the motor speed for a wheel joint.\r\n * @function b2WheelJoint_SetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the wheel joint to modify.\r\n * @param {number} motorSpeed - The desired motor speed in radians per second.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_SetMotorSpeed(jointId, motorSpeed)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n    joint.wheelJoint.motorSpeed = motorSpeed;\r\n}\r\n\r\n/**\r\n * Gets the motor speed of a wheel joint.\r\n * @function b2WheelJoint_GetMotorSpeed\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The current motor speed of the wheel joint in radians per second.\r\n * @throws {Error} If the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_GetMotorSpeed(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.motorSpeed;\r\n}\r\n\r\n/**\r\n * @function b2WheelJoint_GetMotorTorque\r\n * @summary Gets the current motor torque of a wheel joint.\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The current motor torque normalized by the step time (N\u22C5m).\r\n * @description\r\n * Calculates the motor torque by multiplying the motor impulse by the inverse\r\n * of the time step. The joint must be of type b2_wheelJoint.\r\n * @throws {Error} Throws if the joint type is not b2_wheelJoint.\r\n */\r\nexport function b2WheelJoint_GetMotorTorque(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return world.inv_h * joint.wheelJoint.motorImpulse;\r\n}\r\n\r\n/**\r\n * @summary Sets the maximum motor torque for a wheel joint.\r\n * @function b2WheelJoint_SetMaxMotorTorque\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @param {number} torque - The maximum motor torque value to set.\r\n * @returns {void}\r\n * @description\r\n * Sets the maximum torque that can be applied by the wheel joint's motor.\r\n * The joint must be of type b2_wheelJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_wheelJoint.\r\n */\r\nexport function b2WheelJoint_SetMaxMotorTorque(jointId, torque)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n    joint.wheelJoint.maxMotorTorque = torque;\r\n}\r\n\r\n/**\r\n * Gets the maximum motor torque of a wheel joint.\r\n * @function b2WheelJoint_GetMaxMotorTorque\r\n * @param {b2JointId} jointId - The identifier for the wheel joint.\r\n * @returns {number} The maximum motor torque value.\r\n * @throws {Error} If the joint is not a wheel joint type.\r\n */\r\nexport function b2WheelJoint_GetMaxMotorTorque(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_wheelJoint);\r\n\r\n    return joint.wheelJoint.maxMotorTorque;\r\n}\r\n\r\nexport function b2GetWheelJointForce(world, base)\r\n{\r\n    const joint = base.wheelJoint;\r\n\r\n    const axisA = joint.axisA;\r\n    const perpA = b2LeftPerp(axisA);\r\n\r\n    const perpForce = world.inv_h * joint.perpImpulse;\r\n    const axialForce = world.inv_h * (joint.springImpulse + joint.lowerImpulse - joint.upperImpulse);\r\n\r\n    const force = b2Add(b2MulSV(perpForce, perpA), b2MulSV(axialForce, axisA));\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetWheelJointTorque(world, base)\r\n{\r\n    return world.inv_h * base.wheelJoint.motorImpulse;\r\n}\r\n\r\n// Linear constraint (point-to-line)\r\n// d = pB - pA = xB + rB - xA - rA\r\n// C = dot(ay, d)\r\n// Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA, rA))\r\n//      = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB, ay), vB)\r\n// J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\r\n\r\n// Spring linear constraint\r\n// C = dot(ax, d)\r\n// Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) + dot(cross(rB, ax), vB)\r\n// J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\r\n\r\n// Motor rotational constraint\r\n// Cdot = wB - wA\r\n// J = [0 0 -1 0 0 1]\r\n\r\nexport function b2PrepareWheelJoint(base, context)\r\n{\r\n    console.assert(base.type == b2JointType.b2_wheelJoint);\r\n\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    // b2CheckIndex(bodies, idA);\r\n    // b2CheckIndex(bodies, idB);\r\n\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n\r\n    console.assert(bodyA.setIndex == b2SetType.b2_awakeSet || bodyB.setIndex == b2SetType.b2_awakeSet);\r\n\r\n    // b2CheckIndex(world.solverSetArray, bodyA.setIndex);\r\n    // b2CheckIndex(world.solverSetArray, bodyB.setIndex);\r\n\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n\r\n    const localIndexA = bodyA.localIndex;\r\n    const localIndexB = bodyB.localIndex;\r\n\r\n    console.assert(0 <= localIndexA && localIndexA <= setA.sims.count);\r\n    console.assert(0 <= localIndexB && localIndexB <= setB.sims.count);\r\n\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n\r\n    const joint = base.wheelJoint;\r\n\r\n    joint.indexA = bodyA.setIndex == b2SetType.b2_awakeSet ? localIndexA : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex == b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n\r\n    const qA = bodySimA.transform.q;\r\n    const qB = bodySimB.transform.q;\r\n\r\n    joint.anchorA = b2RotateVector(qA, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(qB, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.axisA = b2RotateVector(qA, joint.localAxisA);\r\n    joint.deltaCenter = b2Sub(bodySimB.center, bodySimA.center);\r\n\r\n    const rA = joint.anchorA;\r\n    const rB = joint.anchorB;\r\n\r\n    const d = b2Add(joint.deltaCenter, b2Sub(rB, rA));\r\n    const axisA = joint.axisA;\r\n    const perpA = b2LeftPerp(axisA);\r\n\r\n    const s1 = b2Cross(b2Add(d, rA), perpA);\r\n    const s2 = b2Cross(rB, perpA);\r\n\r\n    const kp = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n    joint.perpMass = kp > 0.0 ? 1.0 / kp : 0.0;\r\n\r\n    const a1 = b2Cross(b2Add(d, rA), axisA);\r\n    const a2 = b2Cross(rB, axisA);\r\n\r\n    const ka = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n    joint.axialMass = ka > 0.0 ? 1.0 / ka : 0.0;\r\n\r\n    joint.springSoftness = b2MakeSoft(joint.hertz, joint.dampingRatio, context.h);\r\n\r\n    const km = iA + iB;\r\n    joint.motorMass = km > 0.0 ? 1.0 / km : 0.0;\r\n\r\n    if (context.enableWarmStarting == false)\r\n    {\r\n        joint.perpImpulse = 0.0;\r\n        joint.springImpulse = 0.0;\r\n        joint.motorImpulse = 0.0;\r\n        joint.lowerImpulse = 0.0;\r\n        joint.upperImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartWheelJoint(base, context)\r\n{\r\n    console.assert(base.type == b2JointType.b2_wheelJoint);\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.wheelJoint;\r\n\r\n    const stateA = joint.indexA == B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB == B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const d = b2Add(b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), joint.deltaCenter), b2Sub(rB, rA));\r\n    const axisA = b2RotateVector(stateA.deltaRotation, joint.axisA);\r\n    const perpA = b2LeftPerp(axisA);\r\n\r\n    const a1 = b2Cross(b2Add(d, rA), axisA);\r\n    const a2 = b2Cross(rB, axisA);\r\n    const s1 = b2Cross(b2Add(d, rA), perpA);\r\n    const s2 = b2Cross(rB, perpA);\r\n\r\n    const axialImpulse = joint.springImpulse + joint.lowerImpulse - joint.upperImpulse;\r\n\r\n    const P = b2Add(b2MulSV(axialImpulse, axisA), b2MulSV(joint.perpImpulse, perpA));\r\n    const LA = axialImpulse * a1 + joint.perpImpulse * s1 + joint.motorImpulse;\r\n    const LB = axialImpulse * a2 + joint.perpImpulse * s2 + joint.motorImpulse;\r\n\r\n    stateA.linearVelocity = b2MulSub(stateA.linearVelocity, mA, P);\r\n    stateA.angularVelocity -= iA * LA;\r\n    stateB.linearVelocity = b2MulAdd(stateB.linearVelocity, mB, P);\r\n    stateB.angularVelocity += iB * LB;\r\n}\r\n\r\nexport function b2SolveWheelJoint(base, context, useBias)\r\n{\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.wheelJoint;\r\n\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    let vA = stateA.linearVelocity;\r\n    let wA = stateA.angularVelocity;\r\n    let vB = stateB.linearVelocity;\r\n    let wB = stateB.angularVelocity;\r\n\r\n    const fixedRotation = (iA + iB === 0.0);\r\n\r\n    // current anchors\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    const d = b2Add(b2Add(b2Sub(stateB.deltaPosition, stateA.deltaPosition), joint.deltaCenter), b2Sub(rB, rA));\r\n    const axisA = b2RotateVector(stateA.deltaRotation, joint.axisA);\r\n    const translation = b2Dot(axisA, d);\r\n\r\n    const a1 = b2Cross(b2Add(d, rA), axisA);\r\n    const a2 = b2Cross(rB, axisA);\r\n\r\n    // motor constraint\r\n    if (joint.enableMotor && fixedRotation === false)\r\n    {\r\n        const Cdot = wB - wA - joint.motorSpeed;\r\n        let impulse = -joint.motorMass * Cdot;\r\n        const oldImpulse = joint.motorImpulse;\r\n        const maxImpulse = context.h * joint.maxMotorTorque;\r\n        joint.motorImpulse = b2ClampFloat(joint.motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n        impulse = joint.motorImpulse - oldImpulse;\r\n\r\n        wA -= iA * impulse;\r\n        wB += iB * impulse;\r\n    }\r\n\r\n    // spring constraint\r\n    if (joint.enableSpring)\r\n    {\r\n        const C = translation;\r\n        const bias = joint.springSoftness.biasRate * C;\r\n        const massScale = joint.springSoftness.massScale;\r\n        const impulseScale = joint.springSoftness.impulseScale;\r\n\r\n        const Cdot = b2Dot(axisA, b2Sub(vB, vA)) + a2 * wB - a1 * wA;\r\n        const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.springImpulse;\r\n        joint.springImpulse += impulse;\r\n\r\n        const P = b2MulSV(impulse, axisA);\r\n        const LA = impulse * a1;\r\n        const LB = impulse * a2;\r\n\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * LA;\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * LB;\r\n    }\r\n\r\n    if (joint.enableLimit)\r\n    {\r\n        const translation = b2Dot(axisA, d);\r\n\r\n        // Lower limit\r\n        {\r\n            const C = translation - joint.lowerTranslation;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            const Cdot = b2Dot(axisA, b2Sub(vB, vA)) + a2 * wB - a1 * wA;\r\n            let impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.lowerImpulse;\r\n            const oldImpulse = joint.lowerImpulse;\r\n            joint.lowerImpulse = Math.max(oldImpulse + impulse, 0.0);\r\n            impulse = joint.lowerImpulse - oldImpulse;\r\n\r\n            const P = b2MulSV(impulse, axisA);\r\n            const LA = impulse * a1;\r\n            const LB = impulse * a2;\r\n\r\n            vA = b2MulSub(vA, mA, P);\r\n            wA -= iA * LA;\r\n            vB = b2MulAdd(vB, mB, P);\r\n            wB += iB * LB;\r\n        }\r\n\r\n        // Upper limit\r\n        {\r\n            const C = joint.upperTranslation - translation;\r\n            let bias = 0.0;\r\n            let massScale = 1.0;\r\n            let impulseScale = 0.0;\r\n\r\n            if (C > 0.0)\r\n            {\r\n                // speculation\r\n                bias = C * context.inv_h;\r\n            }\r\n            else if (useBias)\r\n            {\r\n                bias = context.jointSoftness.biasRate * C;\r\n                massScale = context.jointSoftness.massScale;\r\n                impulseScale = context.jointSoftness.impulseScale;\r\n            }\r\n\r\n            const Cdot = b2Dot(axisA, b2Sub(vA, vB)) + a1 * wA - a2 * wB;\r\n            let impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.upperImpulse;\r\n            const oldImpulse = joint.upperImpulse;\r\n            joint.upperImpulse = Math.max(oldImpulse + impulse, 0.0);\r\n            impulse = joint.upperImpulse - oldImpulse;\r\n\r\n            const P = b2MulSV(impulse, axisA);\r\n            const LA = impulse * a1;\r\n            const LB = impulse * a2;\r\n\r\n            vA = b2MulAdd(vA, mA, P);\r\n            wA += iA * LA;\r\n            vB = b2MulSub(vB, mB, P);\r\n            wB -= iB * LB;\r\n        }\r\n    }\r\n\r\n    // point to line constraint\r\n    {\r\n        const perpA = b2LeftPerp(axisA);\r\n\r\n        let bias = 0.0;\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias)\r\n        {\r\n            const C = b2Dot(perpA, d);\r\n            bias = context.jointSoftness.biasRate * C;\r\n            massScale = context.jointSoftness.massScale;\r\n            impulseScale = context.jointSoftness.impulseScale;\r\n        }\r\n\r\n        const s1 = b2Cross(b2Add(d, rA), perpA);\r\n        const s2 = b2Cross(rB, perpA);\r\n        const Cdot = b2Dot(perpA, b2Sub(vB, vA)) + s2 * wB - s1 * wA;\r\n\r\n        const impulse = -massScale * joint.perpMass * (Cdot + bias) - impulseScale * joint.perpImpulse;\r\n        joint.perpImpulse += impulse;\r\n\r\n        const P = b2MulSV(impulse, perpA);\r\n        const LA = impulse * s1;\r\n        const LB = impulse * s2;\r\n\r\n        vA = b2MulSub(vA, mA, P);\r\n        wA -= iA * LA;\r\n        vB = b2MulAdd(vB, mB, P);\r\n        wB += iB * LB;\r\n    }\r\n\r\n    stateA.linearVelocity = vA;\r\n    stateA.angularVelocity = wA;\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n\r\n/*\r\nNOTE: unconverted C code\r\n\r\nvoid b2WheelJoint_Dump()\r\n{\r\n\tint32 indexA = joint.bodyA.joint.islandIndex;\r\n\tint32 indexB = joint.bodyB.joint.islandIndex;\r\n\r\n\tb2Dump(\"  b2WheelJointDef jd;\\n\");\r\n\tb2Dump(\"  jd.bodyA = sims[%d];\\n\", indexA);\r\n\tb2Dump(\"  jd.bodyB = sims[%d];\\n\", indexB);\r\n\tb2Dump(\"  jd.collideConnected = bool(%d);\\n\", joint.collideConnected);\r\n\tb2Dump(\"  jd.localAnchorA.Set(%.9g, %.9g);\\n\", joint.localAnchorA.x, joint.localAnchorA.y);\r\n\tb2Dump(\"  jd.localAnchorB.Set(%.9g, %.9g);\\n\", joint.localAnchorB.x, joint.localAnchorB.y);\r\n\tb2Dump(\"  jd.referenceAngle = %.9g;\\n\", joint.referenceAngle);\r\n\tb2Dump(\"  jd.enableLimit = bool(%d);\\n\", joint.enableLimit);\r\n\tb2Dump(\"  jd.lowerAngle = %.9g;\\n\", joint.lowerAngle);\r\n\tb2Dump(\"  jd.upperAngle = %.9g;\\n\", joint.upperAngle);\r\n\tb2Dump(\"  jd.enableMotor = bool(%d);\\n\", joint.enableMotor);\r\n\tb2Dump(\"  jd.motorSpeed = %.9g;\\n\", joint.motorSpeed);\r\n\tb2Dump(\"  jd.maxMotorTorque = %.9g;\\n\", joint.maxMotorTorque);\r\n\tb2Dump(\"  joints[%d] = joint.world.CreateJoint(&jd);\\n\", joint.index);\r\n}\r\n */\r\n\r\nexport function b2DrawWheelJoint(draw, base, transformA, transformB)\r\n{\r\n    console.assert( base.type == b2JointType.b2_wheelJoint );\r\n\r\n    const joint = base.wheelJoint;\r\n\r\n    const pA = b2TransformPoint(transformA, base.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, base.localOriginAnchorB);\r\n    const axis = b2RotateVector(transformA.q, joint.localAxisA);\r\n\r\n    const c1 = b2HexColor.b2_colorGray7;\r\n    const c2 = b2HexColor.b2_colorGreen;\r\n    const c3 = b2HexColor.b2_colorRed;\r\n    const c4 = b2HexColor.b2_colorGray4;\r\n    const c5 = b2HexColor.b2_colorBlue;\r\n\r\n    draw.DrawSegment(pA, pB, c5, draw.context);\r\n\r\n    if (joint.enableLimit)\r\n    {\r\n        const lower = b2MulAdd(pA, joint.lowerTranslation, axis);\r\n        const upper = b2MulAdd(pA, joint.upperTranslation, axis);\r\n        const perp = b2LeftPerp(axis);\r\n        draw.DrawSegment(lower, upper, c1, draw.context);\r\n        draw.DrawSegment(b2MulSub(lower, 0.1, perp), b2MulAdd(lower, 0.1, perp), c2, draw.context);\r\n        draw.DrawSegment(b2MulSub(upper, 0.1, perp), b2MulAdd(upper, 0.1, perp), c3, draw.context);\r\n    }\r\n    else\r\n    {\r\n        draw.DrawSegment(b2MulSub(pA, 1.0, axis), b2MulAdd(pA, 1.0, axis), c1, draw.context);\r\n    }\r\n\r\n    draw.DrawPoint(pA.x, pA.y, 5.0, c1, draw.context);\r\n    draw.DrawPoint(pB.x, pB.y, 5.0, c4, draw.context);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    B2_PI,\r\n    b2Add,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2CrossSV,\r\n    b2GetInverse22,\r\n    b2LengthSquared,\r\n    b2Mat22,\r\n    b2MulAdd,\r\n    b2MulMV,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2Normalize,\r\n    b2RelativeAngle,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2UnwindAngle,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2BodyState } from './include/body_h.js';\r\nimport { b2GetJointSimCheckType } from './include/joint_h.js';\r\nimport { b2JointType } from './include/types_h.js';\r\nimport { b2SetType } from './include/world_h.js';\r\n\r\n/**\r\n * @namespace MotorJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * @summary Sets the target linear offset for a motor joint.\r\n * @function b2MotorJoint_SetLinearOffset\r\n * @param {b2JointId} jointId - The identifier for the motor joint to modify.\r\n * @param {b2Vec2} linearOffset - The desired linear offset in local coordinates.\r\n * @returns {void}\r\n * @description\r\n * Updates the target linear offset of a motor joint. The linear offset represents\r\n * the desired translation between the two bodies connected by the joint.\r\n * @throws {Error} Throws if the joint is not a motor joint or if the jointId is invalid.\r\n */\r\nexport function b2MotorJoint_SetLinearOffset(jointId, linearOffset)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n    joint.motorJoint.linearOffset = linearOffset;\r\n}\r\n\r\n/**\r\n * Gets the linear offset of a motor joint.\r\n * @function b2MotorJoint_GetLinearOffset\r\n * @param {b2JointId} jointId - The identifier of the motor joint.\r\n * @returns {b2Vec2} The linear offset vector of the motor joint.\r\n * @throws {Error} If the joint is not a motor joint or the joint ID is invalid.\r\n */\r\nexport function b2MotorJoint_GetLinearOffset(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n\r\n    return joint.motorJoint.linearOffset;\r\n}\r\n\r\n/**\r\n * @summary Sets the target angular offset for a motor joint.\r\n * @function b2MotorJoint_SetAngularOffset\r\n * @param {b2JointId} jointId - The identifier for the motor joint to modify.\r\n * @param {number} angularOffset - The desired angular offset in radians, clamped between -\u03C0 and \u03C0.\r\n * @returns {void}\r\n * @description\r\n * Sets the target angular offset for a motor joint, which defines the desired relative rotation\r\n * between the connected bodies. The input angle is automatically clamped to the range [-\u03C0, \u03C0].\r\n * @throws {Error} Throws if the joint is not a motor joint type.\r\n */\r\nexport function b2MotorJoint_SetAngularOffset(jointId, angularOffset)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n    joint.motorJoint.angularOffset = b2ClampFloat(angularOffset, -B2_PI, B2_PI);\r\n}\r\n\r\n/**\r\n * @summary Gets the angular offset of a motor joint.\r\n * @function b2MotorJoint_GetAngularOffset\r\n * @param {b2JointId} jointId - The identifier of the motor joint.\r\n * @returns {number} The angular offset value of the motor joint in radians.\r\n * @throws {Error} Throws if the joint is not a motor joint or if the joint ID is invalid.\r\n */\r\nexport function b2MotorJoint_GetAngularOffset(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n\r\n    return joint.motorJoint.angularOffset;\r\n}\r\n\r\n/**\r\n * Sets the maximum force that can be applied by a motor joint.\r\n * @function b2MotorJoint_SetMaxForce\r\n * @param {b2JointId} jointId - The identifier for the motor joint\r\n * @param {number} maxForce - The maximum force value to set. Will be clamped to non-negative values.\r\n * @returns {void}\r\n * @throws {Error} If the joint is not a motor joint type\r\n */\r\nexport function b2MotorJoint_SetMaxForce(jointId, maxForce)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n    joint.motorJoint.maxForce = Math.max(0.0, maxForce);\r\n}\r\n\r\n/**\r\n * Gets the maximum force value from a motor joint.\r\n * @function b2MotorJoint_GetMaxForce\r\n * @param {b2JointId} jointId - The identifier for the motor joint.\r\n * @returns {number} The maximum force value of the motor joint.\r\n * @throws {Error} If the joint is not of type b2_motorJoint.\r\n */\r\nexport function b2MotorJoint_GetMaxForce(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n\r\n    return joint.motorJoint.maxForce;\r\n}\r\n\r\n/**\r\n * Sets the maximum torque that can be applied by a motor joint.\r\n * @function b2MotorJoint_SetMaxTorque\r\n * @param {b2JointId} jointId - The identifier for the motor joint.\r\n * @param {number} maxTorque - The maximum torque value. Will be clamped to non-negative values.\r\n * @returns {void}\r\n * @throws {Error} If the joint is not of type b2_motorJoint.\r\n */\r\nexport function b2MotorJoint_SetMaxTorque(jointId, maxTorque)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n    joint.motorJoint.maxTorque = Math.max(0.0, maxTorque);\r\n}\r\n\r\n/**\r\n * Gets the maximum torque value for a motor joint.\r\n * @function b2MotorJoint_GetMaxTorque\r\n * @param {b2JointId} jointId - The identifier for the motor joint.\r\n * @returns {number} The maximum torque value of the motor joint.\r\n * @throws {Error} If the joint is not of type b2_motorJoint.\r\n */\r\nexport function b2MotorJoint_GetMaxTorque(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n\r\n    return joint.motorJoint.maxTorque;\r\n}\r\n\r\n/**\r\n * @function b2MotorJoint_SetCorrectionFactor\r\n * @summary Sets the position correction factor for a motor joint.\r\n * @param {b2JointId} jointId - The identifier for the motor joint.\r\n * @param {number} correctionFactor - The correction factor value, clamped between 0 and 1.\r\n * @returns {void}\r\n * @description\r\n * Sets the position correction factor for a motor joint, which determines how much position error is corrected each time step.\r\n * The correction factor is automatically clamped between 0 and 1.\r\n * @throws {Error} Throws an error if the joint is not a motor joint type.\r\n */\r\nexport function b2MotorJoint_SetCorrectionFactor(jointId, correctionFactor)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n    joint.motorJoint.correctionFactor = b2ClampFloat(correctionFactor, 0.0, 1.0);\r\n}\r\n\r\n/**\r\n * Gets the correction factor of a motor joint.\r\n * @function b2MotorJoint_GetCorrectionFactor\r\n * @param {b2JointId} jointId - The identifier for the motor joint.\r\n * @returns {number} The correction factor value of the motor joint.\r\n * @throws {Error} If the joint is not a motor joint type.\r\n */\r\nexport function b2MotorJoint_GetCorrectionFactor(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_motorJoint);\r\n\r\n    return joint.motorJoint.correctionFactor;\r\n}\r\n\r\nexport function b2GetMotorJointForce(world, base)\r\n{\r\n    const force = b2MulSV(world.inv_h, base.motorJoint.linearImpulse);\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetMotorJointTorque(world, base)\r\n{\r\n    return world.inv_h * base.motorJoint.angularImpulse;\r\n}\r\n\r\n// Point-to-point constraint\r\n// C = p2 - p1\r\n// Cdot = v2 - v1\r\n//      = v2 + cross(w2, r2) - v1 - cross(w1, r1)\r\n// J = [-I -r1_skew I r2_skew ]\r\n// Identity used:\r\n// w k % (rx i + ry j) = w * (-ry i + rx j)\r\n// Angle constraint\r\n// C = angle2 - angle1 - referenceAngle\r\n// Cdot = w2 - w1\r\n// J = [0 0 -1 0 0 1]\r\n// K = invI1 + invI2\r\n\r\nexport function b2PrepareMotorJoint(base, context)\r\n{\r\n    console.assert(base.type == b2JointType.b2_motorJoint);\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    // b2CheckIndex(bodies, idA);\r\n    // b2CheckIndex(bodies, idB);\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n    console.assert(bodyA.setIndex == b2SetType.b2_awakeSet || bodyB.setIndex == b2SetType.b2_awakeSet);\r\n\r\n    // b2CheckIndex(world.solverSetArray, bodyA.setIndex);\r\n    // b2CheckIndex(world.solverSetArray, bodyB.setIndex);\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n    const localIndexA = bodyA.localIndex;\r\n    const localIndexB = bodyB.localIndex;\r\n    console.assert(0 <= localIndexA && localIndexA <= setA.sims.count);\r\n    console.assert(0 <= localIndexB && localIndexB <= setB.sims.count);\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n    const joint = base.motorJoint;\r\n    joint.indexA = bodyA.setIndex == b2SetType.b2_awakeSet ? localIndexA : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex == b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n    joint.anchorA = b2RotateVector(bodySimA.transform.q, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(bodySimB.transform.q, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.deltaCenter = b2Sub(b2Sub(bodySimB.center, bodySimA.center), joint.linearOffset);\r\n    joint.deltaAngle = b2RelativeAngle(bodySimB.transform.q, bodySimA.transform.q) - joint.angularOffset;\r\n    joint.deltaAngle = b2UnwindAngle(joint.deltaAngle);\r\n    const rA = joint.anchorA;\r\n    const rB = joint.anchorB;\r\n    const K = new b2Mat22(\r\n        new b2Vec2(0, 0),\r\n        new b2Vec2(0, 0)\r\n    );\r\n    K.cx.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\r\n    K.cx.y = -rA.y * rA.x * iA - rB.y * rB.x * iB;\r\n    K.cy.x = K.cx.y;\r\n    K.cy.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\r\n    joint.linearMass = b2GetInverse22(K);\r\n    const ka = iA + iB;\r\n    joint.angularMass = ka > 0.0 ? 1.0 / ka : 0.0;\r\n\r\n    if (context.enableWarmStarting == false)\r\n    {\r\n        joint.linearImpulse = new b2Vec2(0, 0);\r\n        joint.angularImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartMotorJoint(base, context)\r\n{\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n    const joint = base.motorJoint;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n    const bodyA = joint.indexA == B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const bodyB = joint.indexB == B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n    const rA = b2RotateVector(bodyA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(bodyB.deltaRotation, joint.anchorB);\r\n    bodyA.linearVelocity = b2MulSub(bodyA.linearVelocity, mA, joint.linearImpulse);\r\n    bodyA.angularVelocity -= iA * (b2Cross(rA, joint.linearImpulse) + joint.angularImpulse);\r\n    bodyB.linearVelocity = b2MulAdd(bodyB.linearVelocity, mB, joint.linearImpulse);\r\n    bodyB.angularVelocity += iB * (b2Cross(rB, joint.linearImpulse) + joint.angularImpulse);\r\n}\r\n\r\nexport function b2SolveMotorJoint(base, context, useBias)\r\n{\r\n    console.assert(base.type == b2JointType.b2_motorJoint);\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n    const joint = base.motorJoint;\r\n    const bodyA = joint.indexA == B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const bodyB = joint.indexB == B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n    let vA = bodyA.linearVelocity;\r\n    let wA = bodyA.angularVelocity;\r\n    let vB = bodyB.linearVelocity;\r\n    let wB = bodyB.angularVelocity;\r\n\r\n    // angular constraint\r\n    {\r\n        let angularSeperation = b2RelativeAngle(bodyB.deltaRotation, bodyA.deltaRotation) + joint.deltaAngle;\r\n        angularSeperation = b2UnwindAngle(angularSeperation);\r\n        const angularBias = context.inv_h * joint.correctionFactor * angularSeperation;\r\n        const Cdot = wB - wA;\r\n        let impulse = -joint.angularMass * (Cdot + angularBias);\r\n        const oldImpulse = joint.angularImpulse;\r\n        const maxImpulse = context.h * joint.maxTorque;\r\n        joint.angularImpulse = b2ClampFloat(joint.angularImpulse + impulse, -maxImpulse, maxImpulse);\r\n        impulse = joint.angularImpulse - oldImpulse;\r\n        wA -= iA * impulse;\r\n        wB += iB * impulse;\r\n    }\r\n\r\n    // linear constraint\r\n    {\r\n        const rA = b2RotateVector(bodyA.deltaRotation, joint.anchorA);\r\n        const rB = b2RotateVector(bodyB.deltaRotation, joint.anchorB);\r\n        const ds = b2Add(b2Sub(bodyB.deltaPosition, bodyA.deltaPosition), b2Sub(rB, rA));\r\n        const linearSeparation = b2Add(joint.deltaCenter, ds);\r\n        const linearBias = b2MulSV(context.inv_h * joint.correctionFactor, linearSeparation);\r\n        const Cdot = b2Sub(b2Add(vB, b2CrossSV(wB, rB)), b2Add(vA, b2CrossSV(wA, rA)));\r\n        const b = b2MulMV(joint.linearMass, b2Add(Cdot, linearBias));\r\n        let impulse = new b2Vec2(-b.x, -b.y);\r\n        const oldImpulse = joint.linearImpulse;\r\n        const maxImpulse = context.h * joint.maxForce;\r\n        joint.linearImpulse = b2Add(joint.linearImpulse, impulse);\r\n\r\n        if (b2LengthSquared(joint.linearImpulse) > maxImpulse * maxImpulse)\r\n        {\r\n            joint.linearImpulse = b2Normalize(joint.linearImpulse);\r\n            joint.linearImpulse.x *= maxImpulse;\r\n            joint.linearImpulse.y *= maxImpulse;\r\n        }\r\n        impulse = b2Sub(joint.linearImpulse, oldImpulse);\r\n        vA = b2MulSub(vA, mA, impulse);\r\n        wA -= iA * b2Cross(rA, impulse);\r\n        vB = b2MulAdd(vB, mB, impulse);\r\n        wB += iB * b2Cross(rB, impulse);\r\n    }\r\n\r\n    bodyA.linearVelocity = vA;\r\n    bodyA.angularVelocity = wA;\r\n    bodyB.linearVelocity = vB;\r\n    bodyB.angularVelocity = wB;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Add, b2Cross, b2CrossSV, b2GetInverse22, b2Length, b2Mat22, b2MulAdd, b2MulMV, b2MulSV, b2Normalize, b2RotateVector, b2Sub, b2Vec2 } from \"./include/math_functions_h.js\";\r\nimport { b2GetJointSimCheckType, b2Joint_WakeBodies } from \"./include/joint_h.js\";\r\n\r\nimport { B2_NULL_INDEX } from \"./include/core_h.js\";\r\nimport { b2JointType } from \"./include/types_h.js\";\r\nimport { b2MakeSoft } from \"./include/solver_h.js\";\r\nimport { b2SetType } from \"./include/world_h.js\";\r\n\r\n/**\r\n * @namespace MouseJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * @summary Sets the target position for a mouse joint.\r\n * @function b2MouseJoint_SetTarget\r\n * @param {b2JointId} jointId - The identifier of the mouse joint to modify.\r\n * @param {b2Vec2} target - The new target position vector to set.\r\n * @returns {void}\r\n * @description\r\n * Updates the target position of a mouse joint by cloning the provided target vector.\r\n * The joint must be of type b2_mouseJoint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_mouseJoint.\r\n */\r\nexport function b2MouseJoint_SetTarget(jointId, target)\r\n{\r\n    // b2Vec2_IsValid(target);\r\n    b2Joint_WakeBodies(jointId);\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n    base.mouseJoint.targetA = target.clone();\r\n}\r\n\r\n/**\r\n * @function b2MouseJoint_GetTarget\r\n * @summary Gets the target point of a mouse joint.\r\n * @param {b2JointId} jointId - The identifier of the mouse joint.\r\n * @returns {b2Vec2} The target point of the mouse joint.\r\n * @throws {Error} If the joint is not of type b2_mouseJoint.\r\n */\r\nexport function b2MouseJoint_GetTarget(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n\r\n    return base.mouseJoint.targetA;\r\n}\r\n\r\n/**\r\n * @summary Sets the spring frequency (in Hertz) for a mouse joint.\r\n * @function b2MouseJoint_SetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the mouse joint to modify.\r\n * @param {number} hertz - The spring frequency in Hertz (Hz).\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not a mouse joint type.\r\n */\r\nexport function b2MouseJoint_SetSpringHertz(jointId, hertz)\r\n{\r\n    // b2IsValid(hertz) && hertz >= 0.0;\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n    base.mouseJoint.hertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the spring frequency in Hertz from a mouse joint.\r\n * @function b2MouseJoint_GetSpringHertz\r\n * @param {b2JointId} jointId - The identifier for the mouse joint.\r\n * @returns {number} The spring frequency in Hertz.\r\n * @throws {Error} If the joint is not a mouse joint type.\r\n */\r\nexport function b2MouseJoint_GetSpringHertz(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n\r\n    return base.mouseJoint.hertz;\r\n}\r\n\r\n/**\r\n * Sets the damping ratio for a mouse joint.\r\n * @function b2MouseJoint_SetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the mouse joint to modify.\r\n * @param {number} dampingRatio - The damping ratio value to set.\r\n * @returns {void}\r\n * @throws {Error} Throws if the joint is not a mouse joint type.\r\n */\r\nexport function b2MouseJoint_SetSpringDampingRatio(jointId, dampingRatio)\r\n{\r\n    // b2IsValid(dampingRatio) && dampingRatio >= 0.0;\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n    base.mouseJoint.dampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the spring damping ratio of a mouse joint.\r\n * @function b2MouseJoint_GetSpringDampingRatio\r\n * @param {b2JointId} jointId - The identifier of the mouse joint.\r\n * @returns {number} The spring damping ratio value of the mouse joint.\r\n * @throws {Error} Throws if the joint is not a mouse joint type.\r\n */\r\nexport function b2MouseJoint_GetSpringDampingRatio(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n\r\n    return base.mouseJoint.dampingRatio;\r\n}\r\n\r\n/**\r\n * @summary Sets the maximum force for a mouse joint.\r\n * @function b2MouseJoint_SetMaxForce\r\n * @param {b2JointId} jointId - The identifier for the mouse joint to modify.\r\n * @param {number} maxForce - The maximum force value to set for the joint.\r\n * @returns {void}\r\n * @description\r\n * Sets the maximum force that can be applied by the mouse joint to maintain its constraint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_mouseJoint.\r\n */\r\nexport function b2MouseJoint_SetMaxForce(jointId, maxForce)\r\n{\r\n    // b2IsValid(maxForce) && maxForce >= 0.0;\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n    base.mouseJoint.maxForce = maxForce;\r\n}\r\n\r\n/**\r\n * Gets the maximum force value from a mouse joint.\r\n * @function b2MouseJoint_GetMaxForce\r\n * @param {b2JointId} jointId - The identifier for the mouse joint.\r\n * @returns {number} The maximum force value of the mouse joint.\r\n * @throws {Error} If the joint is not of type b2_mouseJoint.\r\n */\r\nexport function b2MouseJoint_GetMaxForce(jointId)\r\n{\r\n    const base = b2GetJointSimCheckType(jointId, b2JointType.b2_mouseJoint);\r\n\r\n    return base.mouseJoint.maxForce;\r\n}\r\n\r\nexport function b2GetMouseJointForce(world, base)\r\n{\r\n    const force = b2MulSV(world.inv_h, base.mouseJoint.linearImpulse);\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetMouseJointTorque(world, base)\r\n{\r\n    return world.inv_h * base.mouseJoint.angularImpulse;\r\n}\r\n\r\nexport function b2PrepareMouseJoint(base, context)\r\n{\r\n    // base.type === b2JointType.b2_mouseJoint;\r\n\r\n    const idB = base.bodyIdB;\r\n\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    // b2CheckIndex(bodies, idB);\r\n\r\n    const bodyB = bodies[idB];\r\n\r\n    bodyB.setIndex === b2SetType.b2_awakeSet;\r\n\r\n    // b2CheckIndex(world.solverSetArray, bodyB.setIndex);\r\n\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n\r\n    const localIndexB = bodyB.localIndex;\r\n\r\n    // 0 <= localIndexB && localIndexB <= setB.sims.count;\r\n\r\n    const bodySimB = setB.sims.data[localIndexB];\r\n\r\n    base.invMassB = bodySimB.invMass;\r\n    base.invIB = bodySimB.invInertia;\r\n\r\n    const joint = base.mouseJoint;\r\n    joint.indexB = bodyB.setIndex === b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n    joint.anchorB = b2RotateVector(bodySimB.transform.q, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n\r\n    joint.linearSoftness = b2MakeSoft(joint.hertz, joint.dampingRatio, context.h);\r\n\r\n    const angularHertz = 0.5;\r\n    const angularDampingRatio = 0.1;\r\n    joint.angularSoftness = b2MakeSoft(angularHertz, angularDampingRatio, context.h);\r\n\r\n    const rB = joint.anchorB;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n\r\n    const K = new b2Mat22(\r\n        new b2Vec2(mB + iB * rB.y * rB.y, -iB * rB.x * rB.y),\r\n        new b2Vec2(-iB * rB.x * rB.y, mB + iB * rB.x * rB.x)\r\n    );\r\n\r\n    joint.linearMass = b2GetInverse22(K);\r\n    joint.deltaCenter = b2Sub(bodySimB.center, joint.targetA);\r\n\r\n    if (context.enableWarmStarting === false)\r\n    {\r\n        joint.linearImpulse = new b2Vec2(0, 0);\r\n        joint.angularImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartMouseJoint(base, context)\r\n{\r\n    base.type === b2JointType.b2_mouseJoint;\r\n\r\n    const mB = base.invMassB;\r\n    const iB = base.invIB;\r\n\r\n    const joint = base.mouseJoint;\r\n\r\n    const stateB = context.states[joint.indexB];\r\n    let vB = stateB.linearVelocity.clone();\r\n    let wB = stateB.angularVelocity;\r\n\r\n    const dqB = stateB.deltaRotation;\r\n    const rB = b2RotateVector(dqB, joint.anchorB);\r\n\r\n    vB = b2MulAdd(vB, mB, joint.linearImpulse);\r\n    wB += iB * (b2Cross(rB, joint.linearImpulse) + joint.angularImpulse);\r\n\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n\r\nexport function b2SolveMouseJoint(base, context)\r\n{\r\n    const mB = base.invMassB;\r\n    const iB = base.invIB;\r\n\r\n    const joint = base.mouseJoint;\r\n    const stateB = context.states[joint.indexB];\r\n\r\n    let vB = stateB.linearVelocity.clone();\r\n    let wB = stateB.angularVelocity;\r\n\r\n    {\r\n        const massScale = joint.angularSoftness.massScale;\r\n        const impulseScale = joint.angularSoftness.impulseScale;\r\n\r\n        let impulseStrength = iB > 0.0 ? -wB / iB : 0.0;\r\n        impulseStrength = massScale * impulseStrength - impulseScale * joint.angularImpulse;\r\n        joint.angularImpulse += impulseStrength;\r\n\r\n        wB += iB * impulseStrength;\r\n    }\r\n\r\n    const maxImpulse = joint.maxForce * context.h;\r\n\r\n    {\r\n        const dqB = stateB.deltaRotation;\r\n        const rB = b2RotateVector(dqB, joint.anchorB);\r\n        const Cdot = b2Add(vB, b2CrossSV(wB, rB));\r\n\r\n        const separation = b2Add(b2Add(stateB.deltaPosition, rB), joint.deltaCenter);\r\n        const bias = b2MulSV(joint.linearSoftness.biasRate, separation);\r\n\r\n        const massScale = joint.linearSoftness.massScale;\r\n        const impulseScale = joint.linearSoftness.impulseScale;\r\n\r\n        const b = b2MulMV(joint.linearMass, b2Add(Cdot, bias));\r\n\r\n        const impulseVector = new b2Vec2(\r\n            -massScale * b.x - impulseScale * joint.linearImpulse.x,\r\n            -massScale * b.y - impulseScale * joint.linearImpulse.y);\r\n\r\n        const oldImpulse = joint.linearImpulse.clone();\r\n        joint.linearImpulse.x += impulseVector.x;\r\n        joint.linearImpulse.y += impulseVector.y;\r\n\r\n        const mag = b2Length(joint.linearImpulse);\r\n\r\n        if (mag > maxImpulse)\r\n        {\r\n            joint.linearImpulse = b2MulSV(maxImpulse, b2Normalize(joint.linearImpulse));\r\n        }\r\n\r\n        impulseVector.x = joint.linearImpulse.x - oldImpulse.x;\r\n        impulseVector.y = joint.linearImpulse.y - oldImpulse.y;\r\n\r\n        vB = b2MulAdd(vB, mB, impulseVector);\r\n        wB += iB * b2Cross(rB, impulseVector);\r\n    }\r\n\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    b2Add,\r\n    b2Cross,\r\n    b2CrossSV,\r\n    b2IsValid,\r\n    b2Mat22,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2MulSub,\r\n    b2RelativeAngle,\r\n    b2RotateVector,\r\n    b2Solve22,\r\n    b2Sub,\r\n    b2Vec2\r\n} from './include/math_functions_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2BodyState } from './include/body_h.js';\r\nimport { b2GetJointSimCheckType } from './include/joint_h.js';\r\nimport { b2JointType } from './include/types_h.js';\r\nimport { b2MakeSoft } from './include/solver_h.js';\r\nimport { b2SetType } from './include/world_h.js';\r\n\r\n/**\r\n * @namespace WeldJoint\r\n */\r\n\r\n/**\r\n * @import {b2JointId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * Sets the linear frequency (hertz) for a weld joint.\r\n * @function b2WeldJoint_SetLinearHertz\r\n * @param {b2JointId} jointId - The identifier for the weld joint to modify\r\n * @param {number} hertz - The frequency in hertz (must be >= 0)\r\n * @returns {void}\r\n * @throws {Error} If the hertz value is invalid or negative\r\n */\r\nexport function b2WeldJoint_SetLinearHertz(jointId, hertz)\r\n{\r\n    // Assert is not directly translatable to JS, so we'll use a simple if check\r\n    if (!(b2IsValid(hertz) && hertz >= 0.0))\r\n    {\r\n        throw new Error(\"Invalid hertz value\");\r\n    }\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n    joint.weldJoint.linearHertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the linear Hertz value from a weld joint.\r\n * @function b2WeldJoint_GetLinearHertz\r\n * @param {b2JointId} jointId - The identifier for the weld joint.\r\n * @returns {number} The linear Hertz value of the weld joint.\r\n * @throws {Error} If the joint is not of type b2_weldJoint.\r\n */\r\nexport function b2WeldJoint_GetLinearHertz(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n\r\n    return joint.weldJoint.linearHertz;\r\n}\r\n\r\n/**\r\n * Sets the linear damping ratio for a weld joint.\r\n * @function b2WeldJoint_SetLinearDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the weld joint to modify.\r\n * @param {number} dampingRatio - The damping ratio value. Must be non-negative.\r\n * @returns {void}\r\n * @throws {Error} If dampingRatio is invalid or negative.\r\n */\r\nexport function b2WeldJoint_SetLinearDampingRatio(jointId, dampingRatio)\r\n{\r\n    if (!(b2IsValid(dampingRatio) && dampingRatio >= 0.0))\r\n    {\r\n        throw new Error(\"Invalid dampingRatio value\");\r\n    }\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n    joint.weldJoint.linearDampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the linear damping ratio of a weld joint.\r\n * @function b2WeldJoint_GetLinearDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the weld joint.\r\n * @returns {number} The linear damping ratio of the weld joint.\r\n * @throws {Error} If the joint is not of type b2_weldJoint.\r\n */\r\nexport function b2WeldJoint_GetLinearDampingRatio(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n\r\n    return joint.weldJoint.linearDampingRatio;\r\n}\r\n\r\n/**\r\n * Sets the angular frequency (hertz) for a weld joint's angular spring-damper.\r\n * @function b2WeldJoint_SetAngularHertz\r\n * @param {b2JointId} jointId - The identifier for the weld joint to modify.\r\n * @param {number} hertz - The angular frequency in Hertz (must be >= 0).\r\n * @returns {void}\r\n * @throws {Error} If the hertz value is invalid (NaN, negative, or infinity).\r\n * @throws {Error} If the joint is not a weld joint.\r\n */\r\nexport function b2WeldJoint_SetAngularHertz(jointId, hertz)\r\n{\r\n    if (!(b2IsValid(hertz) && hertz >= 0.0))\r\n    {\r\n        throw new Error(\"Invalid hertz value\");\r\n    }\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n    joint.weldJoint.angularHertz = hertz;\r\n}\r\n\r\n/**\r\n * Gets the angular frequency (hertz) of a weld joint.\r\n * @function b2WeldJoint_GetAngularHertz\r\n * @param {b2JointId} jointId - The identifier for the weld joint.\r\n * @returns {number} The angular frequency in hertz.\r\n * @throws {Error} If the joint is not of type b2_weldJoint.\r\n */\r\nexport function b2WeldJoint_GetAngularHertz(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n\r\n    return joint.weldJoint.angularHertz;\r\n}\r\n\r\n/**\r\n * Sets the angular damping ratio for a weld joint.\r\n * @function b2WeldJoint_SetAngularDampingRatio\r\n * @param {b2JointId} jointId - The identifier for the weld joint to modify.\r\n * @param {number} dampingRatio - The angular damping ratio. Must be non-negative.\r\n * @returns {void}\r\n * @throws {Error} If dampingRatio is invalid or negative.\r\n */\r\nexport function b2WeldJoint_SetAngularDampingRatio(jointId, dampingRatio)\r\n{\r\n    if (!(b2IsValid(dampingRatio) && dampingRatio >= 0.0))\r\n    {\r\n        throw new Error(\"Invalid dampingRatio value\");\r\n    }\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n    joint.weldJoint.angularDampingRatio = dampingRatio;\r\n}\r\n\r\n/**\r\n * Gets the angular damping ratio of a weld joint.\r\n * @function b2WeldJoint_GetAngularDampingRatio\r\n * @param {b2JointId} jointId - The identifier of the weld joint.\r\n * @returns {number} The angular damping ratio of the weld joint.\r\n * @throws {Error} Throws an error if the joint is not of type b2_weldJoint.\r\n */\r\nexport function b2WeldJoint_GetAngularDampingRatio(jointId)\r\n{\r\n    const joint = b2GetJointSimCheckType(jointId, b2JointType.b2_weldJoint);\r\n\r\n    return joint.weldJoint.angularDampingRatio;\r\n}\r\n\r\nexport function b2GetWeldJointForce(world, base)\r\n{\r\n    const force = b2MulSV(world.inv_h, base.weldJoint.linearImpulse);\r\n\r\n    return force;\r\n}\r\n\r\nexport function b2GetWeldJointTorque(world, base)\r\n{\r\n    return world.inv_h * base.weldJoint.angularImpulse;\r\n}\r\n\r\nexport function b2PrepareWeldJoint(base, context)\r\n{\r\n    if (base.type !== b2JointType.b2_weldJoint)\r\n    {\r\n        throw new Error(\"Invalid joint type\");\r\n    }\r\n\r\n    const idA = base.bodyIdA;\r\n    const idB = base.bodyIdB;\r\n\r\n    const world = context.world;\r\n    const bodies = world.bodyArray;\r\n\r\n    // b2CheckIndex(bodies, idA);\r\n    // b2CheckIndex(bodies, idB);\r\n\r\n    const bodyA = bodies[idA];\r\n    const bodyB = bodies[idB];\r\n\r\n    if (!(bodyA.setIndex === b2SetType.b2_awakeSet || bodyB.setIndex === b2SetType.b2_awakeSet))\r\n    {\r\n        throw new Error(\"At least one body must be awake\");\r\n    }\r\n\r\n    // b2CheckIndex(world.solverSetArray, bodyA.setIndex);\r\n    // b2CheckIndex(world.solverSetArray, bodyB.setIndex);\r\n\r\n    const setA = world.solverSetArray[bodyA.setIndex];\r\n    const setB = world.solverSetArray[bodyB.setIndex];\r\n\r\n    const localIndexA = bodyA.localIndex;\r\n    const localIndexB = bodyB.localIndex;\r\n\r\n    if (!(0 <= localIndexA && localIndexA <= setA.sims.count))\r\n    {\r\n        throw new Error(\"Invalid localIndexA\");\r\n    }\r\n\r\n    if (!(0 <= localIndexB && localIndexB <= setB.sims.count))\r\n    {\r\n        throw new Error(\"Invalid localIndexB\");\r\n    }\r\n\r\n    const bodySimA = setA.sims.data[bodyA.localIndex];\r\n    const bodySimB = setB.sims.data[bodyB.localIndex];\r\n\r\n    const mA = bodySimA.invMass;\r\n    const iA = bodySimA.invInertia;\r\n    const mB = bodySimB.invMass;\r\n    const iB = bodySimB.invInertia;\r\n\r\n    base.invMassA = mA;\r\n    base.invMassB = mB;\r\n    base.invIA = iA;\r\n    base.invIB = iB;\r\n\r\n    const joint = base.weldJoint;\r\n    joint.indexA = bodyA.setIndex === b2SetType.b2_awakeSet ? localIndexA : B2_NULL_INDEX;\r\n    joint.indexB = bodyB.setIndex === b2SetType.b2_awakeSet ? localIndexB : B2_NULL_INDEX;\r\n\r\n    const qA = bodySimA.transform.q;\r\n    const qB = bodySimB.transform.q;\r\n\r\n    joint.anchorA = b2RotateVector(qA, b2Sub(base.localOriginAnchorA, bodySimA.localCenter));\r\n    joint.anchorB = b2RotateVector(qB, b2Sub(base.localOriginAnchorB, bodySimB.localCenter));\r\n    joint.deltaCenter = b2Sub(bodySimB.center, bodySimA.center);\r\n    joint.deltaAngle = b2RelativeAngle(qB, qA) - joint.referenceAngle;\r\n\r\n    const ka = iA + iB;\r\n    joint.axialMass = ka > 0.0 ? 1.0 / ka : 0.0;\r\n\r\n    if (joint.linearHertz === 0.0)\r\n    {\r\n        joint.linearSoftness = context.jointSoftness;\r\n    }\r\n    else\r\n    {\r\n        joint.linearSoftness = b2MakeSoft(joint.linearHertz, joint.linearDampingRatio, context.h);\r\n    }\r\n\r\n    if (joint.angularHertz === 0.0)\r\n    {\r\n        joint.angularSoftness = context.jointSoftness;\r\n    }\r\n    else\r\n    {\r\n        joint.angularSoftness = b2MakeSoft(joint.angularHertz, joint.angularDampingRatio, context.h);\r\n    }\r\n\r\n    if (context.enableWarmStarting === false)\r\n    {\r\n        joint.linearImpulse = new b2Vec2(0, 0);\r\n        joint.angularImpulse = 0.0;\r\n    }\r\n}\r\n\r\nexport function b2WarmStartWeldJoint(base, context)\r\n{\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.weldJoint;\r\n\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n    const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n    stateA.linearVelocity = b2MulSub(stateA.linearVelocity, mA, joint.linearImpulse);\r\n    stateA.angularVelocity -= iA * (b2Cross(rA, joint.linearImpulse) + joint.angularImpulse);\r\n\r\n    stateB.linearVelocity = b2MulAdd(stateB.linearVelocity, mB, joint.linearImpulse);\r\n    stateB.angularVelocity += iB * (b2Cross(rB, joint.linearImpulse) + joint.angularImpulse);\r\n}\r\n\r\nexport function b2SolveWeldJoint(base, context, useBias)\r\n{\r\n    if (base.type !== b2JointType.b2_weldJoint)\r\n    {\r\n        throw new Error(\"Invalid joint type\");\r\n    }\r\n\r\n    const mA = base.invMassA;\r\n    const mB = base.invMassB;\r\n    const iA = base.invIA;\r\n    const iB = base.invIB;\r\n\r\n    // dummy state for static bodies\r\n    const dummyState = new b2BodyState();\r\n\r\n    const joint = base.weldJoint;\r\n\r\n    const stateA = joint.indexA === B2_NULL_INDEX ? dummyState : context.states[joint.indexA];\r\n    const stateB = joint.indexB === B2_NULL_INDEX ? dummyState : context.states[joint.indexB];\r\n\r\n    let vA = stateA.linearVelocity;\r\n    let wA = stateA.angularVelocity;\r\n    let vB = stateB.linearVelocity;\r\n    let wB = stateB.angularVelocity;\r\n\r\n    // angular constraint\r\n    {\r\n        let bias = 0.0;\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias || joint.angularHertz > 0.0)\r\n        {\r\n            const C = b2RelativeAngle(stateB.deltaRotation, stateA.deltaRotation) + joint.deltaAngle;\r\n            bias = joint.angularSoftness.biasRate * C;\r\n            massScale = joint.angularSoftness.massScale;\r\n            impulseScale = joint.angularSoftness.impulseScale;\r\n        }\r\n\r\n        const Cdot = wB - wA;\r\n        const impulse = -massScale * joint.axialMass * (Cdot + bias) - impulseScale * joint.angularImpulse;\r\n        joint.angularImpulse += impulse;\r\n\r\n        wA -= iA * impulse;\r\n        wB += iB * impulse;\r\n    }\r\n\r\n    // linear constraint\r\n    {\r\n        const rA = b2RotateVector(stateA.deltaRotation, joint.anchorA);\r\n        const rB = b2RotateVector(stateB.deltaRotation, joint.anchorB);\r\n\r\n        let bias = new b2Vec2(0, 0);\r\n        let massScale = 1.0;\r\n        let impulseScale = 0.0;\r\n\r\n        if (useBias || joint.linearHertz > 0.0)\r\n        {\r\n            const dcA = stateA.deltaPosition;\r\n            const dcB = stateB.deltaPosition;\r\n            const C = b2Add(b2Add(b2Sub(dcB, dcA), b2Sub(rB, rA)), joint.deltaCenter);\r\n\r\n            bias = b2MulSV(joint.linearSoftness.biasRate, C);\r\n            massScale = joint.linearSoftness.massScale;\r\n            impulseScale = joint.linearSoftness.impulseScale;\r\n        }\r\n\r\n        const Cdot = b2Sub(b2Add(vB, b2CrossSV(wB, rB)), b2Add(vA, b2CrossSV(wA, rA)));\r\n\r\n        const K = new b2Mat22();\r\n        K.cx.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\r\n        K.cy.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\r\n        K.cx.y = K.cy.x;\r\n        K.cy.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\r\n        const b = b2Solve22(K, b2Add(Cdot, bias));\r\n\r\n        const impulse = new b2Vec2(\r\n            -massScale * b.x - impulseScale * joint.linearImpulse.x,\r\n            -massScale * b.y - impulseScale * joint.linearImpulse.y);\r\n\r\n        joint.linearImpulse = b2Add(joint.linearImpulse, impulse);\r\n\r\n        vA = b2MulSub(vA, mA, impulse);\r\n        wA -= iA * b2Cross(rA, impulse);\r\n        vB = b2MulAdd(vB, mB, impulse);\r\n        wB += iB * b2Cross(rB, impulse);\r\n    }\r\n\r\n    stateA.linearVelocity = vA;\r\n    stateA.angularVelocity = wA;\r\n    stateB.linearVelocity = vB;\r\n    stateB.angularVelocity = wB;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_HUGE, B2_NULL_INDEX, b2_linearSlop } from \"./include/core_h.js\";\r\nimport { b2AddJoint, b2RemoveJoint } from \"./include/block_array_h.js\";\r\nimport { b2AllocId, b2FreeId } from \"./include/id_pool_h.js\";\r\nimport { b2Body_IsValid, b2GetWorld, b2GetWorldFromId, b2GetWorldLocked, b2SetType, b2ValidateSolverSets } from \"./include/world_h.js\";\r\nimport { b2ClampFloat, b2InvTransformPoint, b2IsValid, b2Lerp, b2Normalize, b2TransformPoint, b2Vec2 } from \"./include/math_functions_h.js\";\r\nimport { b2CreateJointInGraph, b2RemoveJointFromGraph, b2_overflowIndex } from \"./include/constraint_graph_h.js\";\r\nimport { b2DistanceJoint, b2Joint, b2JointEdge, b2MotorJoint, b2MouseJoint, b2PrismaticJoint, b2RevoluteJoint, b2WeldJoint, b2WheelJoint } from \"./include/joint_h.js\";\r\nimport { b2DistanceJointDef, b2HexColor, b2JointType, b2MotorJointDef, b2MouseJointDef, b2PrismaticJointDef, b2RevoluteJointDef, b2WeldJointDef, b2WheelJointDef } from \"./include/types_h.js\";\r\nimport { b2DrawDistanceJoint, b2GetDistanceJointForce, b2PrepareDistanceJoint, b2SolveDistanceJoint, b2WarmStartDistanceJoint } from \"./include/distance_joint_h.js\";\r\nimport { b2DrawPrismaticJoint, b2GetPrismaticJointForce, b2GetPrismaticJointTorque, b2PreparePrismaticJoint, b2SolvePrismaticJoint, b2WarmStartPrismaticJoint } from \"./include/prismatic_joint_h.js\";\r\nimport { b2DrawRevoluteJoint, b2PrepareRevoluteJoint, b2SolveRevoluteJoint, b2WarmStartRevoluteJoint } from \"./include/revolute_joint_h.js\";\r\nimport { b2DrawWheelJoint, b2PrepareWheelJoint, b2SolveWheelJoint, b2WarmStartWheelJoint } from \"./include/wheel_joint_h.js\";\r\nimport { b2GetBody, b2GetBodyFullId, b2GetBodyTransformQuick, b2MakeBodyId, b2WakeBody } from \"./include/body_h.js\";\r\nimport { b2GetMotorJointForce, b2GetMotorJointTorque } from \"./include/motor_joint_h.js\";\r\nimport { b2GetMouseJointForce, b2GetMouseJointTorque, b2PrepareMouseJoint, b2SolveMouseJoint, b2WarmStartMouseJoint } from \"./include/mouse_joint_h.js\";\r\nimport { b2GetRevoluteJointForce, b2GetRevoluteJointTorque } from \"./include/revolute_joint_h.js\";\r\nimport { b2GetWeldJointForce, b2GetWeldJointTorque } from \"./include/weld_joint_h.js\";\r\nimport { b2GetWheelJointForce, b2GetWheelJointTorque } from \"./include/wheel_joint_h.js\";\r\nimport { b2LinkJoint, b2UnlinkJoint } from \"./include/island_h.js\";\r\nimport { b2MergeSolverSets, b2WakeSolverSet } from \"./include/solver_set_h.js\";\r\nimport { b2PrepareMotorJoint, b2SolveMotorJoint, b2WarmStartMotorJoint } from \"./include/motor_joint_h.js\";\r\nimport { b2PrepareWeldJoint, b2SolveWeldJoint, b2WarmStartWeldJoint } from \"./include/weld_joint_h.js\";\r\n\r\nimport { b2BufferMove } from \"./include/broad_phase_h.js\";\r\nimport { b2DestroyContact } from \"./include/contact_h.js\";\r\nimport { b2JointId } from \"./include/id_h.js\";\r\n\r\n/**\r\n * @namespace Joint\r\n */\r\n\r\n/**\r\n * @import {b2WorldId, b2BodyId} from './include/id_h.js'\r\n */\r\n\r\n/**\r\n * Creates a default distance joint definition with preset values.\r\n * @function b2DefaultDistanceJointDef\r\n * @returns {b2DistanceJointDef} A distance joint definition with:\r\n * - length set to 1\r\n * - maxLength set to B2_HUGE\r\n * - all other properties at their default values\r\n * @description\r\n * Creates and returns a new b2DistanceJointDef object initialized with specific default values.\r\n * The length is set to 1 unit and the maxLength is set to B2_HUGE. All other properties\r\n * of the joint definition retain their default values from the b2DistanceJointDef constructor.\r\n */\r\nexport function b2DefaultDistanceJointDef()\r\n{\r\n    const def = new b2DistanceJointDef();\r\n    def.length = 1.0;\r\n    def.maxLength = B2_HUGE;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a b2MotorJointDef with default values.\r\n * @function b2DefaultMotorJointDef\r\n * @returns {b2MotorJointDef} A motor joint definition with:\r\n * - maxForce: 1\r\n * - maxTorque: 1\r\n * - correctionFactor: 0.3\r\n * - linearOffset: (0,0)\r\n * - angularOffset: 0\r\n * @description\r\n * Initializes a new b2MotorJointDef with common default values.\r\n * The joint definition includes preset values for maximum force,\r\n * maximum torque, and correction factor while using default\r\n * values for linear and angular offsets.\r\n */\r\nexport function b2DefaultMotorJointDef()\r\n{\r\n    const def = new b2MotorJointDef();\r\n    def.maxForce = 1.0;\r\n    def.maxTorque = 1.0;\r\n    def.correctionFactor = 0.3;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a b2MouseJointDef with default settings.\r\n * @function b2DefaultMouseJointDef\r\n * @returns {b2MouseJointDef} A mouse joint definition with:\r\n * - hertz = 4\r\n * - dampingRatio = 1\r\n * - maxForce = 1\r\n * @description\r\n * Creates and returns a new b2MouseJointDef object initialized with default values\r\n * for frequency (hertz), damping ratio, and maximum force parameters.\r\n */\r\nexport function b2DefaultMouseJointDef()\r\n{\r\n    const def = new b2MouseJointDef();\r\n    def.hertz = 4.0;\r\n    def.dampingRatio = 1.0;\r\n    def.maxForce = 1.0;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a default prismatic joint definition with preset values.\r\n * @function b2DefaultPrismaticJointDef\r\n * @returns {b2PrismaticJointDef} A prismatic joint definition with localAxisA set to (1,0)\r\n * @description\r\n * Creates and returns a new b2PrismaticJointDef instance with localAxisA initialized\r\n * to a unit vector pointing along the x-axis (1,0). All other properties retain their\r\n * default values from the b2PrismaticJointDef constructor.\r\n */\r\nexport function b2DefaultPrismaticJointDef()\r\n{\r\n    const def = new b2PrismaticJointDef();\r\n    def.localAxisA = new b2Vec2(1.0, 0.0);\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * Creates a default b2RevoluteJointDef with preset values.\r\n * @function b2DefaultRevoluteJointDef\r\n * @returns {b2RevoluteJointDef} A new revolution joint definition with drawSize set to 0.25\r\n * @description\r\n * Creates and initializes a new b2RevoluteJointDef with default values.\r\n * Sets the drawSize property to 0.25 for visualization purposes.\r\n */\r\nexport function b2DefaultRevoluteJointDef()\r\n{\r\n    const def = new b2RevoluteJointDef();\r\n    def.drawSize = 0.25;\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * @summary Creates a new weld joint definition with default values.\r\n * @function b2DefaultWeldJointDef\r\n * @returns {b2WeldJointDef} A new weld joint definition with default configuration:\r\n * - localAnchorA: b2Vec2(0,0)\r\n * - localAnchorB: b2Vec2(0,0)\r\n * - referenceAngle: 0\r\n * - stiffness: 0\r\n * - damping: 0\r\n * @description\r\n * Creates and returns a new b2WeldJointDef object initialized with default values.\r\n * A weld joint essentially glues two bodies together at a reference point.\r\n */\r\nexport function b2DefaultWeldJointDef()\r\n{\r\n    return new b2WeldJointDef();\r\n}\r\n\r\n/**\r\n * Creates a default wheel joint definition with preset values.\r\n * @function b2DefaultWheelJointDef\r\n * @returns {b2WheelJointDef} A wheel joint definition with:\r\n * - localAxisA set to (0,1)\r\n * - enableSpring set to true\r\n * - hertz set to 1\r\n * - dampingRatio set to 0.7\r\n * @description\r\n * Creates and returns a new b2WheelJointDef with common default values.\r\n * The joint's local axis is set to point upward, and spring behavior\r\n * is enabled with standard frequency and damping values.\r\n */\r\nexport function b2DefaultWheelJointDef()\r\n{\r\n    const def = new b2WheelJointDef();\r\n    def.localAxisA = new b2Vec2(0.0, 1.0);\r\n    def.enableSpring = true;\r\n    def.hertz = 1.0;\r\n    def.dampingRatio = 0.7;\r\n\r\n    return def;\r\n}\r\n\r\nfunction b2GetJointFullId(world, jointId)\r\n{\r\n    const id = jointId.index1 - 1;\r\n\r\n    // b2CheckIndex(world.jointArray, id);\r\n    const joint = world.jointArray[id];\r\n\r\n    // b2CheckIndex(world.solverSetArray, joint.setIndex);\r\n    console.assert(joint.revision === jointId.revision);\r\n\r\n    return joint;\r\n}\r\n\r\nexport function b2GetJoint(world, jointId)\r\n{\r\n    // b2CheckIndex(world.jointArray, jointId);\r\n    return world.jointArray[jointId];\r\n}\r\n\r\nexport function b2GetJointSim(world, joint)\r\n{\r\n    // b2CheckIndex(world.solverSetArray, joint.setIndex);\r\n\r\n    if (joint.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        // console.assert(0 <= joint.colorIndex && joint.colorIndex < b2_graphColorCount);\r\n        const color = world.constraintGraph.colors[joint.colorIndex];\r\n\r\n        // console.assert(0 <= joint.localIndex && joint.localIndex < color.joints.count);\r\n\r\n        if (joint.jointId !== color.joints.data[joint.localIndex].jointId)\r\n        {\r\n            console.error(\"jointId \" + joint.jointId + \" localIndex \" +  joint.localIndex + \" jointSim.jointId \" + color.joints.data[joint.localIndex].jointId);\r\n\r\n            // debugger;\r\n        }\r\n\r\n        return color.joints.data[joint.localIndex];\r\n    }\r\n\r\n    const set = world.solverSetArray[joint.setIndex];\r\n    console.assert(0 <= joint.localIndex && joint.localIndex < set.joints.count);\r\n    console.assert(joint.jointId == set.joints.data[joint.localIndex].jointId);\r\n\r\n    return set.joints.data[joint.localIndex];\r\n}\r\n\r\nexport function b2GetJointSimCheckType(jointId, type)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    console.assert(joint.type === type);\r\n    const jointSim = b2GetJointSim(world, joint);\r\n    console.assert(jointSim.type === type);\r\n\r\n    return jointSim;\r\n}\r\n\r\nclass b2JointPair\r\n{\r\n    constructor(joint = null, jointSim = null)\r\n    {\r\n        this.joint = joint;\r\n        this.jointSim = jointSim;\r\n        \r\n    }\r\n}\r\n\r\nexport function b2CreateJoint(world, bodyA, bodyB, userData, drawSize, type, collideConnected)\r\n{\r\n\r\n    b2ValidateSolverSets(world);\r\n\r\n    const bodyIdA = bodyA.id;\r\n    const bodyIdB = bodyB.id;\r\n    const maxSetIndex = Math.max(bodyA.setIndex, bodyB.setIndex);\r\n\r\n    // Create joint id and joint\r\n    const jointId = b2AllocId(world.jointIdPool);\r\n    console.assert(jointId !== B2_NULL_INDEX);\r\n\r\n    // console.warn(\"create jointId \" + jointId + \" world joints \" +  world.jointArray.length + \", for body \" + bodyIdA + \" joined to \" + bodyIdB);\r\n    while (jointId >= world.jointArray.length)\r\n    {\r\n        world.jointArray.push(new b2Joint());\r\n    }\r\n\r\n    const joint = world.jointArray[jointId];\r\n    joint.edges = [ new b2JointEdge(), new b2JointEdge() ];\r\n    joint.jointId = jointId;\r\n    joint.userData = userData;\r\n    joint.setIndex = B2_NULL_INDEX;\r\n    joint.colorIndex = B2_NULL_INDEX;\r\n    joint.localIndex = B2_NULL_INDEX;\r\n    joint.islandId = B2_NULL_INDEX;\r\n    joint.islandPrev = B2_NULL_INDEX;\r\n    joint.islandNext = B2_NULL_INDEX;\r\n    joint.revision += 1;\r\n    joint.drawSize = drawSize;\r\n    joint.type = type;\r\n    joint.isMarked = false;\r\n    joint.collideConnected = collideConnected;\r\n\r\n    // Doubly linked list on bodyA\r\n    joint.edges[0].bodyId = bodyIdA;\r\n    joint.edges[0].prevKey = B2_NULL_INDEX;\r\n    joint.edges[0].nextKey = bodyA.headJointKey;\r\n\r\n    const keyA = (jointId << 1) | 0;\r\n\r\n    if (bodyA.headJointKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointA = world.jointArray[bodyA.headJointKey >> 1];\r\n        const edgeA = jointA.edges[bodyA.headJointKey & 1];\r\n        edgeA.prevKey = keyA;\r\n    }\r\n    bodyA.headJointKey = keyA;\r\n    bodyA.jointCount += 1;\r\n\r\n    // console.warn(\"keyA \" + keyA);\r\n\r\n    // Doubly linked list on bodyB\r\n    joint.edges[1].bodyId = bodyIdB;\r\n    joint.edges[1].prevKey = B2_NULL_INDEX;\r\n    joint.edges[1].nextKey = bodyB.headJointKey;\r\n\r\n    const keyB = (jointId << 1) | 1;\r\n\r\n    if (bodyB.headJointKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointB = world.jointArray[bodyB.headJointKey >> 1];\r\n        const edgeB = jointB.edges[bodyB.headJointKey & 1];\r\n        edgeB.prevKey = keyB;\r\n    }\r\n    bodyB.headJointKey = keyB;\r\n    bodyB.jointCount += 1;\r\n\r\n    // console.warn(\"keyB \" + keyB);\r\n\r\n    let jointSim;\r\n\r\n    if (bodyA.setIndex === b2SetType.b2_disabledSet || bodyB.setIndex === b2SetType.b2_disabledSet)\r\n    {\r\n        // if either body is disabled, create in disabled set\r\n        const set = world.solverSetArray[b2SetType.b2_disabledSet];\r\n        joint.setIndex = b2SetType.b2_disabledSet;\r\n        joint.localIndex = set.joints.length;\r\n\r\n        jointSim = b2AddJoint(set.joints);\r\n        jointSim.jointId = jointId;\r\n\r\n        // console.warn(\"disabled \" + jointId);\r\n        jointSim.bodyIdA = bodyIdA;\r\n        jointSim.bodyIdB = bodyIdB;\r\n    }\r\n    else if (bodyA.setIndex === b2SetType.b2_staticSet && bodyB.setIndex === b2SetType.b2_staticSet)\r\n    {\r\n        // joint is connecting static bodies\r\n        const set = world.solverSetArray[b2SetType.b2_staticSet];\r\n        joint.setIndex = b2SetType.b2_staticSet;\r\n        joint.localIndex = set.joints.length;\r\n\r\n        jointSim = b2AddJoint(set.joints);\r\n        jointSim.jointId = jointId;\r\n\r\n        // console.warn(\"static \" + jointId);\r\n        jointSim.bodyIdA = bodyIdA;\r\n        jointSim.bodyIdB = bodyIdB;\r\n    }\r\n    else if (bodyA.setIndex === b2SetType.b2_awakeSet || bodyB.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        // if either body is sleeping, wake it\r\n        if (maxSetIndex >= b2SetType.b2_firstSleepingSet)\r\n        {\r\n            // console.warn(\"waking\");\r\n            b2WakeSolverSet(world, maxSetIndex);\r\n        }\r\n\r\n        joint.setIndex = b2SetType.b2_awakeSet;\r\n\r\n        jointSim = b2CreateJointInGraph(world, joint);\r\n        jointSim.jointId = jointId;\r\n\r\n        // console.warn(\"awake \" + jointId);\r\n        jointSim.bodyIdA = bodyIdA;\r\n        jointSim.bodyIdB = bodyIdB;\r\n    }\r\n    else\r\n    {\r\n        // joint connected between sleeping and/or static bodies\r\n        console.assert(bodyA.setIndex >= b2SetType.b2_firstSleepingSet || bodyB.setIndex >= b2SetType.b2_firstSleepingSet);\r\n        console.assert(bodyA.setIndex !== b2SetType.b2_staticSet || bodyB.setIndex !== b2SetType.b2_staticSet);\r\n\r\n        // joint should go into the sleeping set (not static set)\r\n        let setIndex = maxSetIndex;\r\n\r\n        // b2CheckIndex(world.solverSetArray, setIndex);\r\n        const set = world.solverSetArray[setIndex];\r\n        joint.setIndex = setIndex;\r\n        joint.localIndex = set.joints.length;\r\n        jointSim = b2AddJoint(set.joints);\r\n        jointSim.jointId = jointId;\r\n\r\n        // console.warn(\"else \" + jointId);\r\n        jointSim.bodyIdA = bodyIdA;\r\n        jointSim.bodyIdB = bodyIdB;\r\n\r\n        if (bodyA.setIndex !== bodyB.setIndex && bodyA.setIndex >= b2SetType.b2_firstSleepingSet &&\r\n            bodyB.setIndex >= b2SetType.b2_firstSleepingSet)\r\n        {\r\n            // merge sleeping sets\r\n            b2MergeSolverSets(world, bodyA.setIndex, bodyB.setIndex);\r\n            console.assert(bodyA.setIndex === bodyB.setIndex);\r\n\r\n            // fix potentially invalid set index\r\n            setIndex = bodyA.setIndex;\r\n\r\n            // Careful! The joint sim pointer was orphaned by the set merge.\r\n            jointSim = world.solverSetArray[setIndex].joints[joint.localIndex];\r\n        }\r\n\r\n        console.assert(joint.setIndex === setIndex);\r\n    }\r\n\r\n    console.assert(jointSim.jointId === jointId);\r\n    console.assert(jointSim.bodyIdA === bodyIdA);\r\n    console.assert(jointSim.bodyIdB === bodyIdB);\r\n\r\n    if (joint.setIndex > b2SetType.b2_disabledSet)\r\n    {\r\n        // Add edge to island graph\r\n        const mergeIslands = true;\r\n        b2LinkJoint(world, joint, mergeIslands);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n\r\n    return new b2JointPair(joint, jointSim);\r\n}\r\n\r\n// Assuming similar data structures exist in JS\r\n\r\nexport function b2DestroyContactsBetweenBodies(world, bodyA, bodyB)\r\n{\r\n    let contactKey;\r\n    let otherBodyId;\r\n\r\n    if (bodyA.contactCount < bodyB.contactCount)\r\n    {\r\n        contactKey = bodyA.headContactKey;\r\n        otherBodyId = bodyB.id;\r\n    }\r\n    else\r\n    {\r\n        contactKey = bodyB.headContactKey;\r\n        otherBodyId = bodyA.id;\r\n    }\r\n\r\n    const wakeBodies = false;\r\n\r\n    while (contactKey !== B2_NULL_INDEX)\r\n    {\r\n        const contactId = contactKey >> 1;\r\n        const edgeIndex = contactKey & 1;\r\n\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n        contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n        const otherEdgeIndex = edgeIndex ^ 1;\r\n\r\n        if (contact.edges[otherEdgeIndex].bodyId === otherBodyId)\r\n        {\r\n            // Careful, this removes the contact from the current doubly linked list\r\n            b2DestroyContact(world, contact, wakeBodies);\r\n        }\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2CreateDistanceJoint\r\n * @summary Creates a distance joint between two bodies in a Box2D world.\r\n * @param {b2WorldId} worldId - The ID of the Box2D world\r\n * @param {b2DistanceJointDef} def - The joint definition containing:\r\n * - bodyIdA: ID of the first body\r\n * - bodyIdB: ID of the second body\r\n * - localAnchorA: Local anchor point on body A\r\n * - localAnchorB: Local anchor point on body B\r\n * - length: Desired distance between anchor points\r\n * - minLength: Minimum allowed distance\r\n * - maxLength: Maximum allowed distance\r\n * - hertz: Spring frequency in Hz\r\n * - dampingRatio: Spring damping ratio\r\n * - maxMotorForce: Maximum motor force\r\n * - motorSpeed: Motor speed\r\n * - enableSpring: Enable/disable spring\r\n * - enableLimit: Enable/disable length limits\r\n * - enableMotor: Enable/disable motor\r\n * - collideConnected: Allow collision between connected bodies\r\n * - userData: User data\r\n * @returns {b2JointId} The ID of the created distance joint\r\n * @throws {Error} Throws assertion error if world is locked, bodies are invalid, or length <= 0\r\n */\r\nexport function b2CreateDistanceJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    console.assert(b2Body_IsValid(def.bodyIdA));\r\n    console.assert(b2Body_IsValid(def.bodyIdB));\r\n    console.assert(b2IsValid(def.length) && def.length > 0.0);\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_distanceJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_distanceJoint;\r\n    joint.localOriginAnchorA = def.localAnchorA;\r\n    joint.localOriginAnchorB = def.localAnchorB;\r\n\r\n    joint.distanceJoint = new b2DistanceJoint();\r\n    joint.distanceJoint.length = Math.max(def.length, b2_linearSlop);\r\n    joint.distanceJoint.hertz = def.hertz;\r\n    joint.distanceJoint.dampingRatio = def.dampingRatio;\r\n    joint.distanceJoint.minLength = Math.max(def.minLength, b2_linearSlop);\r\n    joint.distanceJoint.maxLength = Math.max(def.minLength, def.maxLength);\r\n    joint.distanceJoint.maxMotorForce = def.maxMotorForce;\r\n    joint.distanceJoint.motorSpeed = def.motorSpeed;\r\n    joint.distanceJoint.enableSpring = def.enableSpring;\r\n    joint.distanceJoint.enableLimit = def.enableLimit;\r\n    joint.distanceJoint.enableMotor = def.enableMotor;\r\n    joint.distanceJoint.impulse = 0.0;\r\n    joint.distanceJoint.lowerImpulse = 0.0;\r\n    joint.distanceJoint.upperImpulse = 0.0;\r\n    joint.distanceJoint.motorImpulse = 0.0;\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * @function b2CreateMotorJoint\r\n * @summary Creates a motor joint between two bodies in a Box2D world.\r\n * @param {b2WorldId} worldId - The ID of the Box2D world\r\n * @param {b2MotorJointDef} def - The joint definition containing:\r\n * - bodyIdA: ID of the first body\r\n * - bodyIdB: ID of the second body\r\n * - linearOffset: The target linear offset between bodies\r\n * - angularOffset: The target angular offset between bodies\r\n * - maxForce: Maximum force that can be applied\r\n * - maxTorque: Maximum torque that can be applied\r\n * - correctionFactor: Position correction factor in [0,1]\r\n * - collideConnected: Whether bodies can collide\r\n * - userData: User data\r\n * @returns {b2JointId} The ID of the created motor joint\r\n * @throws {Error} If the world is locked when attempting to create the joint\r\n */\r\nexport function b2CreateMotorJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_motorJoint, def.collideConnected);\r\n    const joint = pair.jointSim;\r\n\r\n    joint.type = b2JointType.b2_motorJoint;\r\n    joint.localOriginAnchorA = new b2Vec2(0, 0);\r\n    joint.localOriginAnchorB = new b2Vec2(0, 0);\r\n    joint.motorJoint = new b2MotorJoint();\r\n    joint.motorJoint.linearOffset = def.linearOffset;\r\n    joint.motorJoint.angularOffset = def.angularOffset;\r\n    joint.motorJoint.maxForce = def.maxForce;\r\n    joint.motorJoint.maxTorque = def.maxTorque;\r\n    joint.motorJoint.correctionFactor = b2ClampFloat(def.correctionFactor, 0.0, 1.0);\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * @function b2CreateMouseJoint\r\n * @summary Creates a mouse joint in a Box2D world.\r\n * @param {b2WorldId} worldId - The ID of the Box2D world where the joint will be created\r\n * @param {b2MouseJointDef} def - The mouse joint definition containing:\r\n * - bodyIdA: ID of the first body\r\n * - bodyIdB: ID of the second body\r\n * - target: Target point in world coordinates\r\n * - hertz: Frequency in Hertz\r\n * - dampingRatio: Damping ratio\r\n * - maxForce: Maximum force\r\n * - userData: User data\r\n * - collideConnected: Whether connected bodies can collide\r\n * @returns {b2JointId} The ID of the created mouse joint\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n * @description\r\n * Creates a mouse joint between two bodies at a specified target point. The joint\r\n * transforms the target point into local coordinates for both bodies and initializes\r\n * the joint properties including frequency, damping ratio, and maximum force.\r\n */\r\nexport function b2CreateMouseJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const transformA = b2GetBodyTransformQuick(world, bodyA);\r\n    const transformB = b2GetBodyTransformQuick(world, bodyB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_mouseJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_mouseJoint;\r\n    joint.localOriginAnchorA = b2InvTransformPoint(transformA, def.target);\r\n    joint.localOriginAnchorB = b2InvTransformPoint(transformB, def.target);\r\n\r\n    joint.mouseJoint = new b2MouseJoint();\r\n    joint.mouseJoint.targetA = def.target;\r\n    joint.mouseJoint.hertz = def.hertz;\r\n    joint.mouseJoint.dampingRatio = def.dampingRatio;\r\n    joint.mouseJoint.maxForce = def.maxForce;\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * @summary Creates a revolute joint between two bodies in a Box2D world\r\n * @function b2CreateRevoluteJoint\r\n * @param {b2WorldId} worldId - The ID of the Box2D world\r\n * @param {b2RevoluteJointDef} def - The joint definition containing properties like:\r\n * - bodyIdA: ID of first body\r\n * - bodyIdB: ID of second body\r\n * - localAnchorA: Local anchor point on body A\r\n * - localAnchorB: Local anchor point on body B\r\n * - referenceAngle: Initial angle between bodies (clamped to [-\u03C0,\u03C0])\r\n * - hertz: Spring frequency\r\n * - dampingRatio: Spring damping ratio\r\n * - lowerAngle: Lower angle limit (clamped to [-\u03C0,\u03C0])\r\n * - upperAngle: Upper angle limit (clamped to [-\u03C0,\u03C0])\r\n * - maxMotorTorque: Maximum motor torque\r\n * - motorSpeed: Motor speed\r\n * - enableSpring: Enable spring behavior\r\n * - enableLimit: Enable angle limits\r\n * - enableMotor: Enable motor\r\n * - collideConnected: Allow collision between connected bodies\r\n * - userData: User data\r\n * - drawSize: Drawing size\r\n * @returns {b2JointId} ID of the created revolute joint\r\n * @throws {Error} If the world is locked\r\n */\r\nexport function b2CreateRevoluteJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, def.drawSize, b2JointType.b2_revoluteJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_revoluteJoint;\r\n    joint.localOriginAnchorA = def.localAnchorA;\r\n    joint.localOriginAnchorB = def.localAnchorB;\r\n\r\n    joint.revoluteJoint = new b2RevoluteJoint();\r\n    joint.revoluteJoint.referenceAngle = b2ClampFloat(def.referenceAngle, -Math.PI, Math.PI);\r\n    joint.revoluteJoint.linearImpulse = new b2Vec2(0, 0);\r\n    joint.revoluteJoint.axialMass = 0.0;\r\n    joint.revoluteJoint.springImpulse = 0.0;\r\n    joint.revoluteJoint.motorImpulse = 0.0;\r\n    joint.revoluteJoint.lowerImpulse = 0.0;\r\n    joint.revoluteJoint.upperImpulse = 0.0;\r\n    joint.revoluteJoint.hertz = def.hertz;\r\n    joint.revoluteJoint.dampingRatio = def.dampingRatio;\r\n    joint.revoluteJoint.lowerAngle = Math.min(def.lowerAngle, def.upperAngle);\r\n    joint.revoluteJoint.upperAngle = Math.max(def.lowerAngle, def.upperAngle);\r\n    joint.revoluteJoint.lowerAngle = b2ClampFloat(joint.revoluteJoint.lowerAngle, -Math.PI, Math.PI);\r\n    joint.revoluteJoint.upperAngle = b2ClampFloat(joint.revoluteJoint.upperAngle, -Math.PI, Math.PI);\r\n    joint.revoluteJoint.maxMotorTorque = def.maxMotorTorque;\r\n    joint.revoluteJoint.motorSpeed = def.motorSpeed;\r\n    joint.revoluteJoint.enableSpring = def.enableSpring;\r\n    joint.revoluteJoint.enableLimit = def.enableLimit;\r\n    joint.revoluteJoint.enableMotor = def.enableMotor;\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * @function b2CreatePrismaticJoint\r\n * @description\r\n * Creates a prismatic joint between two bodies in a Box2D world. A prismatic joint\r\n * constrains two bodies to move relative to each other along a specified axis.\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @param {b2PrismaticJointDef} def - The joint definition containing:\r\n * - bodyIdA: First body ID\r\n * - bodyIdB: Second body ID\r\n * - localAnchorA: Anchor point on body A in local coordinates\r\n * - localAnchorB: Anchor point on body B in local coordinates\r\n * - localAxisA: The axis of translation in body A's local coordinates\r\n * - referenceAngle: The initial angle between the bodies\r\n * - enableLimit: Whether translation limits are enabled\r\n * - lowerTranslation: Lower translation limit\r\n * - upperTranslation: Upper translation limit\r\n * - enableMotor: Whether the motor is enabled\r\n * - motorSpeed: Motor speed\r\n * - maxMotorForce: Maximum motor force\r\n * - enableSpring: Whether spring is enabled\r\n * - hertz: Spring frequency in Hz\r\n * - dampingRatio: Spring damping ratio\r\n * - collideConnected: Whether connected bodies can collide\r\n * - userData: User data\r\n * @returns {b2JointId} The identifier for the created prismatic joint\r\n */\r\nexport function b2CreatePrismaticJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_prismaticJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_prismaticJoint;\r\n    joint.localOriginAnchorA = def.localAnchorA;\r\n    joint.localOriginAnchorB = def.localAnchorB;\r\n\r\n    joint.prismaticJoint = new b2PrismaticJoint();\r\n    joint.prismaticJoint.localAxisA = b2Normalize(def.localAxisA);\r\n    joint.prismaticJoint.referenceAngle = def.referenceAngle;\r\n    joint.prismaticJoint.impulse = new b2Vec2(0, 0);\r\n    joint.prismaticJoint.axialMass = 0.0;\r\n    joint.prismaticJoint.springImpulse = 0.0;\r\n    joint.prismaticJoint.motorImpulse = 0.0;\r\n    joint.prismaticJoint.lowerImpulse = 0.0;\r\n    joint.prismaticJoint.upperImpulse = 0.0;\r\n    joint.prismaticJoint.hertz = def.hertz;\r\n    joint.prismaticJoint.dampingRatio = def.dampingRatio;\r\n    joint.prismaticJoint.lowerTranslation = def.lowerTranslation;\r\n    joint.prismaticJoint.upperTranslation = def.upperTranslation;\r\n    joint.prismaticJoint.maxMotorForce = def.maxMotorForce;\r\n    joint.prismaticJoint.motorSpeed = def.motorSpeed;\r\n    joint.prismaticJoint.enableSpring = def.enableSpring;\r\n    joint.prismaticJoint.enableLimit = def.enableLimit;\r\n    joint.prismaticJoint.enableMotor = def.enableMotor;\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * Creates a weld joint between two bodies in a Box2D world.\r\n * @function b2CreateWeldJoint\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @param {b2WeldJointDef} def - The weld joint definition containing:\r\n * - bodyIdA: ID of the first body\r\n * - bodyIdB: ID of the second body\r\n * - localAnchorA: Local anchor point on body A\r\n * - localAnchorB: Local anchor point on body B\r\n * - referenceAngle: Reference angle between the bodies\r\n * - linearHertz: Frequency for the linear constraint\r\n * - linearDampingRatio: Damping ratio for the linear constraint\r\n * - angularHertz: Frequency for the angular constraint\r\n * - angularDampingRatio: Damping ratio for the angular constraint\r\n * - collideConnected: Whether the connected bodies can collide\r\n * - userData: User data associated with the joint\r\n * @returns {b2JointId} The identifier of the created weld joint\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n */\r\nexport function b2CreateWeldJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_weldJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_weldJoint;\r\n    joint.localOriginAnchorA = def.localAnchorA;\r\n    joint.localOriginAnchorB = def.localAnchorB;\r\n\r\n    joint.weldJoint = new b2WeldJoint();\r\n    joint.weldJoint.referenceAngle = def.referenceAngle;\r\n    joint.weldJoint.linearHertz = def.linearHertz;\r\n    joint.weldJoint.linearDampingRatio = def.linearDampingRatio;\r\n    joint.weldJoint.angularHertz = def.angularHertz;\r\n    joint.weldJoint.angularDampingRatio = def.angularDampingRatio;\r\n    joint.weldJoint.linearImpulse = new b2Vec2(0, 0);\r\n    joint.weldJoint.angularImpulse = 0.0;\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\n/**\r\n * @function b2CreateWheelJoint\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @param {b2WheelJointDef} def - The wheel joint definition containing configuration parameters\r\n * @returns {b2JointId} The identifier of the created wheel joint\r\n * @description\r\n * Creates a wheel joint between two bodies in a Box2D world. A wheel joint provides two degrees of\r\n * freedom: translation along a specified axis and rotation about an orthogonal axis. The joint can\r\n * be configured with a spring and damper mechanism, translation limits, and a motor.\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n * @note If collideConnected is false, any contacts between the connected bodies are destroyed\r\n */\r\nexport function b2CreateWheelJoint(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2JointId();\r\n    }\r\n\r\n    const bodyA = b2GetBodyFullId(world, def.bodyIdA);\r\n    const bodyB = b2GetBodyFullId(world, def.bodyIdB);\r\n\r\n    const pair = b2CreateJoint(world, bodyA, bodyB, def.userData, 1.0, b2JointType.b2_wheelJoint, def.collideConnected);\r\n\r\n    const joint = pair.jointSim;\r\n    joint.type = b2JointType.b2_wheelJoint;\r\n    joint.localOriginAnchorA = def.localAnchorA;\r\n    joint.localOriginAnchorB = def.localAnchorB;\r\n\r\n    joint.wheelJoint = new b2WheelJoint();\r\n    joint.wheelJoint.localAxisA = b2Normalize(def.localAxisA);\r\n    joint.wheelJoint.perpMass = 0.0;\r\n    joint.wheelJoint.axialMass = 0.0;\r\n    joint.wheelJoint.motorImpulse = 0.0;\r\n    joint.wheelJoint.lowerImpulse = 0.0;\r\n    joint.wheelJoint.upperImpulse = 0.0;\r\n    joint.wheelJoint.lowerTranslation = def.lowerTranslation;\r\n    joint.wheelJoint.upperTranslation = def.upperTranslation;\r\n    joint.wheelJoint.maxMotorTorque = def.maxMotorTorque;\r\n    joint.wheelJoint.motorSpeed = def.motorSpeed;\r\n    joint.wheelJoint.hertz = def.hertz;\r\n    joint.wheelJoint.dampingRatio = def.dampingRatio;\r\n    joint.wheelJoint.enableSpring = def.enableSpring;\r\n    joint.wheelJoint.enableLimit = def.enableLimit;\r\n    joint.wheelJoint.enableMotor = def.enableMotor;\r\n\r\n    if (def.collideConnected === false)\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n\r\n    const jointId = new b2JointId(joint.jointId + 1, world.worldId, pair.joint.revision);\r\n\r\n    return jointId;\r\n}\r\n\r\nexport function b2DestroyJointInternal(world, joint, wakeBodies)\r\n{\r\n    const jointId = joint.jointId;\r\n\r\n    const edgeA = joint.edges[0];\r\n    const edgeB = joint.edges[1];\r\n\r\n    const idA = edgeA.bodyId;\r\n    const idB = edgeB.bodyId;\r\n    const bodyA = b2GetBody(world, idA);\r\n    const bodyB = b2GetBody(world, idB);\r\n\r\n    // Remove from body A\r\n    if (edgeA.prevKey !== B2_NULL_INDEX)\r\n    {\r\n        const prevJoint = world.jointArray[edgeA.prevKey >> 1];\r\n        const prevEdge = prevJoint.edges[edgeA.prevKey & 1];\r\n        prevEdge.nextKey = edgeA.nextKey;\r\n    }\r\n\r\n    if (edgeA.nextKey !== B2_NULL_INDEX)\r\n    {\r\n        const nextJoint = world.jointArray[edgeA.nextKey >> 1];\r\n        const nextEdge = nextJoint.edges[edgeA.nextKey & 1];\r\n        nextEdge.prevKey = edgeA.prevKey;\r\n    }\r\n\r\n    const edgeKeyA = (jointId << 1) | 0;\r\n\r\n    if (bodyA.headJointKey === edgeKeyA)\r\n    {\r\n        bodyA.headJointKey = edgeA.nextKey;\r\n    }\r\n\r\n    bodyA.jointCount -= 1;\r\n\r\n    // Remove from body B\r\n    if (edgeB.prevKey !== B2_NULL_INDEX)\r\n    {\r\n        const prevJoint = world.jointArray[edgeB.prevKey >> 1];\r\n        const prevEdge = prevJoint.edges[edgeB.prevKey & 1];\r\n        prevEdge.nextKey = edgeB.nextKey;\r\n    }\r\n\r\n    if (edgeB.nextKey !== B2_NULL_INDEX)\r\n    {\r\n        const nextJoint = world.jointArray[edgeB.nextKey >> 1];\r\n        const nextEdge = nextJoint.edges[edgeB.nextKey & 1];\r\n        nextEdge.prevKey = edgeB.prevKey;\r\n    }\r\n\r\n    const edgeKeyB = (jointId << 1) | 1;\r\n\r\n    if (bodyB.headJointKey === edgeKeyB)\r\n    {\r\n        bodyB.headJointKey = edgeB.nextKey;\r\n    }\r\n\r\n    bodyB.jointCount -= 1;\r\n\r\n    if (joint.islandId !== B2_NULL_INDEX)\r\n    {\r\n        b2UnlinkJoint(world, joint);\r\n    }\r\n\r\n    // Remove joint from solver set that owns it\r\n    const setIndex = joint.setIndex;\r\n    const localIndex = joint.localIndex;\r\n\r\n    if (setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        b2RemoveJointFromGraph(world, joint.edges[0].bodyId, joint.edges[1].bodyId, joint.colorIndex, localIndex);\r\n    }\r\n    else\r\n    {\r\n        const set = world.solverSetArray[setIndex];\r\n        const movedIndex = b2RemoveJoint(set.joints, localIndex);\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            // Fix moved joint\r\n            const movedJointSim = set.joints.data[localIndex];\r\n            const movedId = movedJointSim.jointId;\r\n            const movedJoint = world.jointArray[movedId];\r\n            console.assert(movedJoint.localIndex === movedIndex);\r\n            movedJoint.localIndex = localIndex;\r\n        }\r\n    }\r\n\r\n    // Free joint and id (preserve joint revision)\r\n    joint.setIndex = B2_NULL_INDEX;\r\n    joint.colorIndex = B2_NULL_INDEX;\r\n    joint.localIndex = B2_NULL_INDEX;\r\n    joint.jointId = B2_NULL_INDEX;\r\n    joint.type = b2JointType.b2_unknown;\r\n    b2FreeId(world.jointIdPool, jointId);\r\n\r\n    if (wakeBodies)\r\n    {\r\n        b2WakeBody(world, bodyA);\r\n        b2WakeBody(world, bodyB);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2DestroyJoint\r\n * @param {b2JointId} jointId - The identifier of the joint to be destroyed\r\n * @returns {void}\r\n * @description\r\n * Destroys a joint in the physics world. If the world is locked (e.g. during collision detection\r\n * or integration), the function will return without destroying the joint. The function internally\r\n * calls b2DestroyJointInternal to handle the actual joint destruction.\r\n * @throws {Error} Throws an assertion error if attempting to destroy a joint in a locked world\r\n */\r\nexport function b2DestroyJoint(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    b2DestroyJointInternal(world, joint, true);\r\n}\r\n\r\n/**\r\n * Gets the type of a joint from its ID.\r\n * @function b2Joint_GetType\r\n * @param {b2JointId} jointId - The ID of the joint to query.\r\n * @returns {b2JointType} The type of the specified joint.\r\n * @description\r\n * Retrieves the joint type from the world using the provided joint ID.\r\n * The function first gets the world reference from the joint ID,\r\n * then retrieves the full joint object to access its type property.\r\n */\r\nexport function b2Joint_GetType(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    return joint.type;\r\n}\r\n\r\n/**\r\n * @summary Gets the first body connected to a joint.\r\n * @function b2Joint_GetBodyA\r\n * @param {b2JointId} jointId - The identifier of the joint.\r\n * @returns {b2BodyId} The identifier of the first body connected to the joint.\r\n * @description\r\n * This function retrieves the identifier of the first body (body A) that is\r\n * connected to the specified joint. The joint must exist in the world referenced\r\n * by the jointId.\r\n */\r\nexport function b2Joint_GetBodyA(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    return b2MakeBodyId(world, joint.edges[0].bodyId);\r\n}\r\n\r\n/**\r\n * @summary Gets the second body (body B) connected to a joint.\r\n * @function b2Joint_GetBodyB\r\n * @param {b2JointId} jointId - The identifier of the joint.\r\n * @returns {b2BodyId} The identifier of body B connected to the joint.\r\n * @description\r\n * This function retrieves the identifier of the second body (body B) that is\r\n * connected to the specified joint. The joint must exist in the world referenced\r\n * by the jointId.\r\n */\r\nexport function b2Joint_GetBodyB(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    return b2MakeBodyId(world, joint.edges[1].bodyId);\r\n}\r\n\r\n/**\r\n * @function b2Joint_GetLocalAnchorA\r\n * @summary Gets the local anchor point A of a joint.\r\n * @param {b2JointId} jointId - The identifier for the joint.\r\n * @returns {b2Vec2} The local anchor point A in the body A frame.\r\n * @description\r\n * Retrieves the local anchor point A from a joint's simulation data. The anchor point\r\n * is expressed in the local coordinate system of body A.\r\n */\r\nexport function b2Joint_GetLocalAnchorA(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    const jointSim = b2GetJointSim(world, joint);\r\n\r\n    return jointSim.localOriginAnchorA;\r\n}\r\n\r\n/**\r\n * @function b2Joint_GetLocalAnchorB\r\n * @summary Gets the local anchor point B of a joint.\r\n * @param {b2JointId} jointId - The identifier for the joint.\r\n * @returns {b2Vec2} The local anchor point B in the body's local coordinates.\r\n * @description\r\n * Retrieves the local anchor point B of a joint, which represents the connection\r\n * point on the second body (body B) in that body's local coordinate system.\r\n */\r\nexport function b2Joint_GetLocalAnchorB(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    const jointSim = b2GetJointSim(world, joint);\r\n\r\n    return jointSim.localOriginAnchorB;\r\n}\r\n\r\n/**\r\n * Sets whether two bodies connected by a joint should collide with each other.\r\n * @function b2Joint_SetCollideConnected\r\n * @param {b2JointId} jointId - The identifier for the joint to modify.\r\n * @param {boolean} shouldCollide - True to enable collision between connected bodies, false to disable.\r\n * @returns {void}\r\n * @description\r\n * When enabled, the bodies connected by the joint can collide with each other.\r\n * When disabled, collisions between the connected bodies are filtered out.\r\n * The function updates the broadphase when enabling collisions and destroys\r\n * existing contacts between the bodies when disabling collisions.\r\n */\r\nexport function b2Joint_SetCollideConnected(jointId, shouldCollide)\r\n{\r\n    const world = b2GetWorldLocked(jointId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    if (joint.collideConnected === shouldCollide)\r\n    {\r\n        return;\r\n    }\r\n\r\n    joint.collideConnected = shouldCollide;\r\n\r\n    const bodyA = b2GetBody(world, joint.edges[0].bodyId);\r\n    const bodyB = b2GetBody(world, joint.edges[1].bodyId);\r\n\r\n    if (shouldCollide)\r\n    {\r\n        // need to tell the broad-phase to look for new pairs for one of the\r\n        // two bodies. Pick the one with the fewest shapes.\r\n        const shapeCountA = bodyA.shapeCount;\r\n        const shapeCountB = bodyB.shapeCount;\r\n\r\n        let shapeId = shapeCountA < shapeCountB ? bodyA.headShapeId : bodyB.headShapeId;\r\n\r\n        while (shapeId !== B2_NULL_INDEX)\r\n        {\r\n            const shape = world.shapeArray[shapeId];\r\n\r\n            if (shape.proxyKey !== B2_NULL_INDEX)\r\n            {\r\n                b2BufferMove(world.broadPhase, shape.proxyKey);\r\n            }\r\n\r\n            shapeId = shape.nextShapeId;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        b2DestroyContactsBetweenBodies(world, bodyA, bodyB);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Joint_GetCollideConnected\r\n * @param {b2JointId} jointId - The ID of the joint to query\r\n * @returns {boolean} Whether the connected bodies can collide with each other\r\n * @description\r\n * Gets the collideConnected flag for the specified joint. This flag determines if\r\n * the two bodies connected by this joint are allowed to collide with each other.\r\n */\r\nexport function b2Joint_GetCollideConnected(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    return joint.collideConnected;\r\n}\r\n\r\n/**\r\n * @summary Sets the user data for a joint.\r\n * @function b2Joint_SetUserData\r\n * @param {b2JointId} jointId - The identifier for the joint to modify.\r\n * @param {*} userData - The user data to associate with the joint.\r\n * @returns {void}\r\n * @description\r\n * Associates arbitrary user data with a specified joint in the physics world.\r\n * The joint is located using its world and joint identifiers, and its user data\r\n * property is updated with the provided value.\r\n */\r\nexport function b2Joint_SetUserData(jointId, userData)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    joint.userData = userData;\r\n}\r\n\r\n/**\r\n * @summary Gets the user data associated with a joint.\r\n * @function b2Joint_GetUserData\r\n * @param {b2JointId} jointId - The identifier for the joint.\r\n * @returns {void} The user data associated with the joint.\r\n * @description\r\n * Retrieves the user data that was previously attached to the specified joint.\r\n * The function first gets the world object from the joint ID, then retrieves\r\n * the joint using the full joint ID, and finally returns the userData property\r\n * of that joint.\r\n */\r\nexport function b2Joint_GetUserData(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n\r\n    return joint.userData;\r\n}\r\n\r\n/**\r\n * @function b2Joint_WakeBodies\r\n * @description\r\n * Wakes up both bodies connected by a joint in the physics simulation.\r\n * @param {b2JointId} jointId - The identifier for the joint whose connected bodies should be awakened.\r\n * @returns {void}\r\n * @throws {Error} If the world reference in the jointId is invalid or cannot be accessed.\r\n */\r\nexport function b2Joint_WakeBodies(jointId)\r\n{\r\n    const world = b2GetWorldLocked(jointId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    const bodyA = world.bodyArray[joint.edges[0].bodyId];\r\n    const bodyB = world.bodyArray[joint.edges[1].bodyId];\r\n\r\n    b2WakeBody(world, bodyA);\r\n    b2WakeBody(world, bodyB);\r\n}\r\n\r\n// External function declarations (these would be implemented elsewhere)\r\n// export function b2GetDistanceJointForce(world, base) {}\r\n// export function b2GetMotorJointForce(world, base) {}\r\n// export function b2GetMouseJointForce(world, base) {}\r\n// export function b2GetPrismaticJointForce(world, base) {}\r\n// export function b2GetRevoluteJointForce(world, base) {}\r\n// export function b2GetWeldJointForce(world, base) {}\r\n// export function b2GetWheelJointForce(world, base) {}\r\n\r\n/**\r\n * Gets the constraint force for a joint.\r\n * @function b2Joint_GetConstraintForce\r\n * @param {b2JointId} jointId - The identifier for the joint.\r\n * @returns {b2Vec2} The constraint force vector. Returns (0,0) for unknown joint types.\r\n * @description\r\n * Returns the constraint force for different joint types including distance, motor,\r\n * mouse, prismatic, revolute, weld, and wheel joints. The force is retrieved from\r\n * the corresponding joint-specific force getter function.\r\n * @throws {Error} Throws an assertion error for unknown joint types.\r\n */\r\nexport function b2Joint_GetConstraintForce(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    const base = b2GetJointSim(world, joint);\r\n\r\n    switch (joint.type)\r\n    {\r\n        case b2JointType.b2_distanceJoint:\r\n            return b2GetDistanceJointForce(world, base);\r\n\r\n        case b2JointType.b2_motorJoint:\r\n            return b2GetMotorJointForce(world, base);\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            return b2GetMouseJointForce(world, base);\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            return b2GetPrismaticJointForce(world, base);\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            return b2GetRevoluteJointForce(world, base);\r\n\r\n        case b2JointType.b2_weldJoint:\r\n            return b2GetWeldJointForce(world, base);\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            return b2GetWheelJointForce(world, base);\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return new b2Vec2(0, 0);\r\n    }\r\n}\r\n\r\n// External function declarations (these would be implemented elsewhere)\r\n// export function b2GetMotorJointTorque(world, base) {}\r\n// export function b2GetMouseJointTorque(world, base) {}\r\n// export function b2GetPrismaticJointTorque(world, base) {}\r\n// export function b2GetRevoluteJointTorque(world, base) {}\r\n// export function b2GetWeldJointTorque(world, base) {}\r\n// export function b2GetWheelJointTorque(world, base) {}\r\n\r\n/**\r\n * @function b2Joint_GetConstraintTorque\r\n * @summary Gets the constraint torque for a joint.\r\n * @param {b2JointId} jointId - The ID of the joint to get the constraint torque from.\r\n * @returns {number} The constraint torque value. Returns 0 for distance joints or if joint type is invalid.\r\n * @description\r\n * Returns the constraint torque for different joint types including motor, mouse, prismatic,\r\n * revolute, weld and wheel joints. For distance joints, it always returns 0.\r\n * @throws {Error} Throws an assertion error if an unsupported joint type is provided.\r\n */\r\nexport function b2Joint_GetConstraintTorque(jointId)\r\n{\r\n    const world = b2GetWorld(jointId.world0);\r\n    const joint = b2GetJointFullId(world, jointId);\r\n    const base = b2GetJointSim(world, joint);\r\n\r\n    switch (joint.type)\r\n    {\r\n        case b2JointType.b2_distanceJoint:\r\n            return 0.0;\r\n\r\n        case b2JointType.b2_motorJoint:\r\n            return b2GetMotorJointTorque(world, base);\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            return b2GetMouseJointTorque(world, base);\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            return b2GetPrismaticJointTorque(world, base);\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            return b2GetRevoluteJointTorque(world, base);\r\n\r\n        case b2JointType.b2_weldJoint:\r\n            return b2GetWeldJointTorque(world, base);\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            return b2GetWheelJointTorque(world, base);\r\n\r\n        default:\r\n            console.assert(false);\r\n\r\n            return 0.0;\r\n    }\r\n}\r\n\r\nexport function b2PrepareJoint(joint, context)\r\n{\r\n    switch (joint.type)\r\n    {\r\n        case b2JointType.b2_distanceJoint:\r\n            b2PrepareDistanceJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_motorJoint:\r\n            b2PrepareMotorJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            b2PrepareMouseJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            b2PreparePrismaticJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            b2PrepareRevoluteJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_weldJoint:\r\n            b2PrepareWeldJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            b2PrepareWheelJoint(joint, context);\r\n\r\n            break;\r\n\r\n        default:\r\n            console.assert(false);\r\n    }\r\n}\r\n\r\nexport function b2WarmStartJoint(joint, context)\r\n{\r\n    switch (joint.type)\r\n    {\r\n        case b2JointType.b2_distanceJoint:\r\n            b2WarmStartDistanceJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_motorJoint:\r\n            b2WarmStartMotorJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            b2WarmStartMouseJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            b2WarmStartPrismaticJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            b2WarmStartRevoluteJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_weldJoint:\r\n            b2WarmStartWeldJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            b2WarmStartWheelJoint(joint, context);\r\n\r\n            break;\r\n\r\n        default:\r\n            console.assert(false);\r\n    }\r\n}\r\n\r\nexport function b2SolveJoint(joint, context, useBias)\r\n{\r\n    switch (joint.type)\r\n    {\r\n        case b2JointType.b2_distanceJoint:\r\n            b2SolveDistanceJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_motorJoint:\r\n            b2SolveMotorJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            b2SolveMouseJoint(joint, context);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            b2SolvePrismaticJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            b2SolveRevoluteJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_weldJoint:\r\n            b2SolveWeldJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            b2SolveWheelJoint(joint, context, useBias);\r\n\r\n            break;\r\n\r\n        default:\r\n            console.assert(false);\r\n    }\r\n}\r\n\r\nexport function b2PrepareOverflowJoints(context)\r\n{\r\n    const graph = context.graph;\r\n    const joints = graph.colors[b2_overflowIndex].joints.data;\r\n    const jointCount = graph.colors[b2_overflowIndex].joints.count;\r\n\r\n    for (let i = 0; i < jointCount; ++i)\r\n    {\r\n        const joint = joints[i];\r\n        b2PrepareJoint(joint, context);\r\n    }\r\n}\r\n\r\nexport function b2WarmStartOverflowJoints(context)\r\n{\r\n    const graph = context.graph;\r\n    const joints = graph.colors[b2_overflowIndex].joints.data;\r\n    const jointCount = graph.colors[b2_overflowIndex].joints.count;\r\n\r\n    for (let i = 0; i < jointCount; ++i)\r\n    {\r\n        const joint = joints[i];\r\n        b2WarmStartJoint(joint, context);\r\n    }\r\n}\r\n\r\nexport function b2SolveOverflowJoints(context, useBias)\r\n{\r\n    const graph = context.graph;\r\n    const joints = graph.colors[b2_overflowIndex].joints.data;\r\n    const jointCount = graph.colors[b2_overflowIndex].joints.count;\r\n\r\n    for (let i = 0; i < jointCount; ++i)\r\n    {\r\n        const joint = joints[i];\r\n        b2SolveJoint(joint, context, useBias);\r\n    }\r\n}\r\n\r\nexport function b2DrawJoint(draw, world, joint)\r\n{\r\n    const bodyA = b2GetBody(world, joint.edges[0].bodyId);\r\n    const bodyB = b2GetBody(world, joint.edges[1].bodyId);\r\n\r\n    if (bodyA.setIndex === b2SetType.b2_disabledSet || bodyB.setIndex === b2SetType.b2_disabledSet)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const jointSim = b2GetJointSim(world, joint);\r\n    console.assert(jointSim);\r\n\r\n    const transformA = b2GetBodyTransformQuick(world, bodyA);\r\n    const transformB = b2GetBodyTransformQuick(world, bodyB);\r\n    const pA = b2TransformPoint(transformA, jointSim.localOriginAnchorA);\r\n    const pB = b2TransformPoint(transformB, jointSim.localOriginAnchorB);\r\n\r\n    const color = b2HexColor.b2_colorDarkSeaGreen;\r\n\r\n    switch (joint.type)\r\n    {\r\n        \r\n        case b2JointType.b2_distanceJoint:\r\n            b2DrawDistanceJoint(draw, jointSim, transformA, transformB);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_mouseJoint:\r\n            {\r\n                const target = jointSim.mouseJoint.targetA;\r\n\r\n                const c1 = b2HexColor.b2_colorGreen;\r\n                draw.DrawPoint(target.x, target.y, 4.0, c1, draw.context);\r\n                draw.DrawPoint(pB.x, pB.y, 4.0, c1, draw.context);\r\n\r\n                const c2 = b2HexColor.b2_colorGray8;\r\n                draw.DrawSegment(target, pB, c2, draw.context);\r\n            }\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_prismaticJoint:\r\n            b2DrawPrismaticJoint(draw, jointSim, transformA, transformB);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_revoluteJoint:\r\n            b2DrawRevoluteJoint(draw, jointSim, transformA, transformB, joint.drawSize);\r\n\r\n            break;\r\n\r\n        case b2JointType.b2_wheelJoint:\r\n            b2DrawWheelJoint(draw, jointSim, transformA, transformB);\r\n\r\n            break;\r\n\r\n        default:\r\n            draw.DrawSegment(transformA.p, pA, color, draw.context);\r\n            draw.DrawSegment(pA, pB, color, draw.context);\r\n            draw.DrawSegment(transformB.p, pB, color, draw.context);\r\n    }\r\n\r\n    if (draw.drawGraphColors)\r\n    {\r\n        const colors = [ b2HexColor.b2_colorRed, b2HexColor.b2_colorOrange, b2HexColor.b2_colorYellow, b2HexColor.b2_colorGreen,\r\n            b2HexColor.b2_colorCyan, b2HexColor.b2_colorBlue, b2HexColor.b2_colorViolet, b2HexColor.b2_colorPink,\r\n            b2HexColor.b2_colorChocolate, b2HexColor.b2_colorGoldenrod, b2HexColor.b2_colorCoral, b2HexColor.b2_colorBlack ];\r\n\r\n        const colorIndex = joint.colorIndex;\r\n\r\n        if (colorIndex !== B2_NULL_INDEX)\r\n        {\r\n            const p = b2Lerp(pA, pB, 0.5);\r\n            draw.DrawPoint(p.x, p.y, 5.0, colors[colorIndex], draw.context);\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Mat22, b2Vec2 } from './math_functions_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './core_h.js';\r\nimport { b2JointType } from './types_h.js';\r\nimport { b2Softness } from './solver_h.js';\r\n\r\nexport class b2JointEdge\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyId = B2_NULL_INDEX;\r\n        this.prevKey = B2_NULL_INDEX;\r\n        this.nextKey = B2_NULL_INDEX;\r\n    }\r\n}\r\n\r\nexport class b2Joint\r\n{\r\n    constructor()\r\n    {\r\n        this.userData = null;\r\n        this.setIndex = B2_NULL_INDEX;\r\n        this.colorIndex = B2_NULL_INDEX;\r\n        this.localIndex = B2_NULL_INDEX;\r\n        this.edges = [ new b2JointEdge(), new b2JointEdge() ];\r\n        this.jointId = B2_NULL_INDEX;\r\n        this.islandId = B2_NULL_INDEX;\r\n        this.islandPrev = B2_NULL_INDEX;\r\n        this.islandNext = B2_NULL_INDEX;\r\n        this.revision = 0;\r\n        this.drawSize = 0;\r\n        this.type = b2JointType.b2_unknown;\r\n        this.isMarked = false;\r\n        this.collideConnected = false;\r\n    }\r\n}\r\n\r\nexport class b2DistanceJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.length = 0;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.minLength = 0;\r\n        this.maxLength = 0;\r\n        this.maxMotorForce = 0;\r\n        this.motorSpeed = 0;\r\n        this.impulse = 0;\r\n        this.lowerImpulse = 0;\r\n        this.upperImpulse = 0;\r\n        this.motorImpulse = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.distanceSoftness = new b2Softness();\r\n        this.axialMass = 0;\r\n        this.enableSpring = false;\r\n        this.enableLimit = false;\r\n        this.enableMotor = false;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const dj = new b2DistanceJoint();\r\n        dj.length = this.length;\r\n        dj.hertz = this.hertz;\r\n        dj.dampingRatio = this.dampingRatio;\r\n        dj.minLength = this.minLength;\r\n        dj.maxLength = this.maxLength;\r\n        dj.maxMotorForce = this.maxMotorForce;\r\n        dj.motorSpeed = this.motorSpeed;\r\n        dj.impulse = this.impulse;\r\n        dj.lowerImpulse = this.lowerImpulse;\r\n        dj.upperImpulse = this.upperImpulse;\r\n        dj.motorImpulse = this.motorImpulse;\r\n        dj.indexA = this.indexA;\r\n        dj.indexB = this.indexB;\r\n        dj.anchorA = this.anchorA.clone();\r\n        dj.anchorB = this.anchorB.clone();\r\n        dj.deltaCenter = this.deltaCenter.clone();\r\n        dj.distanceSoftness = this.distanceSoftness;    // this.distanceSoftness.clone(); PJB it's all primitives, we might get away with a reference copy here\r\n        dj.axialMass = this.axialMass;\r\n        dj.enableSpring = this.enableSpring;\r\n        dj.enableLimit = this.enableLimit;\r\n        dj.enableMotor = this.enableMotor;\r\n\r\n        return dj;\r\n    }\r\n}\r\n\r\nexport class b2MotorJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.linearOffset = new b2Vec2();\r\n        this.angularOffset = 0;\r\n        this.linearImpulse = new b2Vec2();\r\n        this.angularImpulse = 0;\r\n        this.maxForce = 0;\r\n        this.maxTorque = 0;\r\n        this.correctionFactor = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.deltaAngle = 0;\r\n        this.linearMass = new b2Mat22();\r\n        this.angularMass = 0;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const mj = new b2MotorJoint();\r\n        mj.linearOffset = this.linearOffset.clone();\r\n        mj.angularOffset = this.angularOffset;\r\n        mj.linearImpulse = this.linearImpulse.clone();\r\n        mj.angularImpulse = this.angularImpulse;\r\n        mj.maxForce = this.maxForce;\r\n        mj.maxTorque = this.maxTorque;\r\n        mj.correctionFactor = this.correctionFactor;\r\n        mj.indexA = this.indexA;\r\n        mj.indexB = this.indexB;\r\n        mj.anchorA = this.anchorA.clone();\r\n        mj.anchorB = this.anchorB.clone();\r\n        mj.deltaCenter = this.deltaCenter.clone();\r\n        mj.deltaAngle = this.deltaAngle;\r\n        mj.linearMass = this.linearMass.clone();\r\n        mj.angularMass = this.angularMass;\r\n\r\n        return mj;\r\n    }\r\n}\r\n\r\nexport class b2MouseJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.targetA = new b2Vec2();\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.maxForce = 0;\r\n        this.linearImpulse = new b2Vec2();\r\n        this.angularImpulse = 0;\r\n        this.linearSoftness = new b2Softness();\r\n        this.angularSoftness = new b2Softness();\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorB = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.linearMass = new b2Mat22();\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const mj = new b2MouseJoint();\r\n        mj.targetA = this.targetA.clone();\r\n        mj.hertz = this.hertz;\r\n        mj.dampingRatio = this.dampingRatio;\r\n        mj.maxForce = this.maxForce;\r\n        mj.linearImpulse = this.linearImpulse.clone();\r\n        mj.angularImpulse = this.angularImpulse;\r\n        mj.linearSoftness = this.linearSoftness;\r\n        mj.angularSoftness = this.angularSoftness;\r\n        mj.indexB = this.indexB;\r\n        mj.anchorB = this.anchorB.clone();\r\n        mj.deltaCenter = this.deltaCenter.clone();\r\n        mj.linearMass = this.linearMass.clone();\r\n\r\n        return mj;\r\n    }\r\n}\r\n\r\nexport class b2PrismaticJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.localAxisA = new b2Vec2();\r\n        this.impulse = new b2Vec2();\r\n        this.springImpulse = 0;\r\n        this.motorImpulse = 0;\r\n        this.lowerImpulse = 0;\r\n        this.upperImpulse = 0;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.maxMotorForce = 0;\r\n        this.motorSpeed = 0;\r\n        this.referenceAngle = 0;\r\n        this.lowerTranslation = 0;\r\n        this.upperTranslation = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.axisA = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.deltaAngle = 0;\r\n        this.axialMass = 0;\r\n        this.springSoftness = new b2Softness();\r\n        this.enableSpring = false;\r\n        this.enableLimit = false;\r\n        this.enableMotor = false;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const pj = new b2PrismaticJoint();\r\n        pj.localAxisA = this.localAxisA.clone();\r\n        pj.impulse = this.impulse.clone();\r\n        pj.springImpulse = this.springImpulse;\r\n        pj.motorImpulse = this.motorImpulse;\r\n        pj.lowerImpulse = this.lowerImpulse;\r\n        pj.upperImpulse = this.upperImpulse;\r\n        pj.hertz = this.hertz;\r\n        pj.dampingRatio = this.dampingRatio;\r\n        pj.maxMotorForce = this.maxMotorForce;\r\n        pj.motorSpeed = this.motorSpeed;\r\n        pj.referenceAngle = this.referenceAngle;\r\n        pj.lowerTranslation = this.lowerTranslation;\r\n        pj.upperTranslation = this.upperTranslation;\r\n        pj.indexA = this.indexA;\r\n        pj.indexB = this.indexB;\r\n        pj.anchorA = this.anchorA.clone();\r\n        pj.anchorB = this.anchorB.clone();\r\n        pj.axisA = this.axisA.clone();\r\n        pj.deltaCenter = this.deltaCenter.clone();\r\n        pj.deltaAngle = this.deltaAngle;\r\n        pj.axialMass = this.axialMass;\r\n        pj.springSoftness = this.springSoftness.clone();\r\n        pj.enableSpring = this.enableSpring;\r\n        pj.enableLimit = this.enableLimit;\r\n        pj.enableMotor = this.enableMotor;\r\n\r\n        return pj;\r\n    }\r\n}\r\n\r\nexport class b2RevoluteJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.linearImpulse = new b2Vec2();\r\n        this.springImpulse = 0;\r\n        this.motorImpulse = 0;\r\n        this.lowerImpulse = 0;\r\n        this.upperImpulse = 0;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.maxMotorTorque = 0;\r\n        this.motorSpeed = 0;\r\n        this.referenceAngle = 0;\r\n        this.lowerAngle = 0;\r\n        this.upperAngle = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.deltaAngle = 0;\r\n        this.axialMass = 0;\r\n        this.springSoftness = new b2Softness();\r\n        this.enableSpring = false;\r\n        this.enableMotor = false;\r\n        this.enableLimit = false;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const rj = new b2RevoluteJoint();\r\n        rj.linearImpulse = this.linearImpulse.clone();\r\n        rj.springImpulse = this.springImpulse;\r\n        rj.motorImpulse = this.motorImpulse;\r\n        rj.lowerImpulse = this.lowerImpulse;\r\n        rj.upperImpulse = this.upperImpulse;\r\n        rj.hertz = this.hertz;\r\n        rj.dampingRatio = this.dampingRatio;\r\n        rj.maxMotorTorque = this.maxMotorTorque;\r\n        rj.motorSpeed = this.motorSpeed;\r\n        rj.referenceAngle = this.referenceAngle;\r\n        rj.lowerAngle = this.lowerAngle;\r\n        rj.upperAngle = this.upperAngle;\r\n        rj.indexA = this.indexA;\r\n        rj.indexB = this.indexB;\r\n        rj.anchorA = this.anchorA.clone();\r\n        rj.anchorB = this.anchorB.clone();\r\n        rj.deltaCenter = this.deltaCenter.clone();\r\n        rj.deltaAngle = this.deltaAngle;\r\n        rj.axialMass = this.axialMass;\r\n        rj.springSoftness = this.springSoftness;\r\n        rj.enableSpring = this.enableSpring;\r\n        rj.enableMotor = this.enableMotor;\r\n        rj.enableLimit = this.enableLimit;\r\n\r\n        return rj;\r\n    }\r\n}\r\n\r\nexport class b2WeldJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.referenceAngle = 0;\r\n        this.linearHertz = 0;\r\n        this.linearDampingRatio = 0;\r\n        this.angularHertz = 0;\r\n        this.angularDampingRatio = 0;\r\n        this.linearSoftness = new b2Softness();\r\n        this.angularSoftness = new b2Softness();\r\n        this.linearImpulse = new b2Vec2();\r\n        this.angularImpulse = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.deltaAngle = 0;\r\n        this.axialMass = 0;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const wj = new b2WeldJoint();\r\n        wj.referenceAngle = this.referenceAngle;\r\n        wj.linearHertz = this.linearHertz;\r\n        wj.linearDampingRatio = this.linearDampingRatio;\r\n        wj.angularHertz = this.angularHertz;\r\n        wj.angularDampingRatio = this.angularDampingRatio;\r\n        wj.linearSoftness = this.linearSoftness;\r\n        wj.angularSoftness = this.angularSoftness;\r\n        wj.linearImpulse = this.linearImpulse.clone();\r\n        wj.angularImpulse = this.angularImpulse;\r\n        wj.indexA = this.indexA;\r\n        wj.indexB = this.indexB;\r\n        wj.anchorA = this.anchorA.clone();\r\n        wj.anchorB = this.anchorB.clone();\r\n        wj.deltaCenter = this.deltaCenter.clone();\r\n        wj.deltaAngle = this.deltaAngle;\r\n        wj.axialMass = this.axialMass;\r\n\r\n        return wj;\r\n    }\r\n}\r\n\r\nexport class b2WheelJoint\r\n{\r\n    constructor()\r\n    {\r\n        this.localAxisA = new b2Vec2();\r\n        this.perpImpulse = 0;\r\n        this.motorImpulse = 0;\r\n        this.springImpulse = 0;\r\n        this.lowerImpulse = 0;\r\n        this.upperImpulse = 0;\r\n        this.maxMotorTorque = 0;\r\n        this.motorSpeed = 0;\r\n        this.lowerTranslation = 0;\r\n        this.upperTranslation = 0;\r\n        this.hertz = 0;\r\n        this.dampingRatio = 0;\r\n        this.indexA = B2_NULL_INDEX;\r\n        this.indexB = B2_NULL_INDEX;\r\n        this.anchorA = new b2Vec2();\r\n        this.anchorB = new b2Vec2();\r\n        this.axisA = new b2Vec2();\r\n        this.deltaCenter = new b2Vec2();\r\n        this.perpMass = 0;\r\n        this.motorMass = 0;\r\n        this.axialMass = 0;\r\n        this.springSoftness = new b2Softness();\r\n        this.enableSpring = false;\r\n        this.enableMotor = false;\r\n        this.enableLimit = false;\r\n    }\r\n\r\n    clone()\r\n    {\r\n        const wj = new b2WheelJoint();\r\n        wj.localAxisA = this.localAxisA.clone();\r\n        wj.perpImpulse = this.perpImpulse;\r\n        wj.motorImpulse = this.motorImpulse;\r\n        wj.springImpulse = this.springImpulse;\r\n        wj.lowerImpulse = this.lowerImpulse;\r\n        wj.upperImpulse = this.upperImpulse;\r\n        wj.maxMotorTorque = this.maxMotorTorque;\r\n        wj.motorSpeed = this.motorSpeed;\r\n        wj.lowerTranslation = this.lowerTranslation;\r\n        wj.upperTranslation = this.upperTranslation;\r\n        wj.hertz = this.hertz;\r\n        wj.dampingRatio = this.dampingRatio;\r\n        wj.indexA = this.indexA;\r\n        wj.indexB = this.indexB;\r\n        wj.anchorA = this.anchorA.clone();\r\n        wj.anchorB = this.anchorB.clone();\r\n        wj.axisA = this.axisA.clone();\r\n        wj.deltaCenter = this.deltaCenter.clone();\r\n        wj.perpMass = this.perpMass;\r\n        wj.motorMass = this.motorMass;\r\n        wj.axialMass = this.axialMass;\r\n        wj.springSoftness = this.springSoftness;\r\n        wj.enableSpring = this.enableSpring;\r\n        wj.enableMotor = this.enableMotor;\r\n        wj.enableLimit = this.enableLimit;\r\n\r\n        return wj;\r\n    }\r\n}\r\n\r\nexport class b2JointSim\r\n{\r\n    constructor()\r\n    {\r\n        this.jointId = B2_NULL_INDEX;\r\n        this.bodyIdA = B2_NULL_INDEX;\r\n        this.bodyIdB = B2_NULL_INDEX;\r\n        this.type = b2JointType.b2_unknown;\r\n        this.localOriginAnchorA = new b2Vec2();\r\n        this.localOriginAnchorB = new b2Vec2();\r\n        this.invMassA = 0;\r\n        this.invMassB = 0;\r\n        this.invIA = 0;\r\n        this.invIB = 0;\r\n        this.joint = null;\r\n\r\n        // in C these joints are in a union\r\n        // (shouldn't matter that they're separate here, unless there's any sneaky type swapping being done)\r\n        this.distanceJoint = null;\r\n        this.motorJoint = null;\r\n        this.mouseJoint = null;\r\n        this.revoluteJoint = null;\r\n        this.prismaticJoint = null;\r\n        this.weldJoint = null;\r\n        this.wheelJoint = null;\r\n    }\r\n\r\n    copyTo(dst)\r\n    {\r\n        dst.jointId = this.jointId;\r\n        dst.bodyIdA = this.bodyIdA;\r\n        dst.bodyIdB = this.bodyIdB;\r\n        dst.type = this.type;\r\n        dst.localOriginAnchorA = this.localOriginAnchorA.clone();\r\n        dst.localOriginAnchorB = this.localOriginAnchorB.clone();\r\n        dst.invMassA = this.invMassA;\r\n        dst.invMassB = this.invMassB;\r\n        dst.invIA = this.invIA;\r\n        dst.invIB = this.invIB;\r\n        dst.joint = this.joint;\r\n        dst.distanceJoint = (this.distanceJoint ? this.distanceJoint.clone() : null);\r\n        dst.motorJoint = (this.motorJoint ? this.motorJoint.clone() : null);\r\n        dst.mouseJoint = (this.mouseJoint ? this.mouseJoint.clone() : null);\r\n        dst.revoluteJoint = (this.revoluteJoint ? this.revoluteJoint.clone() : null);\r\n        dst.prismaticJoint = (this.prismaticJoint ? this.prismaticJoint.clone() : null);\r\n        dst.weldJoint = (this.weldJoint ? this.weldJoint.clone() : null);\r\n        dst.wheelJoint = (this.wheelJoint ? this.wheelJoint.clone() : null);\r\n    }\r\n}\r\n\r\nexport {\r\n    b2GetJoint, b2DestroyJointInternal, b2DestroyJoint, b2PrepareJoint, b2WarmStartJoint, b2SolveJoint, b2DrawJoint,\r\n    b2GetJointSim, b2GetJointSimCheckType,\r\n    b2PrepareOverflowJoints, b2WarmStartOverflowJoints, b2SolveOverflowJoints,\r\n    b2CreateRevoluteJoint, b2CreateWheelJoint, b2CreateWeldJoint, b2CreatePrismaticJoint, b2CreateDistanceJoint, b2CreateMotorJoint, b2CreateMouseJoint,\r\n    b2Joint_WakeBodies, b2Joint_GetBodyA, b2Joint_GetBodyB, b2Joint_GetCollideConnected, b2Joint_GetConstraintForce, b2Joint_GetConstraintTorque, b2Joint_GetLocalAnchorA, b2Joint_GetLocalAnchorB,\r\n    b2Joint_GetType, b2Joint_GetUserData, b2Joint_SetUserData, b2Joint_SetCollideConnected,\r\n    b2DefaultDistanceJointDef,b2DefaultMotorJointDef,b2DefaultMouseJointDef,b2DefaultPrismaticJointDef,b2DefaultRevoluteJointDef,b2DefaultWeldJointDef,b2DefaultWheelJointDef\r\n} from '../joint_c.js';\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2AddIsland, b2RemoveIsland } from './include/block_array_h.js';\r\nimport { b2AllocId, b2FreeId, b2GetIdCount } from './include/id_pool_h.js';\r\nimport { b2CheckIndex, b2SetType, b2ValidateConnectivity } from './include/world_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2ContactFlags } from './include/contact_h.js';\r\nimport { b2GetBody } from './include/body_h.js';\r\nimport { b2GetJoint } from './include/joint_h.js';\r\nimport { b2Validation } from './include/types_h.js';\r\nimport { b2WakeSolverSet } from './include/solver_set_h.js';\r\n\r\n/**\r\n * @namespace Island\r\n */\r\n\r\n// Persistent island for awake bodies, joints, and contacts\r\n// https://en.wikipedia.org/wiki/Component_(graph_theory)\r\n// https://en.wikipedia.org/wiki/Dynamic_connectivity\r\n// map from int to solver set and index\r\nexport class b2Island\r\n{\r\n    setIndex = 0;\r\n    localIndex = 0;\r\n    islandId = 0;\r\n    headBody = 0;\r\n    tailBody = 0;\r\n    bodyCount = 0;\r\n    headContact = 0;\r\n    tailContact = 0;\r\n    contactCount = 0;\r\n    headJoint = 0;\r\n    tailJoint = 0;\r\n    jointCount = 0;\r\n    parentIsland = 0;\r\n    constraintRemoveCount = 0;\r\n}\r\n\r\nexport class b2IslandSim\r\n{\r\n    islandId = 0;\r\n}\r\n\r\nexport function b2CreateIsland(world, setIndex)\r\n{\r\n    console.assert(setIndex === b2SetType.b2_awakeSet || setIndex >= b2SetType.b2_firstSleepingSet);\r\n\r\n    const islandId = b2AllocId(world.islandIdPool);\r\n\r\n    if (islandId === world.islandArray.length)\r\n    {\r\n        const emptyIsland = new b2Island();\r\n        emptyIsland.setIndex = B2_NULL_INDEX;   // { setIndex: B2_NULL_INDEX };\r\n        world.islandArray.push(emptyIsland);\r\n    }\r\n    else\r\n    {\r\n        console.assert(world.islandArray[islandId].setIndex === B2_NULL_INDEX);\r\n    }\r\n\r\n    // b2CheckIndex(world.solverSetArray, setIndex);\r\n    const set = world.solverSetArray[setIndex];\r\n\r\n    const island = world.islandArray[islandId];\r\n    island.setIndex = setIndex;\r\n    island.localIndex = set.islands.count;\r\n    island.islandId = islandId;\r\n    island.headBody = B2_NULL_INDEX;\r\n    island.tailBody = B2_NULL_INDEX;\r\n    island.bodyCount = 0;\r\n    island.headContact = B2_NULL_INDEX;\r\n    island.tailContact = B2_NULL_INDEX;\r\n    island.contactCount = 0;\r\n    island.headJoint = B2_NULL_INDEX;\r\n    island.tailJoint = B2_NULL_INDEX;\r\n    island.jointCount = 0;\r\n    island.parentIsland = B2_NULL_INDEX;\r\n    island.constraintRemoveCount = 0;\r\n\r\n    const islandSim = b2AddIsland(set.islands);\r\n    islandSim.islandId = islandId;\r\n\r\n    return island;\r\n}\r\n\r\nexport function b2DestroyIsland(world, islandId)\r\n{\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n\r\n    // b2CheckIndex(world.solverSetArray, island.setIndex);\r\n    const set = world.solverSetArray[island.setIndex];\r\n    const movedIndex = b2RemoveIsland(set.islands, island.localIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        const movedElement = set.islands.data[island.localIndex];\r\n        const movedId = movedElement.islandId;\r\n        const movedIsland = world.islandArray[movedId];\r\n        console.assert(movedIsland.localIndex === movedIndex);\r\n        movedIsland.localIndex = island.localIndex;\r\n    }\r\n\r\n    island.islandId = B2_NULL_INDEX;\r\n    island.setIndex = B2_NULL_INDEX;\r\n    island.localIndex = B2_NULL_INDEX;\r\n    b2FreeId(world.islandIdPool, islandId);\r\n}\r\n\r\nexport function b2GetIsland(world, islandId)\r\n{\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    return world.islandArray[islandId];\r\n}\r\n\r\nfunction b2AddContactToIsland(world, islandId, contact)\r\n{\r\n    console.assert(contact.islandId === B2_NULL_INDEX);\r\n    console.assert(contact.islandPrev === B2_NULL_INDEX);\r\n    console.assert(contact.islandNext === B2_NULL_INDEX);\r\n\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n\r\n    if (island.headContact !== B2_NULL_INDEX)\r\n    {\r\n        contact.islandNext = island.headContact;\r\n\r\n        // b2CheckIndex(world.contactArray, island.headContact);\r\n        const headContact = world.contactArray[island.headContact];\r\n        headContact.islandPrev = contact.contactId;\r\n    }\r\n\r\n    island.headContact = contact.contactId;\r\n\r\n    if (island.tailContact === B2_NULL_INDEX)\r\n    {\r\n        island.tailContact = island.headContact;\r\n    }\r\n\r\n    island.contactCount += 1;\r\n    contact.islandId = islandId;\r\n\r\n    b2ValidateIsland(world, islandId);\r\n}\r\n\r\nexport function b2LinkContact(world, contact)\r\n{\r\n    console.assert((contact.flags & b2ContactFlags.b2_contactTouchingFlag) !== 0 && (contact.flags & b2ContactFlags.b2_contactSensorFlag) === 0);\r\n\r\n    const bodyIdA = contact.edges[0].bodyId;\r\n    const bodyIdB = contact.edges[1].bodyId;\r\n\r\n    const bodyA = b2GetBody(world, bodyIdA);\r\n    const bodyB = b2GetBody(world, bodyIdB);\r\n\r\n    console.assert(bodyA.setIndex !== b2SetType.b2_disabledSet && bodyB.setIndex !== b2SetType.b2_disabledSet);\r\n    console.assert(bodyA.setIndex !== b2SetType.b2_staticSet || bodyB.setIndex !== b2SetType.b2_staticSet);\r\n\r\n    if (bodyA.setIndex === b2SetType.b2_awakeSet && bodyB.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeSolverSet(world, bodyB.setIndex);\r\n    }\r\n\r\n    if (bodyB.setIndex === b2SetType.b2_awakeSet && bodyA.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeSolverSet(world, bodyA.setIndex);\r\n    }\r\n\r\n    let islandIdA = bodyA.islandId;\r\n    let islandIdB = bodyB.islandId;\r\n\r\n    console.assert(bodyA.setIndex !== b2SetType.b2_staticSet || islandIdA === B2_NULL_INDEX);\r\n    console.assert(bodyB.setIndex !== b2SetType.b2_staticSet || islandIdB === B2_NULL_INDEX);\r\n    console.assert(islandIdA !== B2_NULL_INDEX || islandIdB !== B2_NULL_INDEX);\r\n\r\n    if (islandIdA === islandIdB)\r\n    {\r\n        b2AddContactToIsland(world, islandIdA, contact);\r\n\r\n        return;\r\n    }\r\n\r\n    let islandA = null;\r\n\r\n    if (islandIdA !== B2_NULL_INDEX)\r\n    {\r\n        islandA = b2GetIsland(world, islandIdA);\r\n        let parentId = islandA.parentIsland;\r\n\r\n        while (parentId !== B2_NULL_INDEX)\r\n        {\r\n            const parent = b2GetIsland(world, parentId);\r\n\r\n            if (parent.parentIsland !== B2_NULL_INDEX)\r\n            {\r\n                islandA.parentIsland = parent.parentIsland;\r\n            }\r\n\r\n            islandA = parent;\r\n            islandIdA = parentId;\r\n            parentId = islandA.parentIsland;\r\n        }\r\n    }\r\n\r\n    let islandB = null;\r\n\r\n    if (islandIdB !== B2_NULL_INDEX)\r\n    {\r\n        islandB = b2GetIsland(world, islandIdB);\r\n        let parentId = islandB.parentIsland;\r\n\r\n        while (islandB.parentIsland !== B2_NULL_INDEX)\r\n        {\r\n            const parent = b2GetIsland(world, parentId);\r\n\r\n            if (parent.parentIsland !== B2_NULL_INDEX)\r\n            {\r\n                islandB.parentIsland = parent.parentIsland;\r\n            }\r\n\r\n            islandB = parent;\r\n            islandIdB = parentId;\r\n            parentId = islandB.parentIsland;\r\n        }\r\n    }\r\n\r\n    console.assert(islandA !== null || islandB !== null);\r\n\r\n    if (islandA !== islandB && islandA !== null && islandB !== null)\r\n    {\r\n        console.assert(islandA !== islandB);\r\n        console.assert(islandB.parentIsland === B2_NULL_INDEX);\r\n        islandB.parentIsland = islandIdA;\r\n    }\r\n\r\n    if (islandA !== null)\r\n    {\r\n        b2AddContactToIsland(world, islandIdA, contact);\r\n    }\r\n    else\r\n    {\r\n        b2AddContactToIsland(world, islandIdB, contact);\r\n    }\r\n}\r\n\r\nexport function b2UnlinkContact(world, contact)\r\n{\r\n    console.assert((contact.flags & b2ContactFlags.b2_contactSensorFlag) === 0);\r\n    console.assert(contact.islandId !== B2_NULL_INDEX);\r\n\r\n    const islandId = contact.islandId;\r\n\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = b2GetIsland(world, islandId);\r\n\r\n    if (contact.islandPrev !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(world.contactArray, contact.islandPrev);\r\n        const prevContact = world.contactArray[contact.islandPrev];\r\n        console.assert(prevContact.islandNext === contact.contactId);\r\n        prevContact.islandNext = contact.islandNext;\r\n    }\r\n\r\n    if (contact.islandNext !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(world.contactArray, contact.islandNext);\r\n        const nextContact = world.contactArray[contact.islandNext];\r\n        console.assert(nextContact.islandPrev === contact.contactId);\r\n        nextContact.islandPrev = contact.islandPrev;\r\n    }\r\n\r\n    if (island.headContact === contact.contactId)\r\n    {\r\n        island.headContact = contact.islandNext;\r\n    }\r\n\r\n    if (island.tailContact === contact.contactId)\r\n    {\r\n        island.tailContact = contact.islandPrev;\r\n    }\r\n\r\n    console.assert(island.contactCount > 0);\r\n    island.contactCount -= 1;\r\n    island.constraintRemoveCount += 1;\r\n\r\n    contact.islandId = B2_NULL_INDEX;\r\n    contact.islandPrev = B2_NULL_INDEX;\r\n    contact.islandNext = B2_NULL_INDEX;\r\n\r\n    b2ValidateIsland(world, islandId);\r\n}\r\n\r\nfunction b2AddJointToIsland(world, islandId, joint)\r\n{\r\n    console.assert(joint.islandId === B2_NULL_INDEX);\r\n    console.assert(joint.islandPrev === B2_NULL_INDEX);\r\n    console.assert(joint.islandNext === B2_NULL_INDEX);\r\n\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n\r\n    if (island.headJoint !== B2_NULL_INDEX)\r\n    {\r\n        joint.islandNext = island.headJoint;\r\n        const headJoint = b2GetJoint(world, island.headJoint);\r\n        headJoint.islandPrev = joint.jointId;\r\n    }\r\n\r\n    island.headJoint = joint.jointId;\r\n\r\n    if (island.tailJoint === B2_NULL_INDEX)\r\n    {\r\n        island.tailJoint = island.headJoint;\r\n    }\r\n\r\n    island.jointCount += 1;\r\n    joint.islandId = islandId;\r\n\r\n    b2ValidateIsland(world, islandId);\r\n}\r\n\r\nexport function b2LinkJoint(world, joint, mergeIslands)\r\n{\r\n    const bodyA = b2GetBody(world, joint.edges[0].bodyId);\r\n    const bodyB = b2GetBody(world, joint.edges[1].bodyId);\r\n\r\n    if (bodyA.setIndex === b2SetType.b2_awakeSet && bodyB.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeSolverSet(world, bodyB.setIndex);\r\n    }\r\n    else if (bodyB.setIndex === b2SetType.b2_awakeSet && bodyA.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeSolverSet(world, bodyA.setIndex);\r\n    }\r\n\r\n    let islandIdA = bodyA.islandId;\r\n    let islandIdB = bodyB.islandId;\r\n\r\n    console.assert(islandIdA !== B2_NULL_INDEX || islandIdB !== B2_NULL_INDEX);\r\n\r\n    if (islandIdA === islandIdB)\r\n    {\r\n        b2AddJointToIsland(world, islandIdA, joint);\r\n\r\n        return;\r\n    }\r\n\r\n    let islandA = null;\r\n\r\n    if (islandIdA !== B2_NULL_INDEX)\r\n    {\r\n        islandA = b2GetIsland(world, islandIdA);\r\n\r\n        while (islandA.parentIsland !== B2_NULL_INDEX)\r\n        {\r\n            const parent = b2GetIsland(world, islandA.parentIsland);\r\n\r\n            if (parent.parentIsland !== B2_NULL_INDEX)\r\n            {\r\n                islandA.parentIsland = parent.parentIsland;\r\n            }\r\n\r\n            islandIdA = islandA.parentIsland;\r\n            islandA = parent;\r\n        }\r\n    }\r\n\r\n    let islandB = null;\r\n\r\n    if (islandIdB !== B2_NULL_INDEX)\r\n    {\r\n        islandB = b2GetIsland(world, islandIdB);\r\n\r\n        while (islandB.parentIsland !== B2_NULL_INDEX)\r\n        {\r\n            const parent = b2GetIsland(world, islandB.parentIsland);\r\n\r\n            if (parent.parentIsland !== B2_NULL_INDEX)\r\n            {\r\n                islandB.parentIsland = parent.parentIsland;\r\n            }\r\n\r\n            islandIdB = islandB.parentIsland;\r\n            islandB = parent;\r\n        }\r\n    }\r\n\r\n    console.assert(islandA !== null || islandB !== null);\r\n\r\n    if (islandA !== islandB && islandA !== null && islandB !== null)\r\n    {\r\n        console.assert(islandA !== islandB);\r\n        console.assert(islandB.parentIsland === B2_NULL_INDEX);\r\n        islandB.parentIsland = islandIdA;\r\n    }\r\n\r\n    if (islandA !== null)\r\n    {\r\n        b2AddJointToIsland(world, islandIdA, joint);\r\n    }\r\n    else\r\n    {\r\n        b2AddJointToIsland(world, islandIdB, joint);\r\n    }\r\n\r\n    // Joints need to have islands merged immediately when they are created\r\n    // to keep the island graph valid.\r\n    // However, when a body type is being changed the merge can be deferred until\r\n    // all joints are linked.\r\n    if (mergeIslands)\r\n    {\r\n        b2MergeAwakeIslands(world);\r\n    }\r\n}\r\n\r\nexport function b2UnlinkJoint(world, joint)\r\n{\r\n    console.assert(joint.islandId !== B2_NULL_INDEX);\r\n\r\n    const islandId = joint.islandId;\r\n\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n\r\n    if (joint.islandPrev !== B2_NULL_INDEX)\r\n    {\r\n        const prevJoint = b2GetJoint(world, joint.islandPrev);\r\n        console.assert(prevJoint.islandNext === joint.jointId);\r\n        prevJoint.islandNext = joint.islandNext;\r\n    }\r\n\r\n    if (joint.islandNext !== B2_NULL_INDEX)\r\n    {\r\n        const nextJoint = b2GetJoint(world, joint.islandNext);\r\n        console.assert(nextJoint.islandPrev === joint.jointId);\r\n        nextJoint.islandPrev = joint.islandPrev;\r\n    }\r\n\r\n    if (island.headJoint === joint.jointId)\r\n    {\r\n        island.headJoint = joint.islandNext;\r\n    }\r\n\r\n    if (island.tailJoint === joint.jointId)\r\n    {\r\n        island.tailJoint = joint.islandPrev;\r\n    }\r\n\r\n    console.assert(island.jointCount > 0);\r\n    island.jointCount -= 1;\r\n    island.constraintRemoveCount += 1;\r\n\r\n    joint.islandId = B2_NULL_INDEX;\r\n    joint.islandPrev = B2_NULL_INDEX;\r\n    joint.islandNext = B2_NULL_INDEX;\r\n\r\n    b2ValidateIsland(world, islandId);\r\n}\r\n\r\nfunction b2MergeIsland(world, island)\r\n{\r\n    console.assert(island.parentIsland !== B2_NULL_INDEX);\r\n\r\n    const rootId = island.parentIsland;\r\n\r\n    // b2CheckIndex(world.islandArray, rootId);\r\n    const rootIsland = world.islandArray[rootId];\r\n    console.assert(rootIsland.parentIsland === B2_NULL_INDEX);\r\n\r\n    let bodyId = island.headBody;\r\n\r\n    while (bodyId !== B2_NULL_INDEX)\r\n    {\r\n        const body = b2GetBody(world, bodyId);\r\n        body.islandId = rootId;\r\n        bodyId = body.islandNext;\r\n    }\r\n\r\n    let contactId = island.headContact;\r\n\r\n    while (contactId !== B2_NULL_INDEX)\r\n    {\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n        contact.islandId = rootId;\r\n        contactId = contact.islandNext;\r\n    }\r\n\r\n    let jointId = island.headJoint;\r\n\r\n    while (jointId !== B2_NULL_INDEX)\r\n    {\r\n        const joint = b2GetJoint(world, jointId);\r\n        joint.islandId = rootId;\r\n        jointId = joint.islandNext;\r\n    }\r\n\r\n    console.assert(rootIsland.tailBody !== B2_NULL_INDEX);\r\n    const tailBody = b2GetBody(world, rootIsland.tailBody);\r\n    console.assert(tailBody.islandNext === B2_NULL_INDEX);\r\n    tailBody.islandNext = island.headBody;\r\n\r\n    console.assert(island.headBody !== B2_NULL_INDEX);\r\n    const headBody = b2GetBody(world, island.headBody);\r\n    console.assert(headBody.islandPrev === B2_NULL_INDEX);\r\n    headBody.islandPrev = rootIsland.tailBody;\r\n\r\n    rootIsland.tailBody = island.tailBody;\r\n    rootIsland.bodyCount += island.bodyCount;\r\n\r\n    if (rootIsland.headContact === B2_NULL_INDEX)\r\n    {\r\n        console.assert(rootIsland.tailContact === B2_NULL_INDEX && rootIsland.contactCount === 0);\r\n        rootIsland.headContact = island.headContact;\r\n        rootIsland.tailContact = island.tailContact;\r\n        rootIsland.contactCount = island.contactCount;\r\n    }\r\n    else if (island.headContact !== B2_NULL_INDEX)\r\n    {\r\n        console.assert(island.tailContact !== B2_NULL_INDEX && island.contactCount > 0);\r\n        console.assert(rootIsland.tailContact !== B2_NULL_INDEX && rootIsland.contactCount > 0);\r\n\r\n        // b2CheckIndex(world.contactArray, rootIsland.tailContact);\r\n        const tailContact = world.contactArray[rootIsland.tailContact];\r\n        console.assert(tailContact.islandNext === B2_NULL_INDEX);\r\n        tailContact.islandNext = island.headContact;\r\n\r\n        // b2CheckIndex(world.contactArray, island.headContact);\r\n        const headContact = world.contactArray[island.headContact];\r\n        console.assert(headContact.islandPrev === B2_NULL_INDEX);\r\n        headContact.islandPrev = rootIsland.tailContact;\r\n\r\n        rootIsland.tailContact = island.tailContact;\r\n        rootIsland.contactCount += island.contactCount;\r\n    }\r\n\r\n    if (rootIsland.headJoint === B2_NULL_INDEX)\r\n    {\r\n        console.assert(rootIsland.tailJoint === B2_NULL_INDEX && rootIsland.jointCount === 0);\r\n        rootIsland.headJoint = island.headJoint;\r\n        rootIsland.tailJoint = island.tailJoint;\r\n        rootIsland.jointCount = island.jointCount;\r\n    }\r\n    else if (island.headJoint !== B2_NULL_INDEX)\r\n    {\r\n        console.assert(island.tailJoint !== B2_NULL_INDEX && island.jointCount > 0);\r\n        console.assert(rootIsland.tailJoint !== B2_NULL_INDEX && rootIsland.jointCount > 0);\r\n\r\n        const tailJoint = b2GetJoint(world, rootIsland.tailJoint);\r\n        console.assert(tailJoint.islandNext === B2_NULL_INDEX);\r\n        tailJoint.islandNext = island.headJoint;\r\n\r\n        const headJoint = b2GetJoint(world, island.headJoint);\r\n        console.assert(headJoint.islandPrev === B2_NULL_INDEX);\r\n        headJoint.islandPrev = rootIsland.tailJoint;\r\n\r\n        rootIsland.tailJoint = island.tailJoint;\r\n        rootIsland.jointCount += island.jointCount;\r\n    }\r\n\r\n    rootIsland.constraintRemoveCount += island.constraintRemoveCount;\r\n\r\n    b2ValidateIsland(world, rootId);\r\n}\r\n\r\nexport function b2MergeAwakeIslands(world)\r\n{\r\n    // b2TracyCZoneNC(\"merge_islands\", \"Merge Islands\", b2HexColor.b2_colorMediumTurquoise, true);\r\n\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    const islandSims = awakeSet.islands.data;\r\n    const awakeIslandCount = awakeSet.islands.count;\r\n    const islands = world.islandArray;\r\n\r\n    for (let i = 0; i < awakeIslandCount; ++i)\r\n    {\r\n        const islandId = islandSims[i].islandId;\r\n\r\n        // b2CheckIndex(islands, islandId);\r\n        const island = islands[islandId];\r\n\r\n        let rootId = islandId;\r\n        let rootIsland = island;\r\n\r\n        while (rootIsland.parentIsland !== B2_NULL_INDEX)\r\n        {\r\n            // b2CheckIndex(islands, rootIsland.parentIsland);\r\n            const parent = islands[rootIsland.parentIsland];\r\n\r\n            if (parent.parentIsland !== B2_NULL_INDEX)\r\n            {\r\n                rootIsland.parentIsland = parent.parentIsland;\r\n            }\r\n\r\n            rootId = rootIsland.parentIsland;\r\n            rootIsland = parent;\r\n        }\r\n\r\n        if (rootIsland !== island)\r\n        {\r\n            island.parentIsland = rootId;\r\n        }\r\n    }\r\n\r\n    for (let i = awakeIslandCount - 1; i >= 0; --i)\r\n    {\r\n        const islandId = islandSims[i].islandId;\r\n\r\n        // b2CheckIndex(islands, islandId);\r\n        const island = islands[islandId];\r\n\r\n        if (island.parentIsland === B2_NULL_INDEX)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        b2MergeIsland(world, island);\r\n\r\n        b2DestroyIsland(world, islandId);\r\n    }\r\n\r\n    b2ValidateConnectivity(world);\r\n\r\n    // b2TracyCZoneEnd(\"merge_islands\");\r\n}\r\n\r\nexport function b2SplitIsland(world, baseId)\r\n{\r\n    // b2CheckIndex(world.islandArray, baseId);\r\n    const baseIsland = world.islandArray[baseId];\r\n    const setIndex = baseIsland.setIndex;\r\n\r\n    if (setIndex !== b2SetType.b2_awakeSet)\r\n    {\r\n        // can only split awake island\r\n        return;\r\n    }\r\n\r\n    if (baseIsland.constraintRemoveCount === 0)\r\n    {\r\n        // this island doesn't need to be split\r\n        return;\r\n    }\r\n\r\n    b2ValidateIsland(world, baseId);\r\n\r\n    const bodyCount = baseIsland.bodyCount;\r\n\r\n    const bodies = world.bodyArray;\r\n    const contacts = world.contactArray;\r\n\r\n    const stack = [];\r\n    const bodyIds = [];\r\n\r\n    // Build array containing all body indices from base island. These\r\n    // serve as seed bodies for the depth first search (DFS).\r\n    let nextBody = baseIsland.headBody;\r\n\r\n    while (nextBody !== B2_NULL_INDEX)\r\n    {\r\n        bodyIds.push(nextBody);\r\n        const body = bodies[nextBody];\r\n\r\n        // Clear visitation mark\r\n        body.isMarked = false;\r\n\r\n        nextBody = body.islandNext;\r\n    }\r\n    console.assert(bodyIds.length === bodyCount);\r\n\r\n    // Clear contact island flags. Only need to consider contacts\r\n    // already in the base island.\r\n    let nextContactId = baseIsland.headContact;\r\n\r\n    while (nextContactId !== B2_NULL_INDEX)\r\n    {\r\n        const contact = contacts[nextContactId];\r\n        contact.isMarked = false;\r\n        nextContactId = contact.islandNext;\r\n    }\r\n\r\n    // Clear joint island flags.\r\n    let nextJoint = baseIsland.headJoint;\r\n\r\n    while (nextJoint !== B2_NULL_INDEX)\r\n    {\r\n        const joint = b2GetJoint(world, nextJoint);\r\n        joint.isMarked = false;\r\n        nextJoint = joint.islandNext;\r\n    }\r\n\r\n    // Done with the base split island.\r\n    b2DestroyIsland(world, baseId);\r\n\r\n    // Each island is found as a depth first search starting from a seed body\r\n    for (let i = 0; i < bodyCount; ++i)\r\n    {\r\n        const seedIndex = bodyIds[i];\r\n        const seed = bodies[seedIndex];\r\n        console.assert(seed.setIndex === setIndex);\r\n\r\n        if (seed.isMarked === true)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        stack.push(seedIndex);\r\n        seed.isMarked = true;\r\n\r\n        const island = b2CreateIsland(world, setIndex);\r\n\r\n        const islandId = island.islandId;\r\n\r\n        while (stack.length > 0)\r\n        {\r\n            const bodyId = stack.pop();\r\n            const body = bodies[bodyId];\r\n            console.assert(body.setIndex === b2SetType.b2_awakeSet);\r\n            console.assert(body.isMarked === true);\r\n\r\n            body.islandId = islandId;\r\n\r\n            if (island.tailBody !== B2_NULL_INDEX)\r\n            {\r\n                bodies[island.tailBody].islandNext = bodyId;\r\n            }\r\n            body.islandPrev = island.tailBody;\r\n            body.islandNext = B2_NULL_INDEX;\r\n            island.tailBody = bodyId;\r\n\r\n            if (island.headBody === B2_NULL_INDEX)\r\n            {\r\n                island.headBody = bodyId;\r\n            }\r\n\r\n            island.bodyCount += 1;\r\n\r\n            let contactKey = body.headContactKey;\r\n\r\n            while (contactKey !== B2_NULL_INDEX)\r\n            {\r\n                const contactId = contactKey >> 1;\r\n                const edgeIndex = contactKey & 1;\r\n\r\n                // b2CheckIndex(world.contactArray, contactId);\r\n                const contact = world.contactArray[contactId];\r\n                console.assert(contact.contactId === contactId);\r\n\r\n                contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n                if (contact.isMarked)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (contact.flags & b2ContactFlags.b2_contactSensorFlag)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if ((contact.flags & b2ContactFlags.b2_contactTouchingFlag) === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                contact.isMarked = true;\r\n\r\n                const otherEdgeIndex = edgeIndex ^ 1;\r\n                const otherBodyId = contact.edges[otherEdgeIndex].bodyId;\r\n                const otherBody = bodies[otherBodyId];\r\n\r\n                if (otherBody.isMarked === false && otherBody.setIndex !== b2SetType.b2_staticSet)\r\n                {\r\n                    console.assert(stack.length < bodyCount);\r\n                    stack.push(otherBodyId);\r\n                    otherBody.isMarked = true;\r\n                }\r\n\r\n                contact.islandId = islandId;\r\n\r\n                if (island.tailContact !== B2_NULL_INDEX)\r\n                {\r\n                    // b2CheckIndex(world.contactArray, island.tailContact);\r\n                    const tailContact = world.contactArray[island.tailContact];\r\n                    tailContact.islandNext = contactId;\r\n                }\r\n                contact.islandPrev = island.tailContact;\r\n                contact.islandNext = B2_NULL_INDEX;\r\n                island.tailContact = contactId;\r\n\r\n                if (island.headContact === B2_NULL_INDEX)\r\n                {\r\n                    island.headContact = contactId;\r\n                }\r\n\r\n                island.contactCount += 1;\r\n            }\r\n\r\n            let jointKey = body.headJointKey;\r\n\r\n            while (jointKey !== B2_NULL_INDEX)\r\n            {\r\n                const jointId = jointKey >> 1;\r\n                const edgeIndex = jointKey & 1;\r\n\r\n                const joint = b2GetJoint(world, jointId);\r\n                console.assert(joint.jointId === jointId);\r\n\r\n                jointKey = joint.edges[edgeIndex].nextKey;\r\n\r\n                if (joint.isMarked)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                joint.isMarked = true;\r\n\r\n                const otherEdgeIndex = edgeIndex ^ 1;\r\n                const otherBodyId = joint.edges[otherEdgeIndex].bodyId;\r\n                const otherBody = bodies[otherBodyId];\r\n\r\n                if (otherBody.setIndex === b2SetType.b2_disabledSet)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (otherBody.isMarked === false && otherBody.setIndex === b2SetType.b2_awakeSet)\r\n                {\r\n                    stack.push(otherBodyId);\r\n                    otherBody.isMarked = true;\r\n                }\r\n\r\n                joint.islandId = islandId;\r\n\r\n                if (island.tailJoint !== B2_NULL_INDEX)\r\n                {\r\n                    const tailJoint = b2GetJoint(world, island.tailJoint);\r\n                    tailJoint.islandNext = jointId;\r\n                }\r\n                joint.islandPrev = island.tailJoint;\r\n                joint.islandNext = B2_NULL_INDEX;\r\n                island.tailJoint = jointId;\r\n\r\n                if (island.headJoint === B2_NULL_INDEX)\r\n                {\r\n                    island.headJoint = jointId;\r\n                }\r\n\r\n                island.jointCount += 1;\r\n            }\r\n        }\r\n\r\n        b2ValidateIsland(world, islandId);\r\n    }\r\n\r\n    // b2FreeStackItem(alloc, bodyIds);\r\n    // b2FreeStackItem(alloc, stack);\r\n}\r\n\r\nexport function b2ValidateIsland(world, islandId)\r\n{\r\n    if (!b2Validation) { return; }\r\n    \r\n    b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n    console.assert(island.islandId == islandId);\r\n    console.assert(island.setIndex != B2_NULL_INDEX);\r\n    console.assert(island.headBody != B2_NULL_INDEX);\r\n\r\n    {\r\n        const bodies = world.bodyArray;\r\n        console.assert(island.tailBody != B2_NULL_INDEX);\r\n        console.assert(island.bodyCount > 0);\r\n\r\n        if (island.bodyCount > 1)\r\n        {\r\n            console.assert(island.tailBody != island.headBody);\r\n        }\r\n        console.assert(island.bodyCount <= b2GetIdCount(world.bodyIdPool));\r\n\r\n        let count = 0;\r\n        let bodyId = island.headBody;\r\n\r\n        while (bodyId != B2_NULL_INDEX)\r\n        {\r\n            b2CheckIndex(bodies, bodyId);\r\n            const body = bodies[bodyId];\r\n            console.assert(body.islandId == islandId);\r\n            console.assert(body.setIndex == island.setIndex);\r\n            count += 1;\r\n\r\n            if (count == island.bodyCount)\r\n            {\r\n                console.assert(bodyId == island.tailBody);\r\n            }\r\n\r\n            bodyId = body.islandNext;\r\n        }\r\n        console.assert(count == island.bodyCount);\r\n    }\r\n\r\n    if (island.headContact != B2_NULL_INDEX)\r\n    {\r\n        console.assert(island.tailContact != B2_NULL_INDEX);\r\n        console.assert(island.contactCount > 0);\r\n\r\n        if (island.contactCount > 1)\r\n        {\r\n            console.assert(island.tailContact != island.headContact);\r\n        }\r\n        console.assert(island.contactCount <= b2GetIdCount(world.contactIdPool));\r\n\r\n        let count = 0;\r\n        let contactId = island.headContact;\r\n\r\n        while (contactId != B2_NULL_INDEX)\r\n        {\r\n            b2CheckIndex(world.contactArray, contactId);\r\n            const contact = world.contactArray[contactId];\r\n            console.assert(contact.setIndex == island.setIndex);\r\n            console.assert(contact.islandId == islandId);\r\n            count += 1;\r\n\r\n            if (count == island.contactCount)\r\n            {\r\n                console.assert(contactId == island.tailContact);\r\n            }\r\n\r\n            contactId = contact.islandNext;\r\n        }\r\n        console.assert(count == island.contactCount);\r\n    }\r\n    else\r\n    {\r\n        console.assert(island.tailContact == B2_NULL_INDEX);\r\n        console.assert(island.contactCount == 0);\r\n    }\r\n\r\n    if (island.headJoint != B2_NULL_INDEX)\r\n    {\r\n        console.assert(island.tailJoint != B2_NULL_INDEX);\r\n        console.assert(island.jointCount > 0);\r\n\r\n        if (island.jointCount > 1)\r\n        {\r\n            console.assert(island.tailJoint != island.headJoint);\r\n        }\r\n        console.assert(island.jointCount <= b2GetIdCount(world.jointIdPool));\r\n\r\n        let count = 0;\r\n        let jointId = island.headJoint;\r\n\r\n        while (jointId != B2_NULL_INDEX)\r\n        {\r\n            b2CheckIndex(world.jointArray, jointId);\r\n            const joint = world.jointArray[jointId];\r\n            console.assert(joint.setIndex == island.setIndex);\r\n            count += 1;\r\n\r\n            if (count == island.jointCount)\r\n            {\r\n                console.assert(jointId == island.tailJoint);\r\n            }\r\n\r\n            jointId = joint.islandNext;\r\n        }\r\n        console.assert(count == island.jointCount);\r\n    }\r\n    else\r\n    {\r\n        console.assert(island.tailJoint == B2_NULL_INDEX);\r\n        console.assert(island.jointCount == 0);\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_HUGE, B2_NULL_INDEX, b2_aabbMargin, b2_graphColorCount, b2_speculativeDistance } from './include/core_h.js';\r\nimport { b2AABB, b2AABB_Contains, b2AABB_Union, b2Add, b2Cross, b2CrossSV, b2Dot, b2InvRotateVector, b2InvTransformPoint, b2IsValid, b2LengthSquared, b2MulAdd, b2MulSV, b2Rot, b2Rot_IsValid, b2RotateVector, b2Sub, b2Transform, b2TransformPoint, b2Vec2, b2Vec2_IsValid } from './include/math_functions_h.js';\r\nimport { b2AddBodySim, b2AddBodyState, b2RemoveBodySim, b2RemoveBodyState } from './include/block_array_h.js';\r\nimport { b2AllocId, b2FreeId } from './include/id_pool_h.js';\r\nimport { b2BodyId, b2JointId, b2ShapeId } from './include/id_h.js';\r\nimport { b2ComputeShapeAABB, b2ComputeShapeExtent, b2ComputeShapeMass, b2CreateShapeProxy, b2DestroyShapeProxy } from './include/shape_h.js';\r\nimport { b2ContactFlags, b2DestroyContact, b2GetContactSim } from './include/contact_h.js';\r\nimport { b2CreateIsland, b2DestroyIsland, b2LinkJoint, b2MergeAwakeIslands, b2SplitIsland, b2UnlinkJoint, b2ValidateIsland } from './include/island_h.js';\r\nimport { b2DestroyJointInternal, b2GetJoint } from './include/joint_h.js';\r\nimport { b2DestroySolverSet, b2SolverSet, b2TransferBody, b2TransferJoint, b2TrySleepIsland, b2WakeSolverSet } from './include/solver_set_h.js';\r\nimport { b2GetWorld, b2GetWorldLocked } from './include/world_h.js';\r\nimport { b2GetWorldFromId, b2SetType, b2ValidateConnectivity, b2ValidateSolverSets } from './include/world_h.js';\r\n\r\nimport { b2Body } from './include/body_h.js';\r\nimport { b2BodyType } from './include/types_h.js';\r\nimport { b2Body_IsValid } from './include/world_h.js';\r\nimport { b2BroadPhase_MoveProxy } from './include/broad_phase_h.js';\r\nimport { b2MassData } from './include/collision_h.js';\r\n\r\n/**\r\n * @namespace Body\r\n */\r\n\r\n/**\r\n * @import {b2WorldId} from './include/id_h.js'\r\n * @import {b2BodyDef, b2ContactData} from './include/types_h.js'\r\n */\r\n\r\nexport function b2MakeSweep(bodySim, out)\r\n{\r\n    out.c1.x = bodySim.center0X;\r\n    out.c1.y = bodySim.center0Y;\r\n    out.c2.copy(bodySim.center);\r\n    out.q1.copy(bodySim.rotation0);\r\n    out.q2.copy(bodySim.transform.q);\r\n    out.localCenter.copy(bodySim.localCenter);\r\n\r\n    return out;\r\n}\r\n\r\nexport function b2GetBody(world, bodyId)\r\n{\r\n    return world.bodyArray[bodyId];\r\n}\r\n\r\nexport function b2GetBodyFullId(world, bodyId)\r\n{\r\n    console.assert(b2Body_IsValid(bodyId), `invalid bodyId ${JSON.stringify(bodyId)}\\n${new Error().stack}`);\r\n\r\n    return b2GetBody(world, bodyId.index1 - 1);\r\n}\r\n\r\nexport function b2GetBodyTransformQuick(world, body)\r\n{\r\n    console.assert(0 <= body.setIndex && body.setIndex < world.solverSetArray.length);\r\n    const set = world.solverSetArray[body.setIndex];\r\n    console.assert(0 <= body.localIndex && body.localIndex <= set.sims.count);\r\n    const bodySim = set.sims.data[body.localIndex];\r\n    console.assert(bodySim.transform != null);\r\n    console.assert(bodySim.transform.p != null);\r\n    console.assert(!Number.isNaN(bodySim.transform.p.x));\r\n    console.assert(!Number.isNaN(bodySim.transform.q.c));\r\n\r\n    return bodySim.transform;\r\n}\r\n\r\nexport function b2GetBodyTransform(world, bodyId)\r\n{\r\n    // b2CheckIndex(world.bodyArray, bodyId);\r\n    const body = world.bodyArray[bodyId];\r\n\r\n    return b2GetBodyTransformQuick(world, body);\r\n}\r\n\r\nexport function b2MakeBodyId(world, bodyId)\r\n{\r\n    // b2CheckIndex(world.bodyArray, bodyId);\r\n    const body = world.bodyArray[bodyId];\r\n\r\n    return new b2BodyId(bodyId + 1, world.worldId, body.revision);\r\n}\r\n\r\nexport function b2GetBodySim(world, body)\r\n{\r\n    // b2CheckIndex(world.solverSetArray, body.setIndex);\r\n    console.assert(body.setIndex >= 0);\r\n    const set = world.solverSetArray[body.setIndex];\r\n    console.assert(0 <= body.localIndex && body.localIndex < set.sims.count);\r\n\r\n    return set.sims.data[body.localIndex];\r\n}\r\n\r\nexport function b2GetBodyState(world, body)\r\n{\r\n    // b2CheckIndex(world.solverSetArray, body.setIndex);\r\n    console.assert(body.setIndex >= 0);\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n        // console.assert(0 <= body.localIndex && body.localIndex < set.states.count);\r\n        return set.states.data[body.localIndex];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function b2CreateIslandForBody(world, setIndex, body)\r\n{\r\n    console.assert(body.islandId === B2_NULL_INDEX);\r\n    console.assert(body.islandPrev === B2_NULL_INDEX);\r\n    console.assert(body.islandNext === B2_NULL_INDEX);\r\n    console.assert(setIndex !== b2SetType.b2_disabledSet);\r\n\r\n    const island = b2CreateIsland(world, setIndex);\r\n\r\n    body.islandId = island.islandId;\r\n    island.headBody = body.id;\r\n    island.tailBody = body.id;\r\n    island.bodyCount = 1;\r\n}\r\n\r\nexport function b2RemoveBodyFromIsland(world, body)\r\n{\r\n    if (body.islandId === B2_NULL_INDEX)\r\n    {\r\n        // console.assert(body.islandPrev === B2_NULL_INDEX);\r\n        // console.assert(body.islandNext === B2_NULL_INDEX);\r\n        return;\r\n    }\r\n\r\n    const islandId = body.islandId;\r\n\r\n    // b2CheckIndex(world.islandArray, islandId);\r\n    const island = world.islandArray[islandId];\r\n\r\n    // Fix the island's linked list of sims\r\n    if (body.islandPrev !== B2_NULL_INDEX)\r\n    {\r\n        const prevBody = b2GetBody(world, body.islandPrev);\r\n        prevBody.islandNext = body.islandNext;\r\n    }\r\n\r\n    if (body.islandNext !== B2_NULL_INDEX)\r\n    {\r\n        const nextBody = b2GetBody(world, body.islandNext);\r\n        nextBody.islandPrev = body.islandPrev;\r\n    }\r\n\r\n    console.assert(island.bodyCount > 0);\r\n    island.bodyCount -= 1;\r\n    let islandDestroyed = false;\r\n\r\n    if (island.headBody === body.id)\r\n    {\r\n        island.headBody = body.islandNext;\r\n\r\n        if (island.headBody === B2_NULL_INDEX)\r\n        {\r\n            // Destroy empty island\r\n            console.assert(island.tailBody === body.id);\r\n            console.assert(island.bodyCount === 0);\r\n            console.assert(island.contactCount === 0);\r\n            console.assert(island.jointCount === 0);\r\n\r\n            // Free the island\r\n            b2DestroyIsland(world, island.islandId);\r\n            islandDestroyed = true;\r\n        }\r\n    }\r\n    else if (island.tailBody === body.id)\r\n    {\r\n        island.tailBody = body.islandPrev;\r\n    }\r\n\r\n    if (islandDestroyed === false)\r\n    {\r\n        b2ValidateIsland(world, islandId);\r\n    }\r\n\r\n    body.islandId = B2_NULL_INDEX;\r\n    body.islandPrev = B2_NULL_INDEX;\r\n    body.islandNext = B2_NULL_INDEX;\r\n}\r\n\r\nexport function b2DestroyBodyContacts(world, body, wakeBodies)\r\n{\r\n    // Destroy the attached contacts\r\n    let edgeKey = body.headContactKey;\r\n\r\n    while (edgeKey !== B2_NULL_INDEX)\r\n    {\r\n        const contactId = edgeKey >> 1;\r\n        const edgeIndex = edgeKey & 1;\r\n\r\n        const contact = world.contactArray[contactId];\r\n        edgeKey = contact.edges[edgeIndex].nextKey;\r\n        b2DestroyContact(world, contact, wakeBodies);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2CreateBody\r\n * @param {b2WorldId} worldId - The ID of the world to create the body in\r\n * @param {b2BodyDef} def - The body definition containing initialization parameters\r\n * @returns {b2BodyId} The ID of the newly created body\r\n * @description\r\n * Creates a new physics body in the specified world based on the provided body definition.\r\n * The body is added to the appropriate solver set based on its type and state.\r\n * The function initializes the body's physical properties including position, rotation,\r\n * velocities, damping values and other simulation parameters.\r\n * @throws {Error} Throws assertion errors if:\r\n * - Position vector is invalid\r\n * - Rotation value is invalid\r\n * - Linear velocity vector is invalid\r\n * - Angular velocity is invalid\r\n * - Linear damping is invalid or negative\r\n * - Angular damping is invalid or negative\r\n * - Sleep threshold is invalid or negative\r\n * - Gravity scale is invalid\r\n */\r\nexport function b2CreateBody(worldId, def)\r\n{\r\n    // b2CheckDef(def);\r\n    console.assert(b2Vec2_IsValid(def.position));\r\n    console.assert(b2Rot_IsValid(def.rotation));\r\n    console.assert(b2Vec2_IsValid(def.linearVelocity));\r\n    console.assert(b2IsValid(def.angularVelocity));\r\n    console.assert(b2IsValid(def.linearDamping) && def.linearDamping >= 0.0);\r\n    console.assert(b2IsValid(def.angularDamping) && def.angularDamping >= 0.0);\r\n    console.assert(b2IsValid(def.sleepThreshold) && def.sleepThreshold >= 0.0);\r\n    console.assert(b2IsValid(def.gravityScale));\r\n\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    if (world.locked)\r\n    {\r\n        console.warn(\"Cannot create body while world is locked (are you adding a body during PreSolve callback?)\");\r\n\r\n        return new b2BodyId(0, 0, 0);\r\n    }\r\n\r\n    const isAwake = (def.isAwake || def.enableSleep === false) && def.isEnabled;\r\n\r\n    // determine the solver set\r\n    let setId;\r\n\r\n    if (def.isEnabled === false)\r\n    {\r\n        // any body type can be disabled\r\n        setId = b2SetType.b2_disabledSet;\r\n    }\r\n    else if (def.type === b2BodyType.b2_staticBody)\r\n    {\r\n        setId = b2SetType.b2_staticSet;\r\n    }\r\n    else if (isAwake === true)\r\n    {\r\n        setId = b2SetType.b2_awakeSet;\r\n    }\r\n    else\r\n    {\r\n        // new set for a sleeping body in its own island\r\n        setId = b2AllocId(world.solverSetIdPool);\r\n        console.warn(\"new set for a sleeping body \" + setId);\r\n\r\n        if (setId === world.solverSetArray.length)\r\n        {\r\n            const set = new b2SolverSet();\r\n            set.setIndex = setId;\r\n            world.solverSetArray.push(set);\r\n        }\r\n        else\r\n        {\r\n            console.assert(world.solverSetArray[setId].setIndex === B2_NULL_INDEX);\r\n        }\r\n\r\n        world.solverSetArray[setId].setIndex = setId;\r\n    }\r\n\r\n    // console.assert(0 <= setId && setId < world.solverSetArray.length);\r\n\r\n    const bodyId = b2AllocId(world.bodyIdPool);\r\n\r\n    const set = world.solverSetArray[setId];\r\n    const bodySim = b2AddBodySim(set.sims);\r\n\r\n    Object.assign(bodySim, {\r\n        transform: new b2Transform(def.position, def.rotation),\r\n        center: def.position.clone(),\r\n        rotation0: def.rotation,\r\n        center0X: def.position.x,\r\n        center0Y: def.position.y,\r\n        localCenter: new b2Vec2(),\r\n        force: new b2Vec2(),\r\n        torque: 0.0,\r\n        mass: 0.0,\r\n        invMass: 0.0,\r\n        inertia: 0.0,\r\n        invInertia: 0.0,\r\n        minExtent: B2_HUGE,\r\n        maxExtent: 0.0,\r\n        linearDamping: def.linearDamping,\r\n        angularDamping: def.angularDamping,\r\n        gravityScale: def.gravityScale,\r\n        bodyId: bodyId,\r\n        isBullet: def.isBullet,\r\n        allowFastRotation: def.allowFastRotation,\r\n        enlargeAABB: false,\r\n        isFast: false,\r\n        isSpeedCapped: false\r\n    });\r\n    console.assert(bodySim.transform);\r\n\r\n    if (setId === b2SetType.b2_awakeSet)\r\n    {\r\n        const bodyState = b2AddBodyState(set.states);\r\n        console.assert((bodyState & 0x1F) === 0);\r\n\r\n        Object.assign(bodyState, {\r\n            linearVelocity: def.linearVelocity,\r\n            angularVelocity: def.angularVelocity,\r\n            deltaRotation: new b2Rot()\r\n        });\r\n    }\r\n\r\n    // PJB NOTE: this 'bodyId' is the index in the world.bodyArray (so really, bodyIndex??)\r\n    while (bodyId >= world.bodyArray.length)\r\n    {\r\n        world.bodyArray.push(new b2Body());\r\n    }\r\n\r\n    console.assert(world.bodyArray[bodyId].id === B2_NULL_INDEX, \"bodyId \" + bodyId + \" id \" + world.bodyArray[bodyId].id);\r\n\r\n    // b2CheckIndex(world.bodyArray, bodyId);\r\n    const body = world.bodyArray[bodyId];\r\n    Object.assign(body, {\r\n        userData: def.userData,\r\n        setIndex: setId,\r\n        localIndex: set.sims.count - 1,\r\n        revision: body.revision + 1,\r\n        headShapeId: B2_NULL_INDEX,\r\n        shapeCount: 0,\r\n        headChainId: B2_NULL_INDEX,\r\n        headContactKey: B2_NULL_INDEX,\r\n        contactCount: 0,\r\n        headJointKey: B2_NULL_INDEX,        // PJB NOTE: combination of joint id (>> 1) and edge index (& 0x01)\r\n        jointCount: 0,\r\n        islandId: B2_NULL_INDEX,\r\n        islandPrev: B2_NULL_INDEX,\r\n        islandNext: B2_NULL_INDEX,\r\n        bodyMoveIndex: B2_NULL_INDEX,\r\n        id: bodyId,                         // PJB NOTE: body.id is bodyId (is index in worldBodyArray)\r\n        sleepThreshold: def.sleepThreshold,\r\n        sleepTime: 0.0,\r\n        type: def.type,\r\n        enableSleep: def.enableSleep,\r\n        fixedRotation: def.fixedRotation,\r\n        isSpeedCapped: false,\r\n        isMarked: false,\r\n        updateBodyMass: def.updateBodyMass\r\n    });\r\n\r\n    // dynamic and kinematic bodies that are enabled need an island\r\n    if (setId >= b2SetType.b2_awakeSet)\r\n    {\r\n        b2CreateIslandForBody(world, setId, body);\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n    \r\n    return new b2BodyId(bodyId + 1, world.worldId, body.revision);\r\n}\r\n\r\nexport function b2IsBodyAwake(world, body)\r\n{\r\n    return body.setIndex === b2SetType.b2_awakeSet;\r\n}\r\n\r\nexport function b2WakeBody(world, body)\r\n{\r\n    if (body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeSolverSet(world, body.setIndex);\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * @function b2DestroyBody\r\n * @description\r\n * Destroys a body and all associated joints, contacts, shapes, and chains in the physics world.\r\n * The function cleans up all resources and removes the body from the simulation system.\r\n * @param {b2BodyId} bodyId - The identifier of the body to destroy\r\n * @returns {void}\r\n * @throws {Error} Throws assertion errors if body indices are invalid during removal\r\n * @note This function performs the following cleanup operations:\r\n * - Destroys all joints connected to the body\r\n * - Removes all contacts associated with the body\r\n * - Destroys all shapes attached to the body\r\n * - Removes all chains connected to the body\r\n * - Removes the body from the island structure\r\n * - Cleans up solver sets and simulation data\r\n */\r\nexport function b2DestroyBody(bodyId)\r\n{\r\n    // (\"b2DestroyBody \" + JSON.stringify(bodyId));\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    // Wake bodies attached to this body, even if this body is static.\r\n    const wakeBodies = true;\r\n\r\n    // Destroy the attached joints\r\n    let edgeKey = body.headJointKey;\r\n\r\n    while (edgeKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointId = edgeKey >> 1;\r\n        const edgeIndex = edgeKey & 1;\r\n\r\n        const joint = world.jointArray[jointId];\r\n        edgeKey = joint.edges[edgeIndex].nextKey;\r\n\r\n        // Careful because this modifies the list being traversed\r\n        b2DestroyJointInternal(world, joint, wakeBodies);\r\n    }\r\n\r\n    // Destroy all contacts attached to this body.\r\n    b2DestroyBodyContacts(world, body, wakeBodies);\r\n\r\n    // Destroy the attached shapes and their broad-phase proxies.\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n\r\n        b2DestroyShapeProxy(shape, world.broadPhase);\r\n\r\n        // Return shape to free list.\r\n        b2FreeId(world.shapeIdPool, shapeId);\r\n        shape.id = B2_NULL_INDEX;\r\n\r\n        shapeId = shape.nextShapeId;\r\n    }\r\n\r\n    // Destroy the attached chains. The associated shapes have already been destroyed above.\r\n    let chainId = body.headChainId;\r\n\r\n    while (chainId !== B2_NULL_INDEX)\r\n    {\r\n        const chain = world.chainArray[chainId];\r\n        chain.shapeIndices = null;\r\n\r\n        // Return chain to free list.\r\n        b2FreeId(world.chainIdPool, chainId);\r\n        chain.id = B2_NULL_INDEX;\r\n\r\n        chainId = chain.nextChainId;\r\n    }\r\n\r\n    b2RemoveBodyFromIsland(world, body);\r\n\r\n    // Remove body sim from solver set that owns it\r\n    // (swap the last item in the list into its position, overwriting and removing its data)\r\n    console.assert(body.setIndex != B2_NULL_INDEX);\r\n    const set = world.solverSetArray[body.setIndex];\r\n    const movedIndex = b2RemoveBodySim(set.sims, body.localIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        // Fix moved body index\r\n\r\n        // get the body data from the set using the \r\n        const movedSim = set.sims.data[body.localIndex];\r\n\r\n        const movedId = movedSim.bodyId;\r\n        const movedBody = world.bodyArray[movedId];\r\n        console.assert(movedBody.localIndex === movedIndex);\r\n        movedBody.localIndex = body.localIndex;\r\n    }\r\n\r\n    // Remove body state from awake set\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const result = b2RemoveBodyState(set.states, body.localIndex);\r\n\r\n        // B2_MAYBE_UNUSED(result);\r\n        console.assert(result === movedIndex);\r\n    }\r\n    else if ( set.setIndex >= b2SetType.b2_firstSleepingSet && set.sims.count == 0 )\r\n    {\r\n        // Remove solver set if it's now an orphan.\r\n        b2DestroySolverSet( world, set.setIndex );\r\n    }\r\n\r\n    // Free body and id (preserve body revision)\r\n    b2FreeId(world.bodyIdPool, body.id);\r\n\r\n    body.setIndex = B2_NULL_INDEX;\r\n    body.localIndex = B2_NULL_INDEX;\r\n    body.id = B2_NULL_INDEX;\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * Gets the contact capacity of a body.\r\n * @function b2Body_GetContactCapacity\r\n * @param {b2BodyId} bodyId - The identifier for the body to query\r\n * @returns {number} The number of contacts associated with the body. Returns 0 if the world is invalid.\r\n * @description\r\n * Retrieves the current number of contacts associated with the specified body.\r\n * The function first validates the world reference before accessing the body's contact count.\r\n */\r\nexport function b2Body_GetContactCapacity(bodyId)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    // Conservative and fast\r\n    return body.contactCount;\r\n}\r\n\r\n/**\r\n * @function b2Body_GetContactData\r\n * @param {b2BodyId} bodyId - The ID of the body to get contact data from\r\n * @param {Array<b2ContactData>} contactData - Array to store the contact data\r\n * @param {number} capacity - Maximum number of contacts to retrieve\r\n * @returns {number} The number of contacts stored in contactData\r\n * @description\r\n * Retrieves contact data for a specified body. For each active contact, stores the shape IDs\r\n * of both bodies involved and the contact manifold. Only stores contacts that have the\r\n * touching flag set.\r\n * @throws {Error} If the world is locked or invalid\r\n */\r\nexport function b2Body_GetContactData(bodyId, contactData, capacity)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    let contactKey = body.headContactKey;\r\n    let index = 0;\r\n\r\n    while (contactKey !== B2_NULL_INDEX && index < capacity)\r\n    {\r\n        const contactId = contactKey >> 1;\r\n        const edgeIndex = contactKey & 1;\r\n\r\n        // b2CheckIndex(world.contactArray, contactId);\r\n        const contact = world.contactArray[contactId];\r\n\r\n        // Is contact touching?\r\n        if (contact.flags & b2ContactFlags.b2_contactTouchingFlag)\r\n        {\r\n            const shapeA = world.shapeArray[contact.shapeIdA];\r\n            const shapeB = world.shapeArray[contact.shapeIdB];\r\n\r\n            contactData[index].shapeIdA = new b2ShapeId(shapeA.id + 1, bodyId.world0, shapeA.revision);\r\n            contactData[index].shapeIdB = new b2ShapeId(shapeB.id + 1, bodyId.world0, shapeB.revision);\r\n\r\n            const contactSim = b2GetContactSim(world, contact);\r\n            contactData[index].manifold = contactSim.manifold;\r\n\r\n            index += 1;\r\n        }\r\n\r\n        contactKey = contact.edges[edgeIndex].nextKey;\r\n    }\r\n\r\n    console.assert(index <= capacity);\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * @function b2Body_ComputeAABB\r\n * @summary Computes the Axis-Aligned Bounding Box (AABB) for a body and all its shapes.\r\n * @param {b2BodyId} bodyId - The identifier for the body whose AABB is to be computed.\r\n * @returns {b2AABB} An AABB that encompasses the body and all its shapes. Returns an empty AABB if the world is not found.\r\n * @description\r\n * For bodies with no shapes, returns an AABB containing only the body's position.\r\n * For bodies with shapes, computes the union of AABBs of all shapes attached to the body.\r\n */\r\nexport function b2Body_ComputeAABB(bodyId)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return new b2AABB();\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.headShapeId === B2_NULL_INDEX)\r\n    {\r\n        const transform = b2GetBodyTransform(world, body.id);\r\n        const aabb = new b2AABB(transform.p.x, transform.p.y, transform.p.x, transform.p.y);\r\n\r\n        return aabb;\r\n    }\r\n\r\n    let shape = world.shapeArray[body.headShapeId];\r\n    let aabb = shape.aabb;\r\n\r\n    while (shape.nextShapeId !== B2_NULL_INDEX)\r\n    {\r\n        shape = world.shapeArray[shape.nextShapeId];\r\n        aabb = b2AABB_Union(aabb, shape.aabb);\r\n    }\r\n\r\n    return aabb;\r\n}\r\n\r\nexport function b2UpdateBodyMassData(world, body)\r\n{\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    // Compute mass data from shapes. Each shape has its own density.\r\n    bodySim.mass = 0.0;\r\n    bodySim.invMass = 0.0;\r\n    bodySim.inertia = 0.0;\r\n    bodySim.invInertia = 0.0;\r\n\r\n    // bodySim.localCenter = new b2Vec2(); assigned in the function\r\n    bodySim.minExtent = B2_HUGE;\r\n    bodySim.maxExtent = 0.0;\r\n\r\n    // Static and kinematic sims have zero mass.\r\n    if (body.type !== b2BodyType.b2_dynamicBody)\r\n    {\r\n        bodySim.center = bodySim.transform.p.clone();\r\n\r\n        // Need extents for kinematic bodies for sleeping to work correctly.\r\n        if (body.type === b2BodyType.b2_kinematicBody)\r\n        {\r\n            let shapeId = body.headShapeId;\r\n\r\n            while (shapeId !== B2_NULL_INDEX)\r\n            {\r\n                const s = world.shapeArray[shapeId];\r\n                shapeId = s.nextShapeId;\r\n\r\n                const extent = b2ComputeShapeExtent(s, new b2Vec2());\r\n                bodySim.minExtent = Math.min(bodySim.minExtent, extent.minExtent);\r\n                bodySim.maxExtent = Math.max(bodySim.maxExtent, extent.maxExtent);\r\n            }\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    // Accumulate mass over all shapes.\r\n    let localCenter = new b2Vec2();\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const s = world.shapeArray[shapeId];\r\n        shapeId = s.nextShapeId;\r\n\r\n        if (s.density === 0.0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const massData = b2ComputeShapeMass(s);\r\n        bodySim.mass += massData.mass;\r\n        localCenter = b2MulAdd(localCenter, massData.mass, massData.center);\r\n        bodySim.inertia += massData.rotationalInertia;\r\n    }\r\n\r\n    // Compute center of mass.\r\n    console.assert(bodySim.mass > 0.0, \"A body has zero mass, check both density and size!\");\r\n\r\n    if (bodySim.mass > 0.0)\r\n    {\r\n        bodySim.invMass = 1.0 / bodySim.mass;\r\n        localCenter = b2MulSV(bodySim.invMass, localCenter);\r\n    }\r\n\r\n    if (bodySim.inertia > 0.0 && body.fixedRotation === false)\r\n    {\r\n        // Center the inertia about the center of mass.\r\n        bodySim.inertia -= bodySim.mass * b2Dot(localCenter, localCenter);\r\n        console.assert(bodySim.inertia > 0.0);\r\n        bodySim.invInertia = 1.0 / bodySim.inertia;\r\n    }\r\n    else\r\n    {\r\n        bodySim.inertia = 0.0;\r\n        bodySim.invInertia = 0.0;\r\n    }\r\n\r\n    // Move center of mass.\r\n    const oldCenter = bodySim.center.clone();\r\n    bodySim.localCenter = localCenter;\r\n    bodySim.center = b2TransformPoint(bodySim.transform, bodySim.localCenter);\r\n\r\n    // Update center of mass velocity\r\n    const state = b2GetBodyState(world, body);\r\n\r\n    if (state !== null)\r\n    {\r\n        const deltaLinear = b2CrossSV(state.angularVelocity, b2Sub(bodySim.center, oldCenter));\r\n        state.linearVelocity = b2Add(state.linearVelocity, deltaLinear);\r\n    }\r\n\r\n    // Compute body extents relative to center of mass\r\n    shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const s = world.shapeArray[shapeId];\r\n        shapeId = s.nextShapeId;\r\n\r\n        const extent = b2ComputeShapeExtent(s, localCenter);\r\n        bodySim.minExtent = Math.min(bodySim.minExtent, extent.minExtent);\r\n        bodySim.maxExtent = Math.max(bodySim.maxExtent, extent.maxExtent);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_GetPosition\r\n * @summary Gets the current position of a body in the physics world.\r\n * @param {b2BodyId} bodyId - The identifier for the body whose position is being queried.\r\n * @returns {b2Vec2} The position vector of the body in world coordinates.\r\n * @description\r\n * Retrieves the current position component of a body's transform from the physics world.\r\n * The position is returned as a b2Vec2 representing the body's location in world space.\r\n */\r\nexport function b2Body_GetPosition(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return transform.p;\r\n}\r\n\r\n/**\r\n * Gets the rotation component of a body's transform.\r\n * @function b2Body_GetRotation\r\n * @param {b2BodyId} bodyId - The identifier for the body whose rotation is being queried.\r\n * @returns {b2Rot} A rotation object containing the cosine and sine of the body's angle.\r\n * @description\r\n * Retrieves the rotation component (q) from the body's transform. The returned b2Rot\r\n * object represents the body's angular orientation in 2D space.\r\n */\r\nexport function b2Body_GetRotation(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return transform.q;\r\n}\r\n\r\n/**\r\n * @summary Gets the transform of a body in the physics world.\r\n * @function b2Body_GetTransform\r\n * @param {Object} bodyId - The identifier object for the body, containing world reference.\r\n * @param {number} bodyId.world0 - The world identifier.\r\n * @returns {Object} The body's transform containing:\r\n * - position {b2Vec2} The position vector (x, y)\r\n * - rotation {b2Rot} The rotation values (c, s)\r\n * @description\r\n * Retrieves the current transform (position and rotation) of a physics body\r\n * from the specified Box2D world using the body's identifier.\r\n */\r\nexport function b2Body_GetTransform(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return b2GetBodyTransformQuick(world, body);\r\n}\r\n\r\n/**\r\n * Converts a point from world coordinates to local body coordinates.\r\n * @function b2Body_GetLocalPoint\r\n * @param {b2BodyId} bodyId - The identifier for the body\r\n * @param {b2Vec2} worldPoint - A point in world coordinates\r\n * @returns {b2Vec2} The point expressed in the body's local coordinates\r\n * @description\r\n * Takes a point given in world coordinates and converts it to the body's local\r\n * coordinate system by applying the inverse of the body's transform.\r\n */\r\nexport function b2Body_GetLocalPoint(bodyId, worldPoint)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return b2InvTransformPoint(transform, worldPoint);\r\n}\r\n\r\n/**\r\n * @function b2Body_GetWorldPoint\r\n * @summary Converts a point from local body coordinates to world coordinates.\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @param {b2Vec2} localPoint - A point in the body's local coordinates.\r\n * @returns {b2Vec2} The point transformed to world coordinates.\r\n * @description\r\n * Takes a point given in body-local coordinates and converts it to world coordinates\r\n * using the body's current transform (position and rotation).\r\n */\r\nexport function b2Body_GetWorldPoint(bodyId, localPoint)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return b2TransformPoint(transform, localPoint);\r\n}\r\n\r\n/**\r\n * @function b2Body_GetLocalVector\r\n * @summary Converts a vector from world space to a body's local space\r\n * @param {b2BodyId} bodyId - The identifier for the body\r\n * @param {b2Vec2} worldVector - A vector in world coordinates\r\n * @returns {b2Vec2} The vector transformed into the body's local coordinates\r\n * @description\r\n * Takes a vector defined in world coordinates and transforms it to be relative\r\n * to the body's local coordinate system by applying the inverse of the body's rotation.\r\n */\r\nexport function b2Body_GetLocalVector(bodyId, worldVector)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return b2InvRotateVector(transform.q, worldVector);\r\n}\r\n\r\n/**\r\n * @function b2Body_GetWorldVector\r\n * @summary Converts a vector from local body coordinates to world coordinates.\r\n * @param {b2BodyId} bodyId - The identifier for the body\r\n * @param {b2Vec2} localVector - A vector in local body coordinates\r\n * @returns {b2Vec2} The vector transformed into world coordinates\r\n * @description\r\n * Transforms a vector from the body's local coordinate system to the world\r\n * coordinate system. This operation only performs rotation (not translation)\r\n * using the body's current rotation matrix.\r\n */\r\nexport function b2Body_GetWorldVector(bodyId, localVector)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    return b2RotateVector(transform.q, localVector);\r\n}\r\n\r\n/**\r\n * @function b2Body_SetTransform\r\n * @description\r\n * Sets the position and rotation of a body, updating its transform and associated shape AABBs.\r\n * The function updates the body's center, handles broad-phase movement, and adjusts collision bounds.\r\n * @param {b2BodyId} bodyId - The identifier of the body to transform\r\n * @param {b2Vec2} position - The new position vector for the body\r\n * @param {b2Rot} [rotation] - The new rotation for the body. If undefined, keeps current rotation\r\n * @returns {void}\r\n * @throws {Error} Throws assertion error if:\r\n * - The position vector is invalid\r\n * - The body ID is invalid\r\n * - The world is locked\r\n * - The rotation (if provided) is invalid\r\n */\r\nexport function b2Body_SetTransform(bodyId, position, rotation)\r\n{\r\n    console.assert(b2Vec2_IsValid(position));\r\n    console.assert(b2Body_IsValid(bodyId));\r\n    const world = b2GetWorld(bodyId.world0);\r\n    console.assert(world.locked === false);\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    console.assert(b2Rot_IsValid(rotation) || b2Rot_IsValid(bodySim.transform.q));\r\n\r\n    bodySim.transform.p = position;\r\n\r\n    if (rotation !== undefined)\r\n    {\r\n        bodySim.transform.q = rotation;\r\n    }\r\n    bodySim.center = b2TransformPoint(bodySim.transform, bodySim.localCenter);\r\n\r\n    bodySim.rotation0 = bodySim.transform.q;\r\n    bodySim.center0X = bodySim.center.x;\r\n    bodySim.center0Y = bodySim.center.y;\r\n\r\n    const broadPhase = world.broadPhase;\r\n\r\n    const transform = bodySim.transform;\r\n    const margin = b2_aabbMargin;\r\n    const speculativeDistance = b2_speculativeDistance;\r\n\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n        const aabb = b2ComputeShapeAABB(shape, transform);\r\n        aabb.lowerBoundX -= speculativeDistance;\r\n        aabb.lowerBoundY -= speculativeDistance;\r\n        aabb.upperBoundX += speculativeDistance;\r\n        aabb.upperBoundY += speculativeDistance;\r\n        shape.aabb = aabb;\r\n\r\n        if (b2AABB_Contains(shape.fatAABB, aabb) === false)\r\n        {\r\n            const fatAABB = new b2AABB(aabb.lowerBoundX - margin, aabb.lowerBoundY - margin,\r\n                aabb.upperBoundX + margin, aabb.upperBoundY + margin);\r\n            shape.fatAABB = fatAABB;\r\n\r\n            // The body could be disabled\r\n            if (shape.proxyKey !== B2_NULL_INDEX)\r\n            {\r\n                b2BroadPhase_MoveProxy(broadPhase, shape.proxyKey, fatAABB);\r\n            }\r\n        }\r\n\r\n        shapeId = shape.nextShapeId;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets a clone of the linear velocity of a body.\r\n * @function b2Body_GetLinearVelocity\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {b2Vec2} The linear velocity vector of the body. Returns a zero vector (0,0) if the body state is null.\r\n * @description\r\n * Retrieves the current linear velocity of a body from its state in the physics world.\r\n * If the body state cannot be found, returns a zero vector.\r\n * Linear velocity is often used for calculations (damping, direction, etc) and must be cloned to avoid unwanted effects in the Physics engine.\r\n */\r\nexport function b2Body_GetLinearVelocity(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const state = b2GetBodyState(world, body);\r\n\r\n    if (state !== null)\r\n    {\r\n        return state.linearVelocity.clone();\r\n    }\r\n\r\n    return new b2Vec2();\r\n}\r\n\r\n/**\r\n * Gets the angular velocity of a body.\r\n * @function b2Body_GetAngularVelocity\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {number} The angular velocity in radians per second. Returns 0 if the body state cannot be retrieved.\r\n * @description\r\n * Retrieves the current angular velocity of a body from its state in the physics world.\r\n * Angular velocity represents how fast the body is rotating.\r\n */\r\nexport function b2Body_GetAngularVelocity(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const state = b2GetBodyState(world, body);\r\n\r\n    if (state !== null)\r\n    {\r\n        return state.angularVelocity;\r\n    }\r\n\r\n    return 0.0;\r\n}\r\n\r\n/**\r\n * Sets the linear velocity of a body.\r\n * @function b2Body_SetLinearVelocity\r\n * @param {b2BodyId} bodyId - The identifier of the body to modify.\r\n * @param {b2Vec2} linearVelocity - The new linear velocity vector to set.\r\n * @returns {void}\r\n * @description\r\n * Sets the linear velocity of a body. If the body is static, the function returns without\r\n * making changes. If the new velocity has a non-zero magnitude, the body will be awakened.\r\n * The function will return early if the body state cannot be retrieved.\r\n */\r\nexport function b2Body_SetLinearVelocity(bodyId, linearVelocity)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.type == b2BodyType.b2_staticBody)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (b2LengthSquared(linearVelocity) > 0.0)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    const state = b2GetBodyState(world, body);\r\n\r\n    if (state === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    state.linearVelocity = linearVelocity;\r\n}\r\n\r\n/**\r\n * Sets the angular velocity of a body.\r\n * @function b2Body_SetAngularVelocity\r\n * @param {b2BodyId} bodyId - The identifier of the body to modify\r\n * @param {number} angularVelocity - The new angular velocity in radians per second\r\n * @returns {void}\r\n * @description\r\n * Sets the angular velocity of a body. If the body is static or has fixed rotation,\r\n * the function returns without making changes. The body is woken up if a non-zero\r\n * angular velocity is set.\r\n */\r\nexport function b2Body_SetAngularVelocity(bodyId, angularVelocity)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.type == b2BodyType.b2_staticBody || body.fixedRotation)\r\n    {\r\n        return;\r\n    }\r\n    \r\n    if (angularVelocity !== 0.0)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    const state = b2GetBodyState(world, body);\r\n\r\n    if (state === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    state.angularVelocity = angularVelocity;\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyForce\r\n * @description\r\n * Applies a force at a world point to a body. If the force is not applied at the\r\n * center of mass, it will generate a torque and affect angular motion.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply the force to\r\n * @param {b2Vec2} force - The world force vector\r\n * @param {b2Vec2} point - The world position of the point of application\r\n * @param {boolean} wake - Whether to wake the body if it is sleeping\r\n * @returns {void}\r\n * @note The force is accumulated and applied during the next time step. The body\r\n * must be awake for the force to be applied.\r\n */\r\nexport function b2Body_ApplyForce(bodyId, force, point, wake)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const bodySim = b2GetBodySim(world, body);\r\n        bodySim.force = b2Add(bodySim.force, force);\r\n        bodySim.torque += b2Cross(b2Sub(point, bodySim.center), force);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyForceToCenter\r\n * @description\r\n * Applies a force to the center of mass of a body. If the body is sleeping, it can optionally be woken up.\r\n * The force is only applied if the body is in the awake set.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply the force to\r\n * @param {b2Vec2} force - The world force vector to apply to the body's center\r\n * @param {boolean} wake - Whether to wake the body if it is sleeping\r\n * @returns {void}\r\n */\r\nexport function b2Body_ApplyForceToCenter(bodyId, force, wake)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const bodySim = b2GetBodySim(world, body);\r\n        bodySim.force = b2Add(bodySim.force, force);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyTorque\r\n * @summary Applies a torque to a body.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply torque to\r\n * @param {number} torque - The amount of torque to apply\r\n * @param {boolean} wake - Whether to wake the body if it's sleeping\r\n * @returns {void}\r\n * @description\r\n * Adds the specified torque to the body's total torque. If the wake parameter\r\n * is true and the body is sleeping, it will be awakened. The torque is only\r\n * applied if the body is in the awake set.\r\n */\r\nexport function b2Body_ApplyTorque(bodyId, torque, wake)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const bodySim = b2GetBodySim(world, body);\r\n        bodySim.torque += torque;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyLinearImpulse\r\n * @description\r\n * Applies a linear impulse to a body at a specified world point, affecting both its linear\r\n * and angular velocities.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply the impulse to\r\n * @param {b2Vec2} impulse - The world impulse vector to apply\r\n * @param {b2Vec2} point - The world position where the impulse is applied\r\n * @param {boolean} wake - Whether to wake the body if it's sleeping\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if the body's local index is invalid\r\n */\r\nexport function b2Body_ApplyLinearImpulse(bodyId, impulse, point, wake)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const localIndex = body.localIndex;\r\n        const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n        console.assert(0 <= localIndex && localIndex < set.states.count);\r\n        const state = set.states.data[localIndex];\r\n        const bodySim = set.sims.data[localIndex];\r\n        state.linearVelocity = b2MulAdd(state.linearVelocity, bodySim.invMass, impulse);\r\n        state.angularVelocity += bodySim.invInertia * b2Cross(b2Sub(point, bodySim.center), impulse);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyLinearImpulseToCenter\r\n * @description\r\n * Applies a linear impulse to the center of mass of a body. If the body is sleeping,\r\n * it can optionally be woken up.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply the impulse to\r\n * @param {b2Vec2} impulse - The linear impulse vector to be applied\r\n * @param {boolean} wake - Whether to wake the body if it's sleeping\r\n * @returns {void}\r\n * @note The impulse is applied immediately, changing the body's linear velocity based\r\n * on its mass and the magnitude/direction of the impulse.\r\n */\r\nexport function b2Body_ApplyLinearImpulseToCenter(bodyId, impulse, wake)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const localIndex = body.localIndex;\r\n        const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n        console.assert(0 <= localIndex && localIndex < set.states.count);\r\n        const state = set.states.data[localIndex];\r\n        const bodySim = set.sims.data[localIndex];\r\n        state.linearVelocity = b2MulAdd(state.linearVelocity, bodySim.invMass, impulse);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyAngularImpulse\r\n * @description\r\n * Applies an angular impulse to a body, affecting its angular velocity. The impulse is\r\n * scaled by the body's inverse inertia.\r\n * @param {b2BodyId} bodyId - The identifier of the body to apply the impulse to\r\n * @param {number} impulse - The angular impulse to apply\r\n * @param {boolean} wake - Whether to wake the body if it's sleeping\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if the body ID is invalid or if the body\r\n * revision doesn't match\r\n */\r\nexport function b2Body_ApplyAngularImpulse(bodyId, impulse, wake)\r\n{\r\n    console.assert(b2Body_IsValid(bodyId));\r\n    const world = b2GetWorld(bodyId.world0);\r\n\r\n    const id = bodyId.index1 - 1;\r\n\r\n    // b2CheckIndex(world.bodyArray, id);\r\n    const body = world.bodyArray[id];\r\n    console.assert(body.revision === bodyId.revision);\r\n\r\n    if (wake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        // this will not invalidate body pointer\r\n        b2WakeBody(world, body);\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        const localIndex = body.localIndex;\r\n        const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n        console.assert(0 <= localIndex && localIndex < set.states.count);\r\n        const state = set.states.data[localIndex];\r\n        const sim = set.sims.data[localIndex];\r\n        state.angularVelocity += sim.invInertia * impulse;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the type of a body in the physics world.\r\n * @function b2Body_GetType\r\n * @param {b2BodyId} bodyId - The identifier for the body to query.\r\n * @returns {b2BodyType} The type of the specified body.\r\n * @description\r\n * Retrieves the body type (static, kinematic, or dynamic) for a given body ID\r\n * by looking up the body in the physics world using the provided identifier.\r\n */\r\nexport function b2Body_GetType(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.type;\r\n}\r\n\r\n// Changing the body type is quite complex mainly due to joints.\r\n// Considerations:\r\n// - body and joints must be moved to the correct set\r\n// - islands must be updated\r\n// - graph coloring must be correct\r\n// - any body connected to a joint may be disabled\r\n// - joints between static bodies must go into the static set\r\n/**\r\n * @function b2Body_SetType\r\n * @summary Changes the type of a body in the physics simulation.\r\n * @param {b2BodyId} bodyId - The ID of the body to modify\r\n * @param {b2BodyType} type - The new body type to set (static, kinematic, or dynamic)\r\n * @returns {void}\r\n * @description\r\n * Updates a body's type and handles all necessary simulation changes including:\r\n * - Destroying existing contacts\r\n * - Waking the body and connected bodies\r\n * - Unlinking and relinking joints\r\n * - Transferring the body between solver sets\r\n * - Updating broad-phase proxies\r\n * - Recalculating mass data\r\n * If the body is disabled or the type is unchanged, minimal processing occurs.\r\n * Special handling exists for transitions to/from static body type.\r\n */\r\nexport function b2Body_SetType(bodyId, type)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    const originalType = body.type;\r\n\r\n    if (originalType === type)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (body.setIndex === b2SetType.b2_disabledSet)\r\n    {\r\n        // Disabled bodies don't change solver sets or islands when they change type.\r\n        body.type = type;\r\n\r\n        // Body type affects the mass\r\n        b2UpdateBodyMassData(world, body);\r\n\r\n        return;\r\n    }\r\n\r\n    // Destroy all contacts but don't wake bodies.\r\n    const wakeBodies = false;\r\n    b2DestroyBodyContacts(world, body, wakeBodies);\r\n\r\n    // Wake this body because we assume below that it is awake or static.\r\n    b2WakeBody(world, body);\r\n\r\n    // Unlink all joints and wake attached bodies.\r\n    {\r\n        let jointKey = body.headJointKey;\r\n\r\n        while (jointKey !== B2_NULL_INDEX)\r\n        {\r\n            const jointId = jointKey >> 1;\r\n            const edgeIndex = jointKey & 1;\r\n\r\n            const joint = world.jointArray[jointId];\r\n\r\n            if (joint.islandId !== B2_NULL_INDEX)\r\n            {\r\n                b2UnlinkJoint(world, joint);\r\n            }\r\n\r\n            // A body going from static to dynamic or kinematic goes to the awake set\r\n            // and other attached bodies must be awake as well. For consistency, this is\r\n            // done for all cases.\r\n            const bodyA = world.bodyArray[joint.edges[0].bodyId];\r\n            const bodyB = world.bodyArray[joint.edges[1].bodyId];\r\n            b2WakeBody(world, bodyA);\r\n            b2WakeBody(world, bodyB);\r\n\r\n            jointKey = joint.edges[edgeIndex].nextKey;\r\n        }\r\n    }\r\n\r\n    body.type = type;\r\n\r\n    if (originalType === b2BodyType.staticBody)\r\n    {\r\n        // Body is going from static to dynamic or kinematic. It only makes sense to move it to the awake set.\r\n        console.assert(body.setIndex === b2SetType.b2_staticSet);\r\n\r\n        const staticSet = world.solverSetArray[b2SetType.b2_staticSet];\r\n        const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n        // Transfer body to awake set\r\n        b2TransferBody(world, awakeSet, staticSet, body);\r\n\r\n        // Create island for body\r\n        b2CreateIslandForBody(world, b2SetType.b2_awakeSet, body);\r\n\r\n        // Transfer static joints to awake set\r\n        let jointKey = body.headJointKey;\r\n\r\n        while (jointKey !== B2_NULL_INDEX)\r\n        {\r\n            const jointId = jointKey >> 1;\r\n            const edgeIndex = jointKey & 1;\r\n\r\n            const joint = world.jointArray[jointId];\r\n\r\n            // Transfer the joint if it is in the static set\r\n            if (joint.setIndex === b2SetType.b2_staticSet)\r\n            {\r\n                b2TransferJoint(world, awakeSet, staticSet, joint);\r\n            }\r\n            else if (joint.setIndex === b2SetType.b2_awakeSet)\r\n            {\r\n                // In this case the joint must be re-inserted into the constraint graph to ensure the correct\r\n                // graph color.\r\n\r\n                // First transfer to the static set.\r\n                b2TransferJoint(world, staticSet, awakeSet, joint);\r\n\r\n                // Now transfer it back to the awake set and into the graph coloring.\r\n                b2TransferJoint(world, awakeSet, staticSet, joint);\r\n            }\r\n            else\r\n            {\r\n                // Otherwise the joint must be disabled.\r\n                console.assert(joint.setIndex === b2SetType.b2_disabledSet);\r\n            }\r\n\r\n            jointKey = joint.edges[edgeIndex].nextKey;\r\n        }\r\n\r\n        // Recreate shape proxies in movable tree.\r\n        const transform = b2GetBodyTransformQuick(world, body);\r\n        let shapeId = body.headShapeId;\r\n\r\n        while (shapeId !== B2_NULL_INDEX)\r\n        {\r\n            const shape = world.shapeArray[shapeId];\r\n            shapeId = shape.nextShapeId;\r\n            b2DestroyShapeProxy(shape, world.broadPhase);\r\n            const forcePairCreation = true;\r\n            const proxyType = type;\r\n            b2CreateShapeProxy(shape, world.broadPhase, proxyType, transform, forcePairCreation);\r\n        }\r\n    }\r\n\r\n    // @ts-ignore\r\n    else if (type === b2BodyType.b2_staticBody)\r\n    {\r\n        // The body is going from dynamic/kinematic to static. It should be awake.\r\n        console.assert(body.setIndex === b2SetType.b2_awakeSet);\r\n\r\n        const staticSet = world.solverSetArray[b2SetType.b2_staticSet];\r\n        const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n        // Transfer body to static set\r\n        b2TransferBody(world, staticSet, awakeSet, body);\r\n\r\n        // Remove body from island.\r\n        b2RemoveBodyFromIsland(world, body);\r\n\r\n        // Maybe transfer joints to static set.\r\n        let jointKey = body.headJointKey;\r\n\r\n        while (jointKey !== B2_NULL_INDEX)\r\n        {\r\n            const jointId = jointKey >> 1;\r\n            const edgeIndex = jointKey & 1;\r\n\r\n            const joint = world.jointArray[jointId];\r\n            jointKey = joint.edges[edgeIndex].nextKey;\r\n\r\n            const otherEdgeIndex = edgeIndex ^ 1;\r\n            const otherBody = world.bodyArray[joint.edges[otherEdgeIndex].bodyId];\r\n\r\n            // Skip disabled joint\r\n            if (joint.setIndex === b2SetType.b2_disabledSet)\r\n            {\r\n                // Joint is disable, should be connected to a disabled body\r\n                console.assert(otherBody.setIndex === b2SetType.b2_disabledSet);\r\n\r\n                continue;\r\n            }\r\n\r\n            // Since the body was not static, the joint must be awake.\r\n            console.assert(joint.setIndex === b2SetType.b2_awakeSet);\r\n\r\n            // Only transfer joint to static set if both bodies are static.\r\n            if (otherBody.setIndex === b2SetType.b2_staticSet)\r\n            {\r\n                b2TransferJoint(world, staticSet, awakeSet, joint);\r\n            }\r\n            else\r\n            {\r\n                // The other body must be awake.\r\n                console.assert(otherBody.setIndex === b2SetType.b2_awakeSet);\r\n\r\n                // The joint must live in a graph color.\r\n                console.assert(0 <= joint.colorIndex && joint.colorIndex < b2_graphColorCount);\r\n\r\n                // In this case the joint must be re-inserted into the constraint graph to ensure the correct\r\n                // graph color.\r\n\r\n                // First transfer to the static set.\r\n                b2TransferJoint(world, staticSet, awakeSet, joint);\r\n\r\n                // Now transfer it back to the awake set and into the graph coloring.\r\n                b2TransferJoint(world, awakeSet, staticSet, joint);\r\n            }\r\n        }\r\n\r\n        // Recreate shape proxies in static tree.\r\n        const transform = b2GetBodyTransformQuick(world, body);\r\n        let shapeId = body.headShapeId;\r\n\r\n        while (shapeId !== B2_NULL_INDEX)\r\n        {\r\n            const shape = world.shapeArray[shapeId];\r\n            shapeId = shape.nextShapeId;\r\n            b2DestroyShapeProxy(shape, world.broadPhase);\r\n            const forcePairCreation = true;\r\n            b2CreateShapeProxy(shape, world.broadPhase, b2BodyType.b2_staticBody, transform, forcePairCreation);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        console.assert(originalType === b2BodyType.b2_dynamicBody || originalType === b2BodyType.b2_kinematicBody);\r\n\r\n        // @ts-ignore\r\n        console.assert(type === b2BodyType.b2_dynamicBody || type === b2BodyType.b2_kinematicBody);\r\n\r\n        // Recreate shape proxies in static tree.\r\n        const transform = b2GetBodyTransformQuick(world, body);\r\n        let shapeId = body.headShapeId;\r\n\r\n        while (shapeId !== B2_NULL_INDEX)\r\n        {\r\n            const shape = world.shapeArray[shapeId];\r\n            shapeId = shape.nextShapeId;\r\n            b2DestroyShapeProxy(shape, world.broadPhase);\r\n            const proxyType = type;\r\n            const forcePairCreation = true;\r\n            b2CreateShapeProxy(shape, world.broadPhase, proxyType, transform, forcePairCreation);\r\n        }\r\n    }\r\n\r\n    // Relink all joints\r\n    {\r\n        let jointKey = body.headJointKey;\r\n\r\n        while (jointKey !== B2_NULL_INDEX)\r\n        {\r\n            const jointId = jointKey >> 1;\r\n            const edgeIndex = jointKey & 1;\r\n\r\n            const joint = world.jointArray[jointId];\r\n            jointKey = joint.edges[edgeIndex].nextKey;\r\n\r\n            const otherEdgeIndex = edgeIndex ^ 1;\r\n            const otherBodyId = joint.edges[otherEdgeIndex].bodyId;\r\n\r\n            // b2CheckIndex(world.bodyArray, otherBodyId);\r\n            const otherBody = world.bodyArray[otherBodyId];\r\n\r\n            if (otherBody.setIndex === b2SetType.b2_disabledSet)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (body.type === b2BodyType.b2_staticBody && otherBody.type === b2BodyType.b2_staticBody)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            b2LinkJoint(world, joint, false);\r\n        }\r\n\r\n        b2MergeAwakeIslands(world);\r\n    }\r\n\r\n    // Body type affects the mass\r\n    b2UpdateBodyMassData(world, body);\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @summary Sets the user data associated with a body.\r\n * @function b2Body_SetUserData\r\n * @param {b2BodyId} bodyId - The identifier of the body to modify.\r\n * @param {*} userData - The user data to associate with the body.\r\n * @returns {void}\r\n * @description\r\n * Associates arbitrary user data with a physics body. The user data can be\r\n * retrieved later and can be of any type. The body is located using its\r\n * world identifier and the user data is stored directly on the body object.\r\n */\r\nexport function b2Body_SetUserData(bodyId, userData)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    body.userData = userData;\r\n}\r\n\r\n/**\r\n * @summary Gets the user data associated with a body.\r\n * @function b2Body_GetUserData\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {object} The user data associated with the body.\r\n * @description\r\n * Retrieves the custom user data that was previously attached to the specified body.\r\n * The function first gets the world from the body ID, then retrieves the full body\r\n * object, and finally returns its user data.\r\n */\r\nexport function b2Body_GetUserData(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.userData;\r\n}\r\n\r\n/**\r\n * Gets the mass of a body.\r\n * @function b2Body_GetMass\r\n * @param {b2BodyId} bodyId - The identifier for the body whose mass is to be retrieved.\r\n * @returns {number} The mass of the body in kilograms.\r\n * @description\r\n * Retrieves the mass value from a body's simulation data by accessing the world\r\n * and body objects using the provided body identifier.\r\n */\r\nexport function b2Body_GetMass(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.mass;\r\n}\r\n\r\n/**\r\n * Get the rotational inertia of the body, typically in kg*m^2\r\n * @function b2Body_GetRotationalInertia\r\n * @param {b2BodyId} bodyId - The ID of the body to get the inertia tensor from.\r\n * @returns {number} The inertia tensor value of the body.\r\n * @description\r\n * Retrieves the rotational inertia value from a body's simulation data using the body's ID.\r\n * The inertia tensor represents the body's resistance to rotational acceleration.\r\n */\r\nexport function b2Body_GetRotationalInertia(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.inertia;\r\n}\r\n\r\n/**\r\n * Gets the local center of mass for a body.\r\n * @function b2Body_GetLocalCenterOfMass\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {b2Vec2} The local center of mass position vector.\r\n * @description\r\n * Returns a copy of the body's local center of mass position vector.\r\n * The local center is expressed in the body's local coordinate system.\r\n */\r\nexport function b2Body_GetLocalCenterOfMass(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.localCenter.clone();\r\n}\r\n\r\n/**\r\n * Gets the world position of a body's center of mass.\r\n * @function b2Body_GetWorldCenterOfMass\r\n * @param {b2BodyId} bodyId - The identifier for the body whose center of mass position is being queried.\r\n * @returns {b2Vec2} A vector representing the world position of the body's center of mass.\r\n * @description\r\n * Returns a copy of the body's center of mass position in world coordinates.\r\n * The returned vector is a clone of the internal state, preventing external\r\n * modification of the body's actual center position.\r\n */\r\nexport function b2Body_GetWorldCenterOfMass(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.center.clone();\r\n}\r\n\r\n/**\r\n * @function b2Body_SetMassData\r\n * @description\r\n * Sets the mass properties of a body including mass, rotational inertia, and center of mass.\r\n * The function updates both the primary mass properties and derived values like inverse mass.\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify\r\n * @param {b2MassData} massData - An object containing:\r\n * - mass: The mass of the body (must be >= 0)\r\n * - rotationalInertia: The rotational inertia (must be >= 0)\r\n * - center: A b2Vec2 representing the local center of mass\r\n * @returns {void}\r\n * @throws {Error} Throws assertion error if mass or rotationalInertia are invalid or negative,\r\n * or if the center vector is invalid\r\n */\r\nexport function b2Body_SetMassData(bodyId, massData)\r\n{\r\n    console.assert(b2IsValid(massData.mass) && massData.mass >= 0.0);\r\n    console.assert(b2IsValid(massData.rotationalInertia) && massData.rotationalInertia >= 0.0);\r\n    console.assert(b2Vec2_IsValid(massData.center));\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    bodySim.mass = massData.mass;\r\n    bodySim.inertia = massData.rotationalInertia;\r\n    bodySim.localCenter = massData.center;\r\n\r\n    const center = b2TransformPoint(bodySim.transform, massData.center);\r\n    bodySim.center = center;\r\n    bodySim.center0X = center.x;\r\n    bodySim.center0Y = center.y;\r\n\r\n    bodySim.invMass = bodySim.mass > 0.0 ? 1.0 / bodySim.mass : 0.0;\r\n    bodySim.invInertia = bodySim.inertia > 0.0 ? 1.0 / bodySim.inertia : 0.0;\r\n}\r\n\r\n/**\r\n * @function b2Body_GetMassData\r\n * @param {b2BodyId} bodyId - The identifier for the body whose mass data is being retrieved\r\n * @returns {b2MassData} An object containing mass properties:\r\n * - mass: The total mass of the body\r\n * - center: A b2Vec2 representing the local center of mass\r\n * - rotationalInertia: The rotational inertia about the local center of mass\r\n * @description\r\n * Retrieves the mass properties of a body, including its total mass,\r\n * center of mass position, and rotational inertia.\r\n */\r\nexport function b2Body_GetMassData(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n    const massData = new b2MassData();\r\n    massData.mass = bodySim.mass;\r\n    massData.center = bodySim.localCenter;\r\n    massData.rotationalInertia = bodySim.inertia;\r\n\r\n    return massData;\r\n}\r\n\r\n/**\r\n * @function b2Body_ApplyMassFromShapes\r\n * @summary Updates a body's mass properties based on its attached shapes.\r\n * @param {b2BodyId} bodyId - The identifier for the body whose mass properties need to be updated.\r\n * @returns {void}\r\n * @description\r\n * This function retrieves the body from the world using its ID and updates its mass data\r\n * properties (mass, center of mass, and rotational inertia) based on the shapes attached to it.\r\n * If the world cannot be accessed, the function returns without performing any operations.\r\n */\r\nexport function b2Body_ApplyMassFromShapes(bodyId)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    b2UpdateBodyMassData(world, body);\r\n}\r\n\r\n/**\r\n * Sets the linear damping value for a body.\r\n * @function b2Body_SetLinearDamping\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify.\r\n * @param {number} linearDamping - The new linear damping value. Must be non-negative.\r\n * @returns {void}\r\n * @description\r\n * Sets the linear damping coefficient for a body, which reduces its linear velocity over time.\r\n * Linear damping is used to simulate air resistance or fluid friction.\r\n * @throws {Error} Throws an assertion error if linearDamping is invalid or negative.\r\n */\r\nexport function b2Body_SetLinearDamping(bodyId, linearDamping)\r\n{\r\n    console.assert(b2IsValid(linearDamping) && linearDamping >= 0.0);\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n    bodySim.linearDamping = linearDamping;\r\n}\r\n\r\n/**\r\n * Gets the linear damping coefficient of a body.\r\n * @function b2Body_GetLinearDamping\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {number} The linear damping coefficient of the body.\r\n * @description\r\n * Returns the linear damping coefficient that reduces the body's linear velocity.\r\n * Linear damping is used to reduce the linear velocity of the body in the absence\r\n * of forces. The damping parameter can be used to simulate fluid/air resistance.\r\n */\r\nexport function b2Body_GetLinearDamping(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.linearDamping;\r\n}\r\n\r\n/**\r\n * @summary Sets the angular damping value for a body.\r\n * @function b2Body_SetAngularDamping\r\n * @param {b2BodyId} bodyId - The identifier for the target body.\r\n * @param {number} angularDamping - The new angular damping value. Must be non-negative.\r\n * @returns {void}\r\n * @description\r\n * Sets the angular damping coefficient for a body, which reduces its angular velocity over time.\r\n * Angular damping is a value between 0 and infinity that reduces the body's angular velocity.\r\n * @throws {Error} Throws an assertion error if angularDamping is invalid or negative.\r\n */\r\nexport function b2Body_SetAngularDamping(bodyId, angularDamping)\r\n{\r\n    console.assert(b2IsValid(angularDamping) && angularDamping >= 0.0);\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n    bodySim.angularDamping = angularDamping;\r\n}\r\n\r\n/**\r\n * Gets the angular damping coefficient of a body.\r\n * @function b2Body_GetAngularDamping\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {number} The angular damping coefficient of the body.\r\n * @description\r\n * Returns the angular damping coefficient that reduces the body's angular velocity\r\n * over time. Angular damping is specified in the range [0,1].\r\n */\r\nexport function b2Body_GetAngularDamping(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.angularDamping;\r\n}\r\n\r\n/**\r\n * @function b2Body_SetGravityScale\r\n * @summary Sets the gravity scale factor for a body.\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify.\r\n * @param {number} gravityScale - The scaling factor to apply to gravity for this body.\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if bodyId is invalid or if gravityScale is not a valid number.\r\n * @description\r\n * Sets a scale factor that modifies the effect of gravity on a specific body.\r\n * A value of 1.0 indicates normal gravity, 0.0 indicates no gravity, and negative\r\n * values reverse the effect of gravity on the body.\r\n */\r\nexport function b2Body_SetGravityScale(bodyId, gravityScale)\r\n{\r\n    console.assert(b2Body_IsValid(bodyId));\r\n    console.assert(b2IsValid(gravityScale));\r\n\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n    bodySim.gravityScale = gravityScale;\r\n}\r\n\r\n/**\r\n * Gets the gravity scale of a body.\r\n * @function b2Body_GetGravityScale\r\n * @param {b2BodyId} bodyId - The identifier of the body to query.\r\n * @returns {number} The gravity scale factor of the body.\r\n * @throws {Error} Throws an assertion error if the bodyId is invalid.\r\n */\r\nexport function b2Body_GetGravityScale(bodyId)\r\n{\r\n    console.assert(b2Body_IsValid(bodyId));\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.gravityScale;\r\n}\r\n\r\n/**\r\n * @summary Checks if a body is in the awake set.\r\n * @function b2Body_IsAwake\r\n * @param {b2BodyId} bodyId - The identifier for the body to check.\r\n * @returns {boolean} True if the body is in the awake set, false otherwise.\r\n * @description\r\n * Determines if a body is currently in the awake set by checking its set index\r\n * against the b2_awakeSet type. Bodies in the awake set are actively participating\r\n * in the simulation.\r\n */\r\nexport function b2Body_IsAwake(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.setIndex === b2SetType.b2_awakeSet;\r\n}\r\n\r\n/**\r\n * @summary Sets the awake state of a physics body\r\n * @function b2Body_SetAwake\r\n * @param {b2BodyId} bodyId - The ID of the body to modify\r\n * @param {boolean} awake - True to wake the body, false to put it to sleep\r\n * @returns {void}\r\n * @description\r\n * Controls whether a physics body is awake (active) or asleep (inactive).\r\n * When setting a body to sleep, it will split islands if there are pending constraint removals.\r\n * When waking a body, it will be moved from the sleeping set to the awake set.\r\n */\r\nexport function b2Body_SetAwake(bodyId, awake)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (awake && body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n    else if (awake === false && body.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        // b2CheckIndex(world.islandArray, body.islandId);\r\n        const island = world.islandArray[body.islandId];\r\n\r\n        if (island.constraintRemoveCount > 0)\r\n        {\r\n            b2SplitIsland(world, body.islandId);\r\n        }\r\n\r\n        b2TrySleepIsland(world, body.islandId);\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Checks if a body is enabled in the physics simulation.\r\n * @function b2Body_IsEnabled\r\n * @param {b2BodyId} bodyId - The identifier for the body to check.\r\n * @returns {boolean} True if the body is enabled, false if disabled.\r\n * @description\r\n * Determines if a physics body is enabled by checking if it belongs to the\r\n * disabled set. A disabled body does not participate in collision detection\r\n * or dynamics simulation.\r\n */\r\nexport function b2Body_IsEnabled(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.setIndex !== b2SetType.b2_disabledSet;\r\n}\r\n\r\n/**\r\n * @summary Checks if sleep is enabled for a body.\r\n * @function b2Body_IsSleepEnabled\r\n * @param {b2BodyId} bodyId - The identifier for the body to check.\r\n * @returns {boolean} True if sleep is enabled for the body, false otherwise.\r\n * @description\r\n * Returns whether the specified body has sleep enabled. When sleep is enabled,\r\n * the body can automatically enter a sleep state when it becomes inactive.\r\n */\r\nexport function b2Body_IsSleepEnabled(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.enableSleep;\r\n}\r\n\r\n/**\r\n * Sets the sleep threshold velocity for a body.\r\n * @function b2Body_SetSleepThreshold\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify.\r\n * @param {number} sleepThreshold - The velocity threshold below which the body can sleep.\r\n * @returns {void}\r\n * @description\r\n * Sets the minimum velocity threshold that determines when a body can transition to a sleeping state.\r\n * When a body's velocity falls below this threshold, it becomes eligible for sleeping.\r\n */\r\nexport function b2Body_SetSleepThreshold(bodyId, sleepThreshold)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    body.sleepThreshold = sleepThreshold;\r\n}\r\n\r\n/**\r\n * Gets the sleep threshold value for a body.\r\n * @function b2Body_GetSleepThreshold\r\n * @param {b2BodyId} bodyId - The identifier for the body.\r\n * @returns {number} The sleep threshold value for the body.\r\n * @description\r\n * Returns the minimum speed threshold below which a body can be put to sleep\r\n * to optimize simulation performance.\r\n */\r\nexport function b2Body_GetSleepThreshold(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.sleepThreshold;\r\n}\r\n\r\n/**\r\n * @function b2Body_EnableSleep\r\n * @description\r\n * Enables or disables sleep capability for a specific body. When sleep is disabled,\r\n * the body will be woken if it was sleeping.\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify\r\n * @param {boolean} enableSleep - True to enable sleep capability, false to disable it\r\n * @returns {void}\r\n * @throws {Error} If the world associated with the bodyId is not found\r\n */\r\nexport function b2Body_EnableSleep(bodyId, enableSleep)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    body.enableSleep = enableSleep;\r\n\r\n    if (enableSleep === false)\r\n    {\r\n        b2WakeBody(world, body);\r\n    }\r\n}\r\n\r\n// Disabling a body requires a lot of detailed bookkeeping, but it is a valuable feature.\r\n// The most challenging aspect that joints may connect to bodies that are not disabled.\r\n/**\r\n * @function b2Body_Disable\r\n * @param {b2BodyId} bodyId - The identifier of the body to disable\r\n * @returns {void}\r\n * @description\r\n * Disables a body in the physics simulation by removing it from its current solver set\r\n * and moving it to the disabled set. The function removes all contacts associated with\r\n * the body, removes it from any island it belongs to, destroys shape proxies in the\r\n * broad phase, and transfers associated joints to the disabled set.\r\n * @throws {Error} Throws if the world is locked or invalid\r\n */\r\nexport function b2Body_Disable(bodyId)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.setIndex === b2SetType.b2_disabledSet)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Destroy contacts and wake bodies touching this body. This avoid floating bodies.\r\n    // This is necessary even for static bodies.\r\n    const wakeBodies = true;\r\n    b2DestroyBodyContacts(world, body, wakeBodies);\r\n\r\n    // Disabled bodies are not in an island.\r\n    b2RemoveBodyFromIsland(world, body);\r\n\r\n    // Remove shapes from broad-phase\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n        shapeId = shape.nextShapeId;\r\n        b2DestroyShapeProxy(shape, world.broadPhase);\r\n    }\r\n\r\n    // Transfer simulation data to disabled set\r\n    // b2CheckIndex(world.solverSetArray, body.setIndex);\r\n    const set = world.solverSetArray[body.setIndex];\r\n    const disabledSet = world.solverSetArray[b2SetType.b2_disabledSet];\r\n\r\n    // Transfer body sim\r\n    b2TransferBody(world, disabledSet, set, body);\r\n\r\n    // Unlink joints and transfer\r\n    let jointKey = body.headJointKey;\r\n\r\n    while (jointKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointId = jointKey >> 1;\r\n        const edgeIndex = jointKey & 1;\r\n\r\n        const joint = world.jointArray[jointId];\r\n        jointKey = joint.edges[edgeIndex].nextKey;\r\n\r\n        // joint may already be disabled by other body\r\n        if (joint.setIndex === b2SetType.b2_disabledSet)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        console.assert(joint.setIndex === set.setIndex || set.setIndex === b2SetType.b2_staticSet);\r\n\r\n        // Remove joint from island\r\n        if (joint.islandId !== B2_NULL_INDEX)\r\n        {\r\n            b2UnlinkJoint(world, joint);\r\n        }\r\n\r\n        // Transfer joint to disabled set\r\n        // b2CheckIndex(world.solverSetArray, joint.setIndex);\r\n        const jointSet = world.solverSetArray[joint.setIndex];\r\n        b2TransferJoint(world, disabledSet, jointSet, joint);\r\n    }\r\n\r\n    b2ValidateConnectivity(world);\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2Body_Enable\r\n * @description\r\n * Enables a previously disabled body in the physics world. When enabled, the body's\r\n * shapes are added to the broad-phase collision system, and its joints are\r\n * reconnected to the simulation. The body is moved from the disabled set to either\r\n * the static set or awake set based on its type.\r\n * @param {b2BodyId} bodyId - The identifier of the body to enable\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if joint connectivity validation fails\r\n */\r\nexport function b2Body_Enable(bodyId)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.setIndex !== b2SetType.b2_disabledSet)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const disabledSet = world.solverSetArray[b2SetType.b2_disabledSet];\r\n    const setId = body.type === b2BodyType.b2_staticBody ? b2SetType.b2_staticSet : b2SetType.b2_awakeSet;\r\n    const targetSet = world.solverSetArray[setId];\r\n\r\n    b2TransferBody(world, targetSet, disabledSet, body);\r\n\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    // Add shapes to broad-phase\r\n    const proxyType = body.type;\r\n    const forcePairCreation = true;\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n        shapeId = shape.nextShapeId;\r\n\r\n        b2CreateShapeProxy(shape, world.broadPhase, proxyType, transform, forcePairCreation);\r\n    }\r\n\r\n    if (setId !== b2SetType.b2_staticSet)\r\n    {\r\n        b2CreateIslandForBody(world, setId, body);\r\n    }\r\n\r\n    // Transfer joints. If the other body is disabled, don't transfer.\r\n    // If the other body is sleeping, wake it.\r\n    const mergeIslands = false;\r\n    let jointKey = body.headJointKey;\r\n\r\n    while (jointKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointId = jointKey >> 1;\r\n        const edgeIndex = jointKey & 1;\r\n\r\n        const joint = world.jointArray[jointId];\r\n        console.assert(joint.setIndex === b2SetType.b2_disabledSet);\r\n        console.assert(joint.islandId === B2_NULL_INDEX);\r\n\r\n        jointKey = joint.edges[edgeIndex].nextKey;\r\n\r\n        const bodyA = world.bodyArray[joint.edges[0].bodyId];\r\n        const bodyB = world.bodyArray[joint.edges[1].bodyId];\r\n\r\n        if (bodyA.setIndex === b2SetType.b2_disabledSet || bodyB.setIndex === b2SetType.b2_disabledSet)\r\n        {\r\n            // one body is still disabled\r\n            continue;\r\n        }\r\n\r\n        // Transfer joint first\r\n        let jointSetId;\r\n\r\n        if (bodyA.setIndex === b2SetType.b2_staticSet && bodyB.setIndex === b2SetType.b2_staticSet)\r\n        {\r\n            jointSetId = b2SetType.b2_staticSet;\r\n        }\r\n        else if (bodyA.setIndex === b2SetType.b2_staticSet)\r\n        {\r\n            jointSetId = bodyB.setIndex;\r\n        }\r\n        else\r\n        {\r\n            jointSetId = bodyA.setIndex;\r\n        }\r\n\r\n        // b2CheckIndex(world.solverSetArray, jointSetId);\r\n        const jointSet = world.solverSetArray[jointSetId];\r\n        b2TransferJoint(world, jointSet, disabledSet, joint);\r\n\r\n        // Now that the joint is in the correct set, I can link the joint in the island.\r\n        if (jointSetId !== b2SetType.b2_staticSet)\r\n        {\r\n            b2LinkJoint(world, joint, mergeIslands);\r\n        }\r\n    }\r\n\r\n    // Now merge islands\r\n    b2MergeAwakeIslands(world);\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\n/**\r\n * @function b2Body_SetFixedRotation\r\n * @summary Sets whether a body should have fixed rotation.\r\n * @param {b2BodyId} bodyId - The identifier for the body to modify\r\n * @param {boolean} flag - True to fix the rotation, false to allow rotation\r\n * @returns {void}\r\n * @description\r\n * Sets the fixed rotation state of a body. When enabled, the body will not rotate\r\n * and any existing angular velocity is cleared. The body's mass data is updated\r\n * to reflect the change in rotational constraints.\r\n */\r\nexport function b2Body_SetFixedRotation(bodyId, flag)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    if (body.fixedRotation !== flag)\r\n    {\r\n        body.fixedRotation = flag;\r\n        const state = b2GetBodyState(world, body);\r\n\r\n        if (state !== null)\r\n        {\r\n            state.angularVelocity = 0.0;\r\n        }\r\n        b2UpdateBodyMassData(world, body);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2Body_IsFixedRotation\r\n * @param {b2BodyId} bodyId - The identifier for the body to check\r\n * @returns {boolean} True if the body has fixed rotation enabled, false otherwise\r\n * @description\r\n * Checks whether a body has fixed rotation enabled. When fixed rotation is enabled,\r\n * the body will not rotate in response to torques or collisions.\r\n */\r\nexport function b2Body_IsFixedRotation(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.fixedRotation;\r\n}\r\n\r\n/**\r\n * @function b2Body_SetBullet\r\n * @summary Sets the bullet flag on a physics body.\r\n * @param {b2BodyId} bodyId - The identifier for the physics body.\r\n * @param {boolean} flag - True to enable bullet mode, false to disable it.\r\n * @returns {void}\r\n * @description\r\n * Sets whether a body should be treated as a bullet for continuous collision detection.\r\n * Bullet bodies are designed for fast moving objects that require more precise\r\n * collision detection.\r\n */\r\nexport function b2Body_SetBullet(bodyId, flag)\r\n{\r\n    const world = b2GetWorldLocked(bodyId.world0);\r\n\r\n    if (world === null)\r\n    {\r\n        return;\r\n    }\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n    bodySim.isBullet = flag;\r\n}\r\n\r\n/**\r\n * @function b2Body_IsBullet\r\n * @summary Checks if a body has bullet status.\r\n * @param {b2BodyId} bodyId - The identifier for the body to check.\r\n * @returns {boolean} True if the body is a bullet, false otherwise.\r\n * @description\r\n * Retrieves the bullet status of a body from the physics simulation.\r\n * Bullet bodies undergo continuous collision detection for improved\r\n * accuracy with fast-moving objects.\r\n */\r\nexport function b2Body_IsBullet(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    const bodySim = b2GetBodySim(world, body);\r\n\r\n    return bodySim.isBullet;\r\n}\r\n\r\n/**\r\n * @function b2Body_EnableHitEvents\r\n * @description\r\n * Enables or disables hit event detection for all shapes attached to a body.\r\n * @param {b2BodyId} bodyId - The identifier of the body to modify\r\n * @param {boolean} enableHitEvents - Whether to enable or disable hit events\r\n * @returns {void}\r\n */\r\nexport function b2Body_EnableHitEvents(bodyId, enableHitEvents)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    let shapeId = body.headShapeId;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n        shape.enableHitEvents = enableHitEvents;\r\n        shapeId = shape.nextShapeId;\r\n    }\r\n}\r\n\r\n/**\r\n * @summary Gets the number of shapes attached to a body.\r\n * @function b2Body_GetShapeCount\r\n * @param {b2BodyId} bodyId - The identifier for the body to query.\r\n * @returns {number} The number of shapes attached to the body.\r\n * @description\r\n * Returns the total count of shapes currently attached to the specified body\r\n * in the physics world.\r\n */\r\nexport function b2Body_GetShapeCount(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.shapeCount;\r\n}\r\n\r\n/**\r\n * @function b2Body_GetShapes\r\n * @summary Gets all shapes attached to a body and returns the count.\r\n * @param {b2BodyId} bodyId - The identifier of the body to get shapes from.\r\n * @param {b2ShapeId[]} shapeArray - An array to store the retrieved shape IDs.\r\n * @returns {number} The number of shapes found on the body.\r\n * @description\r\n * Retrieves all shapes attached to the specified body by traversing the linked list\r\n * of shapes starting from the body's headShapeId. Each shape ID is stored in the\r\n * provided shapeArray and the total count is returned.\r\n * If shapeArray is already large enough we can avoid the overhead of growing the array.\r\n */\r\nexport function b2Body_GetShapes(bodyId, shapeArray)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    let shapeId = body.headShapeId;\r\n    let shapeCount = 0;\r\n\r\n    while (shapeId !== B2_NULL_INDEX)\r\n    {\r\n        const shape = world.shapeArray[shapeId];\r\n        const id = new b2ShapeId(shape.id + 1, bodyId.world0, shape.revision);\r\n        shapeArray[shapeCount] = id;\r\n        shapeCount += 1;\r\n        shapeId = shape.nextShapeId;\r\n    }\r\n\r\n    return shapeCount;\r\n}\r\n\r\n/**\r\n * @summary Gets the number of joints connected to a body.\r\n * @function b2Body_GetJointCount\r\n * @param {b2BodyId} bodyId - The identifier for the body to query.\r\n * @returns {number} The number of joints connected to the body.\r\n * @description\r\n * Returns the total count of joints that are connected to the specified body.\r\n */\r\nexport function b2Body_GetJointCount(bodyId)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n\r\n    return body.jointCount;\r\n}\r\n\r\n/**\r\n * @function b2Body_GetJoints\r\n * @summary Gets all joints connected to a body.\r\n * @param {b2BodyId} bodyId - The ID of the body to get joints for\r\n * @param {b2JointId[]} jointArray - Array to store the joint IDs\r\n * @param {number} capacity - Maximum number of joints to retrieve\r\n * @returns {number} The number of joints found and stored in jointArray\r\n * @description\r\n * Retrieves the IDs of all joints connected to the specified body, up to the given capacity.\r\n * The joint IDs are stored in the provided jointArray. The function traverses the body's\r\n * joint list and copies each joint's ID information including the index, world ID and revision.\r\n */\r\nexport function b2Body_GetJoints(bodyId, jointArray, capacity)\r\n{\r\n    const world = b2GetWorld(bodyId.world0);\r\n    const body = b2GetBodyFullId(world, bodyId);\r\n    let jointKey = body.headJointKey;\r\n    let jointCount = 0;\r\n\r\n    while (jointKey !== B2_NULL_INDEX && jointCount < capacity)\r\n    {\r\n        const jointId = jointKey >> 1;\r\n        const edgeIndex = jointKey & 1;\r\n        const joint = b2GetJoint(world, jointId);\r\n        const id = new b2JointId();\r\n        id.index1 = jointId + 1;\r\n        id.world0 = bodyId.world0;\r\n        id.revision = joint.revision;\r\n        jointArray[jointCount] = id;\r\n        jointCount += 1;\r\n        jointKey = joint.edges[edgeIndex].nextKey;\r\n    }\r\n\r\n    return jointCount;\r\n}\r\n\r\nexport function b2ShouldBodiesCollide(world, bodyA, bodyB)\r\n{\r\n    if (bodyA.type !== b2BodyType.b2_dynamicBody && bodyB.type !== b2BodyType.b2_dynamicBody)\r\n    {\r\n        return false;\r\n    }\r\n    let jointKey;\r\n    let otherBodyId;\r\n\r\n    if (bodyA.jointCount < bodyB.jointCount)\r\n    {\r\n        jointKey = bodyA.headJointKey;\r\n        otherBodyId = bodyB.id;\r\n    }\r\n    else\r\n    {\r\n        jointKey = bodyB.headJointKey;\r\n        otherBodyId = bodyA.id;\r\n    }\r\n\r\n    while (jointKey !== B2_NULL_INDEX)\r\n    {\r\n        const jointId = jointKey >> 1;\r\n        const edgeIndex = jointKey & 1;\r\n        const otherEdgeIndex = edgeIndex ^ 1;\r\n        const joint = b2GetJoint(world, jointId);\r\n\r\n        if (joint.collideConnected === false && joint.edges[otherEdgeIndex].bodyId === otherBodyId)\r\n        {\r\n            return false;\r\n        }\r\n        jointKey = joint.edges[edgeIndex].nextKey;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// PJB: recursively deep set obj 'number' properties to zero, similar to the C <struct name> = { 0 };\r\nexport function resetProperties(obj)\r\n{\r\n    const resetProperty = (item) =>\r\n    {\r\n        if (typeof item === 'object' && item !== null)\r\n        {\r\n            Object.keys(item).forEach(key =>\r\n            {\r\n                switch (typeof item[key])\r\n                {\r\n                    case 'number':\r\n                        item[key] = 0;\r\n\r\n                        break;\r\n\r\n                    case 'boolean':\r\n                        item[key] = false;\r\n\r\n                        break;\r\n\r\n                    case 'string':\r\n                        item[key] = '';\r\n\r\n                        break;\r\n\r\n                    case 'object':\r\n                        if (Array.isArray(item[key]))\r\n                        {\r\n                            // item[key] = [];  PJB: don't do this here, it's handled before the call in the rare instances it's needed\r\n                        }\r\n                        else if (item[key] !== null)\r\n                        {\r\n                            resetProperty(item[key]);\r\n                        }\r\n                        else\r\n                        {\r\n                            item[key] = null;\r\n                        }\r\n\r\n                        break;\r\n\r\n                    // For functions, symbols, etc., we leave them as is\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    resetProperty(obj);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Rot, b2Transform, b2Vec2 } from './math_functions_h.js';\r\n\r\nimport { B2_NULL_INDEX } from '../core_c.js';\r\nimport { b2BodyType } from './types_h.js';\r\n\r\nexport class b2Body\r\n{\r\n    constructor()\r\n    {\r\n        this.userData = null;\r\n        this.setIndex = 0;\r\n        this.localIndex = 0;\r\n        this.headContactKey = 0;\r\n        this.contactCount = 0;\r\n        this.headShapeId = 0;\r\n        this.shapeCount = 0;\r\n        this.headChainId = 0;\r\n        this.headJointKey = B2_NULL_INDEX;\r\n        this.jointCount = 0;\r\n        this.islandId = 0;\r\n        this.islandPrev = 0;\r\n        this.islandNext = 0;\r\n        this.sleepThreshold = 0;\r\n        this.sleepTime = 0;\r\n        this.bodyMoveIndex = 0;\r\n        this.id = B2_NULL_INDEX;\r\n        this.type = b2BodyType.b2_staticBody;\r\n        this.revision = 0;\r\n        this.enableSleep = false;\r\n        this.fixedRotation = false;\r\n        this.isSpeedCapped = false;\r\n        this.isMarked = false;\r\n        this.updateBodyMass = false;\r\n    }\r\n}\r\n\r\nexport class b2BodyState\r\n{\r\n    constructor()\r\n    {\r\n        this.linearVelocity = new b2Vec2(0, 0);\r\n        this.angularVelocity = 0;\r\n        this.flags = 0;\r\n        this.deltaPosition = new b2Vec2(0, 0);\r\n        this.deltaRotation = new b2Rot(1, 0);\r\n    }\r\n}\r\n\r\n// export const b2_identityBodyState = new b2BodyState();\r\n\r\nexport class b2BodySim\r\n{\r\n    constructor()\r\n    {\r\n        this.transform = new b2Transform();\r\n        this.center = new b2Vec2(0, 0);\r\n        this.rotation0 = new b2Rot(1, 0);\r\n        this.center0X = 0;\r\n        this.center0Y = 0;\r\n        this.localCenter = new b2Vec2(0, 0);\r\n        this.force = new b2Vec2(0, 0);\r\n        this.torque = 0;\r\n        this.mass = 0;\r\n        this.invMass = 0;\r\n        this.inertia = 0;\r\n        this.invInertia = 0;\r\n        this.minExtent = 0;\r\n        this.maxExtent = 0;\r\n        this.linearDamping = 0;\r\n        this.angularDamping = 0;\r\n        this.gravityScale = 0;\r\n        this.bodyId = 0;\r\n        this.isFast = false;\r\n        this.isBullet = false;\r\n        this.isSpeedCapped = false;\r\n        this.allowFastRotation = false;\r\n        this.enlargeAABB = false;\r\n    }\r\n\r\n    copyTo(dst)\r\n    {\r\n        dst.transform = this.transform.deepClone();\r\n        dst.center = this.center.clone();\r\n        dst.rotation0 = this.rotation0.clone();\r\n        dst.center0X = this.center0X;\r\n        dst.center0Y = this.center0Y;\r\n        dst.localCenter = this.localCenter.clone();\r\n        dst.force = this.force.clone();\r\n        dst.torque = this.torque;\r\n        dst.mass = this.mass;\r\n        dst.invMass = this.invMass;\r\n        dst.inertia = this.inertia;\r\n        dst.invInertia = this.invInertia;\r\n        dst.minExtent = this.minExtent;\r\n        dst.maxExtent = this.maxExtent;\r\n        dst.linearDamping = this.linearDamping;\r\n        dst.angularDamping = this.angularDamping;\r\n        dst.gravityScale = this.gravityScale;\r\n        dst.bodyId = this.bodyId;\r\n        dst.isFast = this.isFast;\r\n        dst.isBullet = this.isBullet;\r\n        dst.isSpeedCapped = this.isSpeedCapped;\r\n        dst.allowFastRotation = this.allowFastRotation;\r\n        dst.enlargeAABB = this.enlargeAABB;\r\n    }\r\n}\r\n\r\nexport {\r\n    b2CreateBody, b2DestroyBody, b2GetBodyFullId, b2GetBody, b2GetBodyTransformQuick, b2GetBodyTransform, b2MakeBodyId,\r\n    b2ShouldBodiesCollide, b2IsBodyAwake, b2GetBodySim, b2GetBodyState, b2WakeBody, b2UpdateBodyMassData,\r\n    b2Body_IsEnabled, b2Body_GetType, b2Body_SetType, b2Body_GetUserData, b2Body_SetUserData,\r\n    b2Body_GetLocalPoint,\r\n    b2Body_GetPosition, b2Body_GetRotation, b2Body_SetTransform,\r\n    b2Body_GetMassData, b2Body_SetMassData, b2Body_GetMass,\r\n    b2Body_GetTransform, b2Body_ApplyTorque, b2Body_GetWorldPoint, b2Body_GetWorldVector,\r\n    b2Body_GetLinearDamping, b2Body_SetLinearDamping, b2Body_GetLinearVelocity, b2Body_SetLinearVelocity, b2Body_ApplyLinearImpulse, b2Body_ApplyLinearImpulseToCenter,\r\n    b2Body_GetAngularVelocity, b2Body_SetAngularVelocity, b2Body_ApplyAngularImpulse,\r\n    b2Body_GetRotationalInertia, b2Body_GetLocalCenterOfMass, b2Body_GetWorldCenterOfMass,\r\n    b2Body_ApplyMassFromShapes, b2Body_SetAngularDamping, b2Body_GetAngularDamping, b2Body_SetGravityScale, b2Body_GetGravityScale,\r\n    b2Body_EnableSleep, b2Body_IsSleepEnabled, b2Body_SetSleepThreshold, b2Body_GetSleepThreshold,\r\n    b2Body_Enable, b2Body_Disable,\r\n    b2Body_SetFixedRotation, b2Body_IsFixedRotation,\r\n    b2Body_GetLocalVector, b2Body_SetBullet, b2Body_IsBullet, b2Body_EnableHitEvents,\r\n    b2Body_GetShapeCount, b2Body_GetShapes, b2Body_GetJointCount, b2Body_GetJoints,\r\n    b2Body_ApplyForce, b2Body_SetAwake, b2Body_IsAwake, b2Body_ApplyForceToCenter,\r\n    b2Body_GetContactCapacity, b2Body_GetContactData, b2Body_ComputeAABB,\r\n    b2MakeSweep,\r\n    resetProperties\r\n} from '../body_c.js';\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Alloc, b2Grow } from './include/allocate_h.js';\r\nimport { b2BodySim, b2BodyState, resetProperties } from './include/body_h.js';\r\n\r\nimport { B2_NULL_INDEX } from './include/core_h.js';\r\nimport { b2ContactSim } from './include/contact_h.js';\r\nimport { b2IslandSim } from './include/island_h.js';\r\nimport { b2JointSim } from './include/joint_h.js';\r\n\r\n/**\r\n * @namespace BlockArray\r\n */\r\n\r\nconst B2_INITIAL_CAPACITY = 16;\r\n\r\nexport class b2BodySimArray\r\n{\r\n    constructor(capacity = 0)\r\n    {\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = capacity;\r\n    }\r\n}\r\n\r\nexport class b2BodyStateArray\r\n{\r\n    constructor(capacity = 0)\r\n    {\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = capacity;\r\n    }\r\n}\r\n\r\nexport class b2ContactArray\r\n{\r\n    constructor(capacity = 0)\r\n    {\r\n        /** @type {b2ContactSim[]} */\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = capacity;\r\n    }\r\n}\r\n\r\nexport class b2IslandArray\r\n{\r\n    constructor(capacity = 0)\r\n    {\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = capacity;\r\n    }\r\n}\r\n\r\nexport class b2JointArray\r\n{\r\n    constructor(capacity = 0)\r\n    {\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = capacity;\r\n    }\r\n}\r\n\r\nexport function b2CreateBodySimArray(capacity)\r\n{\r\n    const array = new b2BodySimArray(capacity);\r\n\r\n    if (capacity > 0)\r\n    {\r\n        array.data = b2Alloc(capacity, () => { return new b2BodySim(); });\r\n\r\n        return array;\r\n    }\r\n    array.data = null;\r\n\r\n    return array;\r\n}\r\n\r\nexport function b2CreateBodyStateArray(capacity)\r\n{\r\n    const array = new b2BodyStateArray(capacity);\r\n\r\n    if (capacity > 0)\r\n    {\r\n        array.data = b2Alloc(capacity, () => { return new b2BodyState(); });\r\n\r\n        return array;\r\n    }\r\n    array.data = null;\r\n\r\n    return array;\r\n}\r\n\r\nexport function b2CreateContactArray(capacity)\r\n{\r\n    const array = new b2ContactArray(capacity);\r\n\r\n    if (capacity > 0)\r\n    {\r\n        array.data = b2Alloc(capacity, () => { return new b2ContactSim(); });\r\n\r\n        // console.warn(\"b2CreateContactArray \" + capacity);\r\n        return array;\r\n    }\r\n    array.data = null;\r\n\r\n    return array;\r\n}\r\n\r\nexport function b2CreateJointArray(capacity)\r\n{\r\n    const array = new b2JointArray(capacity);\r\n\r\n    if (capacity > 0)\r\n    {\r\n        array.data = b2Alloc(capacity, () => { return new b2JointSim(); });\r\n\r\n        return array;\r\n    }\r\n    array.data = null;\r\n\r\n    return array;\r\n}\r\n\r\nexport function b2CreateIslandArray(capacity)\r\n{\r\n    const array = new b2IslandArray(capacity);\r\n\r\n    if (capacity > 0)\r\n    {\r\n        array.data = b2Alloc(capacity, () => { return new b2IslandSim(); });\r\n\r\n        return array;\r\n    }\r\n    array.data = null;\r\n\r\n    return array;\r\n}\r\n\r\nexport function b2AddBodySim(array)\r\n{\r\n    if (array.capacity === 0)\r\n    {\r\n        console.assert(array.count === 0);\r\n        array.data = b2Alloc(B2_INITIAL_CAPACITY, () => { return new b2BodySim(); });\r\n        array.capacity = B2_INITIAL_CAPACITY;\r\n        array.count = 0;\r\n    }\r\n    else if (array.count === array.capacity)\r\n    {\r\n        const newCapacity = 2 * array.capacity;\r\n        b2Grow(array.data, newCapacity, () => { return new b2BodySim(); });\r\n        array.capacity = newCapacity;\r\n    }\r\n    else\r\n    {\r\n        resetProperties(array.data[array.count]);\r\n    }\r\n\r\n    array.count += 1;\r\n\r\n    return array.data[array.count - 1];\r\n}\r\n\r\nexport function b2AddBodyState(array)\r\n{\r\n    if (array.capacity === 0)\r\n    {\r\n        console.assert(array.count === 0);\r\n        array.data = b2Alloc(B2_INITIAL_CAPACITY, () => { return new b2BodyState(); });\r\n        array.capacity = B2_INITIAL_CAPACITY;\r\n        array.count = 0;\r\n    }\r\n    else if (array.count === array.capacity)\r\n    {\r\n        const newCapacity = 2 * array.capacity;\r\n        b2Grow(array.data, newCapacity, () => { return new b2BodyState(); });\r\n        array.capacity = newCapacity;\r\n    }\r\n    else\r\n    {\r\n        resetProperties(array.data[array.count]);\r\n    }\r\n\r\n    array.count += 1;\r\n\r\n    return array.data[array.count - 1];\r\n}\r\n\r\n// create a b2ContactSim and add it to array, maintain count and capacity\r\nexport function b2AddContact(array)\r\n{\r\n    if (array.capacity === 0)\r\n    {\r\n        console.assert(array.count === 0);\r\n        array.data = b2Alloc(B2_INITIAL_CAPACITY, () => { return new b2ContactSim(); });\r\n        array.capacity = B2_INITIAL_CAPACITY;\r\n        array.count = 0;\r\n    }\r\n    else if (array.count === array.capacity)\r\n    {\r\n        // PJB: grow quickly to avoid a bunch of these...\r\n        const newCapacity = 8 * array.capacity;\r\n        b2Grow(array.data, newCapacity, () => { return new b2ContactSim(); });\r\n        array.capacity = newCapacity;\r\n    }\r\n    else\r\n    {\r\n        const sim = array.data[array.count];\r\n        resetProperties(sim);\r\n        sim._bodyIdA = sim._bodyIdB = B2_NULL_INDEX;\r\n    }\r\n\r\n    array.count += 1;\r\n\r\n    return array.data[array.count - 1];\r\n}\r\n\r\nexport function b2AddJoint(array)\r\n{\r\n    // array type: b2JointArray*\r\n    if (array.capacity === 0)\r\n    {\r\n        console.assert(array.count === 0);\r\n        array.data = b2Alloc(B2_INITIAL_CAPACITY, () => { return new b2JointSim(); });\r\n        array.capacity = B2_INITIAL_CAPACITY;\r\n        array.count = 0;\r\n    }\r\n    else if (array.count === array.capacity)\r\n    {\r\n        const newCapacity = 2 * array.capacity;\r\n        b2Grow(array.data, newCapacity, () => { return new b2JointSim(); });\r\n        array.capacity = newCapacity;\r\n    }\r\n    else\r\n    {\r\n        resetProperties(array.data[array.count]);\r\n    }\r\n\r\n    array.count += 1;\r\n    console.assert(array.data[array.count - 1].type !== undefined, `${new Error().stack}`);\r\n\r\n    return array.data[array.count - 1];\r\n}\r\n\r\nexport function b2AddIsland(array)\r\n{\r\n    if (array.capacity === 0)\r\n    {\r\n        console.assert(array.count === 0);\r\n        array.data = b2Alloc(B2_INITIAL_CAPACITY, () => { return new b2IslandSim(); });\r\n        array.capacity = B2_INITIAL_CAPACITY;\r\n        array.count = 0;\r\n    }\r\n    else if (array.count === array.capacity)\r\n    {\r\n        const newCapacity = 2 * array.capacity;\r\n        b2Grow(array.data, newCapacity, () => { return new b2IslandSim(); });\r\n        array.capacity = newCapacity;\r\n    }\r\n    else\r\n    {\r\n        resetProperties(array.data[array.count]);\r\n    }\r\n\r\n    array.count += 1;\r\n    array.data[array.count - 1].islandId = B2_NULL_INDEX;\r\n\r\n    return array.data[array.count - 1];\r\n}\r\n\r\nfunction removeArrayIndex(array, index)\r\n{\r\n    console.assert(0 <= index && index < array.count);\r\n\r\n    if (index < array.count - 1)\r\n    {\r\n        const swapA = array.data[array.count - 1];\r\n        const swapB = array.data[index];\r\n        array.data[index] = swapA;\r\n        array.data[array.count - 1] = swapB;\r\n        array.count -= 1;\r\n\r\n        return array.count;\r\n    }\r\n    array.count -= 1;\r\n\r\n    return B2_NULL_INDEX;\r\n}\r\n\r\nexport function b2RemoveBodySim(array, index)\r\n{\r\n    return removeArrayIndex(array, index);\r\n}\r\n\r\nexport function b2RemoveBodyState(array, index)\r\n{\r\n    return removeArrayIndex(array, index);\r\n}\r\n\r\nexport function b2RemoveContact(array, index)\r\n{\r\n    return removeArrayIndex(array, index);\r\n}\r\n\r\nexport function b2RemoveJoint(array, index)\r\n{\r\n    return removeArrayIndex(array, index);\r\n}\r\n\r\nexport function b2RemoveIsland(array, index)\r\n{\r\n    return removeArrayIndex(array, index);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_MAX_POLYGON_VERTICES, b2Capsule, b2DistanceInput, b2ManifoldPoint, b2Polygon } from './include/collision_h.js';\r\nimport {\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2DistanceSquared,\r\n    b2Dot,\r\n    b2DotSub,\r\n    b2GetLengthAndNormalize,\r\n    b2InvMulTransformsOut,\r\n    b2LeftPerp,\r\n    b2LengthXY,\r\n    b2Lerp,\r\n    b2MulAdd,\r\n    b2MulAddOut,\r\n    b2MulSV,\r\n    b2Neg,\r\n    b2Normalize,\r\n    b2RightPerp,\r\n    b2Rot,\r\n    b2RotateVector,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2TransformPointOut,\r\n    b2Vec2,\r\n    eps,\r\n    epsSqr\r\n} from './include/math_functions_h.js';\r\nimport { b2MakeProxy, b2SegmentDistance, b2ShapeDistance } from './include/distance_h.js';\r\nimport { b2_linearSlop, b2_speculativeDistance } from './include/core_h.js';\r\n\r\nimport { resetProperties } from './body_c.js';\r\n\r\n/**\r\n * @namespace Manifold\r\n */\r\n\r\n/**\r\n * @import {b2Segment, b2Circle, b2ChainSegment, b2DistanceCache, b2Manifold} from './include/collision_h.js'\r\n */\r\n\r\nconst B2_MAKE_ID = (A, B) => ((A & 0xFF) << 8) | (B & 0xFF);\r\n\r\nconst xf = new b2Transform(new b2Vec2(), new b2Rot());\r\nconst xf1 = new b2Transform(new b2Vec2(), new b2Rot());\r\nconst p1 = new b2Vec2();\r\nconst p2 = new b2Vec2();\r\nconst q1 = new b2Vec2();\r\nconst q2 = new b2Vec2();\r\n\r\nfunction b2MakeCapsule(p1, p2, radius)\r\n{\r\n    const d = b2Sub(p2, p1);\r\n    const axis = b2Normalize(d);\r\n    const normal = b2RightPerp(axis);\r\n\r\n    const shape = new b2Polygon();\r\n    shape.vertices = [ p1, p2 ];\r\n    shape.centroid = b2Lerp(p1, p2, 0.5);\r\n    shape.normals = [ normal, b2Neg(normal) ];\r\n    shape.count = 2;\r\n    shape.radius = radius;\r\n\r\n    return shape;\r\n}\r\n\r\n/**\r\n * @function b2CollideCircles\r\n * @description\r\n * Computes collision information between two circles transformed by their respective transforms.\r\n * @param {b2Circle} circleA - The first circle\r\n * @param {b2Transform} xfA - Transform for the first circle\r\n * @param {b2Circle} circleB - The second circle\r\n * @param {b2Transform} xfB - Transform for the second circle\r\n * @param {b2Manifold} manifold - The output collision manifold\r\n * @returns {b2Manifold} The collision manifold containing contact points, normal, and separation\r\n * information. If no collision is detected, returns a cleared manifold.\r\n */\r\nexport function b2CollideCircles(circleA, xfA, circleB, xfB, manifold)\r\n{\r\n    // let manifold = new b2Manifold();\r\n\r\n    b2InvMulTransformsOut(xfA, xfB, xf);\r\n\r\n    const pointA = circleA.center;\r\n\r\n    // let pointB = b2TransformPoint(xf, circleB.center);\r\n    const pointBX = (xf.q.c * circleB.center.x - xf.q.s * circleB.center.y) + xf.p.x;\r\n    const pointBY = (xf.q.s * circleB.center.x + xf.q.c * circleB.center.y) + xf.p.y;\r\n\r\n    const sx = pointBX - pointA.x;\r\n    const sy = pointBY - pointA.y;\r\n    const distance = Math.sqrt(sx * sx + sy * sy);\r\n    let normalX = 0,\r\n        normalY = 0;\r\n\r\n    if (distance >= eps)\r\n    {\r\n        normalX = sx / distance;\r\n        normalY = sy / distance;\r\n    }\r\n    const radiusA = circleA.radius;\r\n    const radiusB = circleB.radius;\r\n    const separation = distance - radiusA - radiusB;\r\n\r\n    if (separation > b2_speculativeDistance)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n    const cAx = pointA.x + radiusA * normalX;\r\n    const cAy = pointA.y + radiusA * normalY;\r\n    const cBx = pointBX + (-radiusB) * normalX;\r\n    const cBy = pointBY + (-radiusB) * normalY;\r\n    const contactPointAx = cAx + 0.5 * (cBx - cAx);\r\n    const contactPointAy = cAy + 0.5 * (cBy - cAy);\r\n    manifold.normalX = xfA.q.c * normalX - xfA.q.s * normalY;\r\n    manifold.normalY = xfA.q.s * normalX + xfA.q.c * normalY;\r\n    manifold.normalX = xfA.q.c * normalX - xfA.q.s * normalY;\r\n    manifold.normalY = xfA.q.s * normalX + xfA.q.c * normalY;\r\n    const mp = manifold.points[0];\r\n    mp.anchorAX = xfA.q.c * contactPointAx - xfA.q.s * contactPointAy;\r\n    mp.anchorAY = xfA.q.s * contactPointAx + xfA.q.c * contactPointAy;\r\n    mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n    mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n    mp.pointX = xfA.p.x + mp.anchorAX;\r\n    mp.pointY = xfA.p.y + mp.anchorAY;\r\n    mp.separation = separation;\r\n    mp.id = 0;\r\n    manifold.pointCount = 1;\r\n\r\n    return manifold;\r\n}\r\n\r\n/**\r\n * @function b2CollideCapsuleAndCircle\r\n * @description\r\n * Computes collision information between a capsule shape and a circle shape.\r\n * @param {b2Capsule} capsuleA - The capsule shape A with properties center1, center2, and radius\r\n * @param {b2Transform} xfA - Transform for shape A containing position (p) and rotation (q)\r\n * @param {b2Circle} circleB - The circle shape B with properties center and radius\r\n * @param {b2Transform} xfB - Transform for shape B containing position (p) and rotation (q)\r\n * @param {b2Manifold} manifold - Output collision manifold to be populated\r\n * @returns {b2Manifold} The populated collision manifold containing contact points,\r\n * normal, separation, and other collision data\r\n */\r\nexport function b2CollideCapsuleAndCircle(capsuleA, xfA, circleB, xfB, manifold)\r\n{\r\n    // let manifold = new b2Manifold();\r\n\r\n    b2InvMulTransformsOut(xfA, xfB, xf);\r\n\r\n    // Compute circle position in the frame of the capsule.\r\n    const pB = b2TransformPoint(xf, circleB.center);\r\n\r\n    // Compute closest point\r\n    const p1 = capsuleA.center1;\r\n    const p2 = capsuleA.center2;\r\n\r\n    const e = b2Sub(p2, p1);\r\n\r\n    // dot(p - pA, e) = 0\r\n    // dot(p - (p1 + s1 * e), e) = 0\r\n    // s1 = dot(p - p1, e)\r\n    let pA;\r\n    const s1 = b2Dot(b2Sub(pB, p1), e);\r\n    const s2 = b2Dot(b2Sub(p2, pB), e);\r\n\r\n    if (s1 < 0.0)\r\n    {\r\n        // p1 region\r\n        pA = p1;\r\n    }\r\n    else if (s2 < 0.0)\r\n    {\r\n        // p2 region\r\n        pA = p2;\r\n    }\r\n    else\r\n    {\r\n        // circle colliding with segment interior\r\n        const s = s1 / b2Dot(e, e);\r\n        pA = b2MulAdd(p1, s, e);\r\n    }\r\n\r\n    const res = b2GetLengthAndNormalize(b2Sub(pB, pA));\r\n    const distance = res.length;\r\n    const normal = res.normal;\r\n\r\n    const radiusA = capsuleA.radius;\r\n    const radiusB = circleB.radius;\r\n    const separation = distance - radiusA - radiusB;\r\n\r\n    if (separation > b2_speculativeDistance)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    const cA = b2MulAdd(pA, radiusA, normal);\r\n    const cB = b2MulAdd(pB, -radiusB, normal);\r\n    const contactPointA = b2Lerp(cA, cB, 0.5);\r\n\r\n    // manifold.normal = b2RotateVector(xfA.q, normal);\r\n    manifold.normalX = xfA.q.c * normal.x - xfA.q.s * normal.y;\r\n    manifold.normalY = xfA.q.s * normal.x + xfA.q.c * normal.y;\r\n    const mp = manifold.points[0];\r\n\r\n    // mp.anchorA = b2RotateVector(xfA.q, contactPointA);\r\n    mp.anchorAX = xfA.q.c * contactPointA.x - xfA.q.s * contactPointA.y;\r\n    mp.anchorAY = xfA.q.s * contactPointA.x + xfA.q.c * contactPointA.y;\r\n\r\n    // mp.anchorB = b2Add(mp.anchorA, b2Sub(xfA.p, xfB.p));\r\n    mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n    mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n\r\n    // mp.point = b2Add(xfA.p, mp.anchorA);\r\n    mp.pointX = xfA.p.x + mp.anchorAX;\r\n    mp.pointY = xfA.p.y + mp.anchorAY;\r\n    mp.separation = separation;\r\n    mp.id = 0;\r\n    manifold.pointCount = 1;\r\n\r\n    return manifold;\r\n}\r\n\r\nconst c = new b2Vec2();\r\n\r\n/**\r\n * @function b2CollidePolygonAndCircle\r\n * @description\r\n * Computes collision information between a polygon and a circle.\r\n * @param {b2Polygon} polygonA - The polygon shape\r\n * @param {b2Transform} xfA - Transform for polygon A\r\n * @param {b2Circle} circleB - The circle shape\r\n * @param {b2Transform} xfB - Transform for circle B\r\n * @param {b2Manifold} manifold - Output collision manifold\r\n * @returns {b2Manifold} The collision manifold containing contact points, normal, and separation\r\n * @note The manifold is cleared and returned if no collision is detected.\r\n * The function handles three cases:\r\n * 1. Circle center closest to polygon vertex 1\r\n * 2. Circle center closest to polygon vertex 2\r\n * 3. Circle center closest to polygon edge\r\n */\r\nexport function b2CollidePolygonAndCircle(polygonA, xfA, circleB, xfB, manifold)\r\n{\r\n    const speculativeDistance = b2_speculativeDistance;\r\n\r\n    b2InvMulTransformsOut(xfA, xfB, xf);\r\n\r\n    // Compute circle position in the frame of the polygon.\r\n    b2TransformPointOut(xf, circleB.center, c);\r\n    const radiusA = polygonA.radius;\r\n    const radiusB = circleB.radius;\r\n    const radius = radiusA + radiusB;\r\n\r\n    // Find the min separating edge.\r\n    let normalIndex = 0;\r\n    let separation = -Number.MAX_VALUE;\r\n    const vertexCount = polygonA.count;\r\n    const vertices = polygonA.vertices;\r\n    const normals = polygonA.normals;\r\n\r\n    for (let i = 0; i < vertexCount; ++i)\r\n    {\r\n        // let s = b2Dot(normals[i], b2Sub(c, vertices[i]));\r\n        const s = normals[i].x * (c.x - vertices[i].x) + normals[i].y * (c.y - vertices[i].y);\r\n\r\n        if (s > separation)\r\n        {\r\n            separation = s;\r\n            normalIndex = i;\r\n        }\r\n    }\r\n\r\n    if (separation > radius + speculativeDistance)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    // Vertices of the reference edge.\r\n    const vertIndex1 = normalIndex;\r\n    const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\r\n    const v1 = vertices[vertIndex1];\r\n    const v2 = vertices[vertIndex2];\r\n\r\n    // Compute barycentric coordinates\r\n    const u1 = (c.x - v1.x) * (v2.x - v1.x) + (c.y - v1.y) * (v2.y - v1.y);\r\n    const u2 = (c.x - v2.x) * (v1.x - v2.x) + (c.y - v2.y) * (v1.y - v2.y);\r\n\r\n    if (u1 < 0.0 && separation > eps)\r\n    {\r\n        // Circle center is closest to v1 and safely outside the polygon\r\n        const x = c.x - v1.x;\r\n        const y = c.y - v1.y;\r\n        const length = Math.sqrt(x * x + y * y);\r\n        let normalX = 0,\r\n            normalY = 0;\r\n\r\n        if (length > eps)\r\n        {\r\n            const invLength = 1 / length;\r\n            normalX = x * invLength;\r\n            normalY = y * invLength;\r\n        }\r\n\r\n        separation = (c.x - v1.x) * normalX + (c.y - v1.y) * normalY;\r\n\r\n        if (separation > radius + speculativeDistance)\r\n        {\r\n            return manifold.clear();\r\n        }\r\n\r\n        const cAX = v1.x + radiusA * normalX;\r\n        const cAY = v1.y + radiusA * normalY;\r\n        const cBX = c.x - radiusB * normalX;\r\n        const cBY = c.y - radiusB * normalY;\r\n        const contactPointAX = 0.5 * (cAX + cBX);\r\n        const contactPointAY = 0.5 * (cAY + cBY);\r\n\r\n        manifold.normalX = xfA.q.c * normalX - xfA.q.s * normalY;\r\n        manifold.normalY = xfA.q.s * normalX + xfA.q.c * normalY;\r\n        const mp = manifold.points[0];\r\n        mp.anchorAX = xfA.q.c * contactPointAX - xfA.q.s * contactPointAY;\r\n        mp.anchorAY = xfA.q.s * contactPointAX + xfA.q.c * contactPointAY;\r\n        mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n        mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n        mp.pointX = xfA.p.x + mp.anchorAX;\r\n        mp.pointY = xfA.p.y + mp.anchorAY;\r\n        mp.separation = (cBX - cAX) * normalX + (cBY - cAY) * normalY;\r\n        mp.id = 0;\r\n        manifold.pointCount = 1;\r\n    }\r\n    else if (u2 < 0.0 && separation > eps)\r\n    {\r\n        // Circle center is closest to v2 and safely outside the polygon\r\n        const x = c.x - v2.x;\r\n        const y = c.y - v2.y;\r\n        const length = Math.sqrt(x * x + y * y);\r\n        let normalX = 0,\r\n            normalY = 0;\r\n\r\n        if (length > eps)\r\n        {\r\n            const invLength = 1 / length;\r\n            normalX = x * invLength;\r\n            normalY = y * invLength;\r\n        }\r\n\r\n        separation = (c.x - v2.x) * normalX + (c.y - v2.y) * normalY;\r\n\r\n        if (separation > radius + speculativeDistance)\r\n        {\r\n            return manifold.clear();\r\n        }\r\n\r\n        const cAX = v2.x + radiusA * normalX;\r\n        const cAY = v2.y + radiusA * normalY;\r\n        const cBX = c.x - radiusB * normalX;\r\n        const cBY = c.y - radiusB * normalY;\r\n        const contactPointAX = 0.5 * (cAX + cBX);\r\n        const contactPointAY = 0.5 * (cAY + cBY);\r\n\r\n        manifold.normalX = xfA.q.c * normalX - xfA.q.s * normalY;\r\n        manifold.normalY = xfA.q.s * normalX + xfA.q.c * normalY;\r\n        const mp = manifold.points[0];\r\n        mp.anchorAX = xfA.q.c * contactPointAX - xfA.q.s * contactPointAY;\r\n        mp.anchorAY = xfA.q.s * contactPointAX + xfA.q.c * contactPointAY;\r\n        mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n        mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n        mp.pointX = xfA.p.x + mp.anchorAX;\r\n        mp.pointY = xfA.p.y + mp.anchorAY;\r\n        mp.separation = (cBX - cAX) * normalX + (cBY - cAY) * normalY;\r\n        mp.id = 0;\r\n        manifold.pointCount = 1;\r\n    }\r\n    else\r\n    {\r\n        // Circle center is between v1 and v2. Center may be inside polygon\r\n        const normalX = normals[normalIndex].x;\r\n        const normalY = normals[normalIndex].y;\r\n        manifold.normalX = xfA.q.c * normalX - xfA.q.s * normalY;\r\n        manifold.normalY = xfA.q.s * normalX + xfA.q.c * normalY;\r\n\r\n        // cA is the projection of the circle center onto to the reference edge\r\n        const d = radiusA - ((c.x - v1.x) * normalX + (c.y - v1.y) * normalY);\r\n        const cAX = c.x + d * normalX;\r\n        const cAY = c.y + d * normalY;\r\n\r\n        // cB is the deepest point on the circle with respect to the reference edge\r\n        const cBX = c.x - radiusB * normalX;\r\n        const cBY = c.y - radiusB * normalY;\r\n\r\n        // contactPointA is the midpoint between cA and cB\r\n        const contactPointAX = (cAX + cBX) * 0.5;\r\n        const contactPointAY = (cAY + cBY) * 0.5;\r\n\r\n        // The contact point is the midpoint in world space\r\n        const mp = manifold.points[0];\r\n        mp.anchorAX = xfA.q.c * contactPointAX - xfA.q.s * contactPointAY;\r\n        mp.anchorAY = xfA.q.s * contactPointAX + xfA.q.c * contactPointAY;\r\n        mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n        mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n        mp.pointX = xfA.p.x + mp.anchorAX;\r\n        mp.pointY = xfA.p.y + mp.anchorAY;\r\n        mp.separation = separation - radius;\r\n        mp.id = 0;\r\n        manifold.pointCount = 1;\r\n    }\r\n\r\n    return manifold;\r\n}\r\n\r\n// PJB - with allocation avoidance edits\r\n\r\n/**\r\n * @function b2CollideCapsules\r\n * @description\r\n * Computes the collision manifold between two capsule shapes in 2D space.\r\n * A capsule is defined by two endpoints and a radius.\r\n * @param {b2Capsule} capsuleA - The first capsule shape\r\n * @param {b2Transform} xfA - Transform for the first capsule\r\n * @param {b2Capsule} capsuleB - The second capsule shape\r\n * @param {b2Transform} xfB - Transform for the second capsule\r\n * @param {b2Manifold} manifold - Output collision manifold\r\n * @returns {void} Modifies the manifold parameter with collision data:\r\n * - normalX/Y: Collision normal vector\r\n * - pointCount: Number of contact points (0-2)\r\n * - points[]: Contact point data including:\r\n * - anchorA/B: Contact points in local coordinates\r\n * - separation: Penetration depth\r\n * - id: Contact ID\r\n */\r\nexport function b2CollideCapsules(capsuleA, xfA, capsuleB, xfB, manifold)\r\n{\r\n    const origin = capsuleA.center1;\r\n\r\n    // let sfA = {\r\n    //     p: b2Add(xfA.p, b2RotateVector(xfA.q, origin)),\r\n    //     q: xfA.q\r\n    // };\r\n    b2MulAddOut(xfA.p, 1, b2RotateVector(xfA.q, origin), xf1.p);\r\n    xf1.q = xfA.q;\r\n    b2InvMulTransformsOut(xf1, xfB, xf);\r\n\r\n    // let p1 = new b2Vec2(0, 0);\r\n    p1.x = 0;\r\n    p1.y = 0;\r\n\r\n    // let q1 = b2Sub(capsuleA.center2, origin);\r\n    q1.x = capsuleA.center2.x - origin.x;\r\n    q1.y = capsuleA.center2.y - origin.y;\r\n\r\n    // let p2 = b2TransformPoint(xf, capsuleB.center1);\r\n    b2TransformPointOut(xf, capsuleB.center1, p2);\r\n\r\n    // let q2 = b2TransformPoint(xf, capsuleB.center2);\r\n    b2TransformPointOut(xf, capsuleB.center2, q2);\r\n    const d1X = q1.x;\r\n    const d1Y = q1.y;\r\n    const d2X = q2.x - p2.x;\r\n    const d2Y = q2.y - p2.y;\r\n    const dd1 = d1X * d1X + d1Y * d1Y;\r\n    const dd2 = d2X * d2X + d2Y * d2Y;\r\n    console.assert(dd1 > epsSqr && dd2 > epsSqr, `dd1=${dd1} dd2=${dd2} (both should be > epsilon squared)`);\r\n    const rX = p1.x - p2.x;\r\n    const rY = p1.y - p2.y;\r\n    const rd1 = rX * d1X + rY * d1Y;\r\n    const rd2 = rX * d2X + rY * d2Y;\r\n    const d12 = d1X * d2X + d1Y * d2Y;\r\n    const denom = dd1 * dd2 - d12 * d12;\r\n    let f1 = 0.0;\r\n\r\n    if (denom !== 0.0)\r\n    {\r\n        f1 = b2ClampFloat((d12 * rd2 - rd1 * dd2) / denom, 0.0, 1.0);\r\n    }\r\n    let f2 = (d12 * f1 + rd2) / dd2;\r\n\r\n    if (f2 < 0.0)\r\n    {\r\n        f2 = 0.0;\r\n        f1 = b2ClampFloat(-rd1 / dd1, 0.0, 1.0);\r\n    }\r\n    else if (f2 > 1.0)\r\n    {\r\n        f2 = 1.0;\r\n        f1 = b2ClampFloat((d12 - rd1) / dd1, 0.0, 1.0);\r\n    }\r\n\r\n    // let closest1 = b2MulAdd(p1, f1, d1);\r\n    const closest1 = { x: p1.x + f1 * d1X, y: p1.y + f1 * d1Y };\r\n\r\n    // let closest2 = b2MulAdd(p2, f2, d2);\r\n    const closest2 = { x: p2.x + f2 * d2X, y: p2.y + f2 * d2Y };\r\n    const distanceSquared = b2DistanceSquared(closest1, closest2);\r\n    const radiusA = capsuleA.radius;\r\n    const radiusB = capsuleB.radius;\r\n    const radius = radiusA + radiusB;\r\n    const maxDistance = radius + b2_speculativeDistance;\r\n\r\n    if (distanceSquared > maxDistance * maxDistance)\r\n    {\r\n        resetProperties(manifold);\r\n\r\n        return;\r\n    }\r\n    const distance = Math.sqrt(distanceSquared);\r\n    const length1 = b2LengthXY(d1X, d1Y);\r\n    const u1X = d1X * 1.0 / length1;\r\n    const u1Y = d1Y * 1.0 / length1;\r\n    const length2 = b2LengthXY(d2X, d2Y);\r\n    const u2X = d2X * 1.0 / length2;\r\n    const u2Y = d2Y * 1.0 / length2;\r\n\r\n    // let fp2 = b2Dot({ x: p2.x - p1.x, y: p2.y - p1.y }, u1n);\r\n    const fp2 = (p2.x - p1.x) * u1X + (p2.y - p1.y) * u1Y;\r\n    const fq2 = (q2.x - p1.x) * u1X + (q2.y - p1.y) * u1Y;\r\n    const outsideA = (fp2 <= 0.0 && fq2 <= 0.0) || (fp2 >= length1 && fq2 >= length1);\r\n\r\n    // let fp1 = b2Dot({ x: p1.x - p2.x, y: p1.y - p2.y }, u2n);\r\n    // let fq1 = b2Dot({ x: q1.x - p2.x, y: q1.y - p2.y }, u2n);\r\n    const fp1 = (p1.x - p2.x) * u1X + (p1.y - p2.y) * u2Y;\r\n    const fq1 = (q1.x - p2.x) * u1X + (q1.y - p2.y) * u2Y;\r\n    const outsideB = (fp1 <= 0.0 && fq1 <= 0.0) || (fp1 >= length2 && fq1 >= length2);\r\n\r\n    manifold.pointCount = 0;\r\n    \r\n    if (outsideA === false && outsideB === false)\r\n    {\r\n        let normalAX, normalAY, separationA;\r\n\r\n        {\r\n            // normal = b2LeftPerp(u1n);\r\n            normalAX = -u1Y;\r\n            normalAY = u1X;\r\n\r\n            // let ss1 = b2Dot({ x: p2.x - p1.x, y: p2.y - p1.y }, normalA);\r\n            // let ss2 = b2Dot({ x: q2.x - p1.x, y: q2.y - p1.y }, normalA);\r\n            const ss1 = (p2.x - p1.x) * normalAX + (p2.y - p1.y) * normalAY;\r\n            const ss2 = (q2.x - p1.x) * normalAX + (q2.y - p1.y) * normalAY;\r\n            const s1p = Math.min(ss1, ss2);\r\n            const s1n = Math.max(-ss1, -ss2);\r\n\r\n            if (s1p > s1n)\r\n            {\r\n                separationA = s1p;\r\n            }\r\n            else\r\n            {\r\n                separationA = s1n;\r\n\r\n                // normalA = { x: -normalA.x, y: -normalA.y };\r\n                normalAX = -normalAX;\r\n                normalAY = -normalAY;\r\n            }\r\n        }\r\n        let normalBX, normalBY, separationB;\r\n\r\n        {\r\n            // normalB = b2LeftPerp(u2n);\r\n            normalBX = -u2Y;\r\n            normalBY = u2X;\r\n\r\n            // let ss1 = b2Dot({ x: p1.x - p2.x, y: p1.y - p2.y }, normalB);\r\n            // let ss2 = b2Dot({ x: q1.x - p2.x, y: q1.y - p2.y }, normalB);\r\n            const ss1 = (p1.x - p2.x) * normalBX + (p1.y - p2.y) * normalBY;\r\n            const ss2 = (q1.x - p2.x) * normalBX + (q1.y - p2.y) * normalBY;\r\n            const s1p = Math.min(ss1, ss2);\r\n            const s1n = Math.max(-ss1, -ss2);\r\n\r\n            if (s1p > s1n)\r\n            {\r\n                separationB = s1p;\r\n            }\r\n            else\r\n            {\r\n                separationB = s1n;\r\n\r\n                // normalB = { x: -normalB.x, y: -normalB.y };\r\n                normalBX = -normalBX;\r\n                normalBY = -normalBY;\r\n            }\r\n        }\r\n\r\n        if (separationA >= separationB)\r\n        {\r\n            manifold.normalX = normalAX;\r\n            manifold.normalY = normalAY;\r\n            let cpX = p2.x;\r\n            let cpY = p2.y;\r\n            let cqX = q2.x;\r\n            let cqY = q2.y;\r\n\r\n            if (fp2 < 0.0 && fq2 > 0.0)\r\n            {\r\n                const t = (0.0 - fp2) / (fq2 - fp2);\r\n                cpX = p2.x + t * (q2.x - p2.x);\r\n                cpY = p2.y + t * (q2.y - p2.y);\r\n            }\r\n            else if (fq2 < 0.0 && fp2 > 0.0)\r\n            {\r\n                const t = (0.0 - fq2) / (fp2 - fq2);\r\n                cqX = q2.x + t * (p2.x - q2.x);\r\n                cqY = q2.y + t * (p2.y - q2.y);\r\n            }\r\n\r\n            if (fp2 > length1 && fq2 < length1)\r\n            {\r\n                const t = (fp2 - length1) / (fp2 - fq2);\r\n                cpX = p2.x + t * (q2.x - p2.x);\r\n                cpY = p2.y + t * (q2.y - p2.y);\r\n            }\r\n            else if (fq2 > length1 && fp2 < length1)\r\n            {\r\n                const t = (fq2 - length1) / (fq2 - fp2);\r\n                cqX = q2.x + t * (p2.x - q2.x);\r\n                cqY = q2.y + t * (p2.y - q2.y);\r\n            }\r\n\r\n            // let sp = b2Dot({ x: cpX - p1.x, y: cpY - p1.y }, { x: normalAX, y: normalAY });\r\n            // let sq = b2Dot({ x: cqX - p1.x, y: cqY - p1.y }, { x: normalAX, y: normalAY });\r\n            const sp = (cpX - p1.x) * normalAX + (cpY - p1.y) * normalAY;\r\n            const sq = (cqX - p1.x) * normalAX + (cqY - p1.y) * normalAY;\r\n\r\n            if (sp <= distance + b2_linearSlop || sq <= distance + b2_linearSlop)\r\n            {\r\n                let s = 0.5 * (radiusA - radiusB - sp);\r\n                manifold.points[0].anchorAX = cpX + s * normalAX;\r\n                manifold.points[0].anchorAY = cpY + s * normalAY;\r\n                manifold.points[0].separation = sp - radius;\r\n                manifold.points[0].id = B2_MAKE_ID(0, 0);\r\n                s = 0.5 * (radiusA - radiusB - sq);\r\n                manifold.points[1].anchorAX = cqX + s * normalAX;\r\n                manifold.points[1].anchorAY = cqY + s * normalAY;\r\n                manifold.points[1].separation = sq - radius;\r\n                manifold.points[1].id = B2_MAKE_ID(0, 1);\r\n                manifold.pointCount = 2;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            manifold.normalX = -normalBX;\r\n            manifold.normalY = -normalBY;\r\n            let cpX = p1.x;\r\n            let cpY = p1.y;\r\n            let cqX = q1.x;\r\n            let cqY = q1.y;\r\n\r\n            if (fp1 < 0.0 && fq1 > 0.0)\r\n            {\r\n                const t = (0.0 - fp1) / (fq1 - fp1);\r\n                cpX = p1.x + t * (q1.x - p1.x);\r\n                cpY = p1.y + t * (q1.y - p1.y);\r\n            }\r\n            else if (fq1 < 0.0 && fp1 > 0.0)\r\n            {\r\n                const t = (0.0 - fq1) / (fp1 - fq1);\r\n                cqX = q1.x + t * (p1.x - q1.x);\r\n                cqY = q1.y + t * (p1.y - q1.y);\r\n            }\r\n\r\n            if (fp1 > length2 && fq1 < length2)\r\n            {\r\n                const t = (fp1 - length2) / (fp1 - fq1);\r\n                cpX = p1.x + t * (q1.x - p1.x);\r\n                cpY = p1.y + t * (q1.y - p1.y);\r\n            }\r\n            else if (fq1 > length2 && fp1 < length2)\r\n            {\r\n                const t = (fq1 - length2) / (fq1 - fp1);\r\n                cqX = q1.x + t * (p1.x - q1.x);\r\n                cqY = q1.y + t * (p1.y - q1.y);\r\n            }\r\n            const sp = (cpX - p2.x) * normalBX + (cpY - p2.y) * normalBY;\r\n            const sq = (cqX - p2.x) * normalBX + (cqY - p2.y) * normalBY;\r\n\r\n            if (sp <= distance + b2_linearSlop || sq <= distance + b2_linearSlop)\r\n            {\r\n                let s = 0.5 * (radiusB - radiusA - sp);\r\n                manifold.points[0].anchorAX = cpX + s * normalBX;\r\n                manifold.points[0].anchorAY = cpY + s * normalBY;\r\n                manifold.points[0].separation = sp - radius;\r\n                manifold.points[0].id = B2_MAKE_ID(0, 0);\r\n                \r\n                s = 0.5 * (radiusB - radiusA - sq);\r\n                manifold.points[1].anchorAX = cqX + s * normalBX;\r\n                manifold.points[1].anchorAY = cqY + s * normalBY;\r\n                manifold.points[1].separation = sq - radius;\r\n                manifold.points[1].id = B2_MAKE_ID(1, 0);\r\n                manifold.pointCount = 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (manifold.pointCount === 0)\r\n    {\r\n        let normalX = closest2.x - closest1.x;\r\n        let normalY = closest2.y - closest1.y;\r\n        const lengthSq = normalX * normalX + normalY * normalY;\r\n\r\n        if (lengthSq > epsSqr)\r\n        {\r\n            const length = Math.sqrt(lengthSq);\r\n            normalX /= length;\r\n            normalY /= length;\r\n        }\r\n        else\r\n        {\r\n            // const leftPerp = b2LeftPerp(u1);\r\n            normalX = -u1Y; // leftPerp.x;\r\n            normalY = u1X;  // leftPerp.y;\r\n        }\r\n        const c1X = closest1.x + radiusA * normalX;\r\n        const c1Y = closest1.y + radiusA * normalY;\r\n        const c2X = closest2.x - radiusB * normalX;\r\n        const c2Y = closest2.y - radiusB * normalY;\r\n        const i1 = f1 === 0.0 ? 0 : 1;\r\n        const i2 = f2 === 0.0 ? 0 : 1;\r\n        manifold.normalX = normalX;\r\n        manifold.normalY = normalY;\r\n        manifold.points[0].anchorAX = (c1X + c2X) * 0.5;\r\n        manifold.points[0].anchorAY = (c1Y + c2Y) * 0.5;\r\n        manifold.points[0].separation = Math.sqrt(distanceSquared) - radius;\r\n        manifold.points[0].id = B2_MAKE_ID(i1, i2);\r\n        manifold.pointCount = 1;\r\n    }\r\n\r\n    if (manifold.pointCount > 0)\r\n    {\r\n        const rotatedNormalX = xfA.q.c * manifold.normalX - xfA.q.s * manifold.normalY;\r\n        const rotatedNormalY = xfA.q.s * manifold.normalX + xfA.q.c * manifold.normalY;\r\n        manifold.normalX = rotatedNormalX;\r\n        manifold.normalY = rotatedNormalY;\r\n\r\n        for (let i = 0; i < manifold.pointCount; ++i)\r\n        {\r\n            const mp = manifold.points[i];\r\n            const vx = mp.anchorAX + origin.x;\r\n            const vy = mp.anchorAY + origin.y;\r\n            const rotatedVecX = xfA.q.c * vx - xfA.q.s * vy;\r\n            const rotatedVecY = xfA.q.s * vx + xfA.q.c * vy;\r\n            mp.anchorAX = rotatedVecX;\r\n            mp.anchorAY = rotatedVecY;\r\n            mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n            mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n            mp.pointX = xfA.p.x + mp.anchorAX;\r\n            mp.pointY = xfA.p.y + mp.anchorAY;\r\n        }\r\n    }\r\n\r\n    return;\r\n}\r\n\r\nconst constCapsule = new b2Capsule();\r\n\r\n/**\r\n * @function b2CollideSegmentAndCapsule\r\n * @summary Computes collision between a line segment and a capsule.\r\n * @param {b2Segment} segmentA - A line segment defined by two points (point1, point2)\r\n * @param {b2Transform} xfA - Transform for segmentA containing position and rotation\r\n * @param {b2Capsule} capsuleB - A capsule shape defined by two points and a radius\r\n * @param {b2Transform} xfB - Transform for capsuleB containing position and rotation\r\n * @param {b2Manifold} manifold - Output collision manifold\r\n * @returns {void} Modifies the manifold parameter with collision data:\r\n * - normalX/Y: Collision normal vector\r\n * - pointCount: Number of contact points (0-2)\r\n * - points[]: Contact point data including:\r\n * - anchorA/B: Contact points in local coordinates\r\n * - separation: Penetration depth\r\n * - id: Contact ID\r\n * @description\r\n * Converts the segment to a zero-radius capsule and delegates to b2CollideCapsules\r\n * for the actual collision computation.\r\n */\r\nexport function b2CollideSegmentAndCapsule(segmentA, xfA, capsuleB, xfB, manifold)\r\n{\r\n    constCapsule.center1 = segmentA.point1;\r\n    constCapsule.center2 = segmentA.point2;\r\n    constCapsule.radius = 0;\r\n\r\n    return b2CollideCapsules(constCapsule, xfA, capsuleB, xfB, manifold);\r\n}\r\n\r\n/**\r\n * @function b2CollidePolygonAndCapsule\r\n * @description\r\n * Computes collision manifold between a polygon and a capsule by converting the capsule\r\n * to a polygon and using polygon-polygon collision detection.\r\n * @param {b2Polygon} polygonA - The first collision shape (polygon)\r\n * @param {b2Transform} xfA - Transform for polygon A, containing position and rotation\r\n * @param {b2Capsule} capsuleB - The second collision shape (capsule) defined by two centers and a radius\r\n * @param {b2Transform} xfB - Transform for capsule B, containing position and rotation\r\n * @param {b2Manifold} manifold - The output collision manifold to be populated\r\n * @returns {b2Manifold} The collision manifold containing contact points and normal\r\n */\r\nexport function b2CollidePolygonAndCapsule(polygonA, xfA, capsuleB, xfB, manifold)\r\n{\r\n    const polyB = b2MakeCapsule(capsuleB.center1, capsuleB.center2, capsuleB.radius);\r\n\r\n    return b2CollidePolygons(polygonA, xfA, polyB, xfB, manifold);\r\n}\r\n\r\n// Polygon clipper used to compute contact points when there are potentially two contact points.\r\nfunction b2ClipPolygons(polyA, polyB, edgeA, edgeB, flip, manifold)\r\n{\r\n    // reference polygon\r\n    let poly1, i11, i12;\r\n\r\n    // incident polygon\r\n    let poly2, i21, i22;\r\n\r\n    if (flip)\r\n    {\r\n        poly1 = polyB;\r\n        poly2 = polyA;\r\n        i11 = edgeB;\r\n        i12 = edgeB + 1 < polyB.count ? edgeB + 1 : 0;\r\n        i21 = edgeA;\r\n        i22 = edgeA + 1 < polyA.count ? edgeA + 1 : 0;\r\n    }\r\n    else\r\n    {\r\n        poly1 = polyA;\r\n        poly2 = polyB;\r\n        i11 = edgeA;\r\n        i12 = edgeA + 1 < polyA.count ? edgeA + 1 : 0;\r\n        i21 = edgeB;\r\n        i22 = edgeB + 1 < polyB.count ? edgeB + 1 : 0;\r\n    }\r\n\r\n    const normal = poly1.normals[i11];\r\n\r\n    // Reference edge vertices\r\n    const v11 = poly1.vertices[i11];\r\n    const v12 = poly1.vertices[i12];\r\n\r\n    // Incident edge vertices\r\n    const v21 = poly2.vertices[i21];\r\n    const v22 = poly2.vertices[i22];\r\n\r\n    // const tangent = b2CrossSV(1.0, normal);\r\n    const tangentX = -1.0 * normal.y;\r\n    const tangentY = 1.0 * normal.x;\r\n\r\n    const lower1 = 0.0;\r\n\r\n    // const upper1 = b2Dot(b2Sub(v12, v11), tangent);\r\n    let subX = v12.x - v11.x;\r\n    let subY = v12.y - v11.y;\r\n    const upper1 = subX * tangentX + subY * tangentY;\r\n\r\n    // Incident edge points opposite of tangent due to CCW winding\r\n    // const upper2 = b2Dot(b2Sub(v21, v11), tangent);\r\n    subX = v21.x - v11.x;\r\n    subY = v21.y - v11.y;\r\n    const upper2 = subX * tangentX + subY * tangentY;\r\n\r\n    // const lower2 = b2Dot(b2Sub(v22, v11), tangent);\r\n    subX = v22.x - v11.x;\r\n    subY = v22.y - v11.y;\r\n    const lower2 = subX * tangentX + subY * tangentY;\r\n\r\n    let vLower;\r\n\r\n    if (lower2 < lower1 && upper2 - lower2 > eps)\r\n    {\r\n        vLower = b2Lerp(v22, v21, (lower1 - lower2) / (upper2 - lower2));\r\n    }\r\n    else\r\n    {\r\n        vLower = v22;\r\n    }\r\n\r\n    let vUpper;\r\n\r\n    if (upper2 > upper1 && upper2 - lower2 > eps)\r\n    {\r\n        vUpper = b2Lerp(v22, v21, (upper1 - lower2) / (upper2 - lower2));\r\n    }\r\n    else\r\n    {\r\n        vUpper = v21;\r\n    }\r\n\r\n    // const separationLower = b2Dot(b2Sub(vLower, v11), normal);\r\n    // const separationUpper = b2Dot(b2Sub(vUpper, v11), normal);\r\n    const separationLower = b2DotSub(vLower, v11, normal);\r\n    const separationUpper = b2DotSub(vUpper, v11, normal);\r\n\r\n    const r1 = poly1.radius;\r\n    const r2 = poly2.radius;\r\n\r\n    // Put contact points at midpoint, accounting for radii\r\n    // vLower = b2MulAdd(vLower, 0.5 * (r1 - r2 - separationLower), normal);\r\n    // vUpper = b2MulAdd(vUpper, 0.5 * (r1 - r2 - separationUpper), normal);\r\n    b2MulAddOut(vLower, 0.5 * (r1 - r2 - separationLower), normal, p1);\r\n    b2MulAddOut(vUpper, 0.5 * (r1 - r2 - separationUpper), normal, p2);\r\n\r\n    const radius = r1 + r2;\r\n\r\n    if (flip === false)\r\n    {\r\n        manifold.normalX = normal.x;\r\n        manifold.normalY = normal.y;\r\n        let mp = manifold.points[0];\r\n        mp.anchorAX = p1.x;\r\n        mp.anchorAY = p1.y;\r\n        mp.separation = separationLower - radius;\r\n        mp.id = B2_MAKE_ID(i11, i22);\r\n\r\n        mp = manifold.points[1];\r\n        mp.anchorAX = p2.x;\r\n        mp.anchorAY = p2.y;\r\n        mp.separation = separationUpper - radius;\r\n        mp.id = B2_MAKE_ID(i12, i21);\r\n        manifold.pointCount = 2;\r\n    }\r\n    else\r\n    {\r\n        // manifold.normal = b2Neg(normal);\r\n        manifold.normalX = -normal.x;\r\n        manifold.normalY = -normal.y;\r\n        let mp = manifold.points[0];\r\n        mp.anchorAX = p2.x;\r\n        mp.anchorAY = p2.y;\r\n        mp.separation = separationUpper - radius;\r\n        mp.id = B2_MAKE_ID(i21, i12);\r\n\r\n        mp = manifold.points[1];\r\n        mp.anchorAX = p1.x;\r\n        mp.anchorAY = p1.y;\r\n        mp.separation = separationLower - radius;\r\n        mp.id = B2_MAKE_ID(i22, i11);\r\n        manifold.pointCount = 2;\r\n    }\r\n\r\n    return manifold;\r\n}\r\n\r\n// Find the max separation between poly1 and poly2 using edge normals from poly1.\r\nfunction b2FindMaxSeparation(poly1, poly2)\r\n{\r\n    const count1 = poly1.count;\r\n    const count2 = poly2.count;\r\n    const n1s = poly1.normals;\r\n    const v1s = poly1.vertices;\r\n    const v2s = poly2.vertices;\r\n\r\n    let bestIndex = 0;\r\n    let maxSeparation = Number.NEGATIVE_INFINITY;\r\n\r\n    for (let i = 0; i < count1; ++i)\r\n    {\r\n        // Get poly1 normal in frame2.\r\n        const n = n1s[i];\r\n        const vx = v1s[i].x,\r\n            vy = v1s[i].y;\r\n\r\n        // Find the deepest point for normal i.\r\n        let si = Number.POSITIVE_INFINITY;\r\n\r\n        for (let j = 0; j < count2; ++j)\r\n        {\r\n            const dx = v2s[j].x - vx;\r\n            const dy = v2s[j].y - vy;\r\n            const sij = n.x * dx + n.y * dy;\r\n\r\n            // const sij = b2Dot(n, b2Sub(v2s[j], v1));\r\n            if (sij < si)\r\n            {\r\n                si = sij;\r\n            }\r\n        }\r\n\r\n        if (si > maxSeparation)\r\n        {\r\n            maxSeparation = si;\r\n            bestIndex = i;\r\n        }\r\n    }\r\n\r\n    return { edgeIndex: bestIndex, maxSeparation: maxSeparation };  // PJB = the C version returns float maxSeparation here and bestIndex through *edgeIndex parameter\r\n}\r\n\r\n// Due to speculation, every polygon is rounded\r\n// Algorithm:\r\n//\r\n// compute edge separation using the separating axis test (SAT)\r\n// if (separation > speculation_distance)\r\n//   return\r\n// find reference and incident edge\r\n// if separation >= 0.1f * b2_linearSlop\r\n//   compute closest points between reference and incident edge\r\n//   if vertices are closest\r\n//      single vertex-vertex contact\r\n//   else\r\n//      clip edges\r\n//   end\r\n// else\r\n//   clip edges\r\n// end\r\n\r\nconst localPolyA = new b2Polygon(B2_MAX_POLYGON_VERTICES);\r\nconst localPolyB = new b2Polygon(B2_MAX_POLYGON_VERTICES);\r\nconst p = new b2Vec2();\r\nconst sfA = new b2Transform();\r\n\r\n/**\r\n * @function b2CollidePolygons\r\n * @description\r\n * Computes collision manifold between two polygons using their transforms.\r\n * @param {b2Polygon} polygonA - First polygon\r\n * @param {b2Transform} xfA - Transform for first polygon containing position (p) and rotation (q)\r\n * @param {b2Polygon} polygonB - Second polygon\r\n * @param {b2Transform} xfB - Transform for second polygon containing position (p) and rotation (q)\r\n * @param {b2Manifold} manifold - Output manifold to store collision data\r\n * @returns {b2Manifold} The collision manifold containing contact points, normal and separation\r\n * @description\r\n * Detects collision between two polygons and generates contact information.\r\n * Transforms the polygons into a common frame, finds the separating axes,\r\n * and generates contact points. The manifold includes contact points with\r\n * anchor positions, separation distance, contact IDs and collision normal.\r\n */\r\nexport function b2CollidePolygons(polygonA, xfA, polygonB, xfB, manifold)\r\n{\r\n    const originX = polygonA.vertices[0].x;\r\n    const originY = polygonA.vertices[0].y;\r\n\r\n    p.x = xfA.p.x + (xfA.q.c * originX - xfA.q.s * originY);\r\n    p.y = xfA.p.y + (xfA.q.s * originX + xfA.q.c * originY);\r\n    sfA.p = p;\r\n    sfA.q = xfA.q;\r\n    b2InvMulTransformsOut(sfA, xfB, xf);\r\n\r\n    // Shift polyA to origin, retain rotation\r\n    localPolyA.centroid = null;\r\n    \r\n    localPolyA.count = polygonA.count;\r\n    localPolyA.radius = polygonA.radius;\r\n    localPolyA.vertices[0].x = 0;\r\n    localPolyA.vertices[0].y = 0;\r\n    localPolyA.normals[0].x = polygonA.normals[0].x;\r\n    localPolyA.normals[0].y = polygonA.normals[0].y;\r\n\r\n    for (let i = 1; i < localPolyA.count; ++i)\r\n    {\r\n        const v = localPolyA.vertices[i];\r\n        v.x = polygonA.vertices[i].x - originX;\r\n        v.y = polygonA.vertices[i].y - originY;\r\n        const n = localPolyA.normals[i];\r\n        n.x = polygonA.normals[i].x;\r\n        n.y = polygonA.normals[i].y;\r\n    }\r\n\r\n    // Put polyB in polyA's frame to reduce round-off error\r\n    localPolyA.centroid = null;\r\n\r\n    localPolyB.count = polygonB.count;\r\n    localPolyB.radius = polygonB.radius;\r\n\r\n    for (let i = 0; i < localPolyB.count; ++i)\r\n    {\r\n        const v = localPolyB.vertices[i];\r\n        const p = polygonB.vertices[i];\r\n        v.x = (xf.q.c * p.x - xf.q.s * p.y) + xf.p.x;\r\n        v.y = (xf.q.s * p.x + xf.q.c * p.y) + xf.p.y;\r\n        const n = localPolyB.normals[i];\r\n        n.x = xf.q.c * polygonB.normals[i].x - xf.q.s * polygonB.normals[i].y;\r\n        n.y = xf.q.s * polygonB.normals[i].x + xf.q.c * polygonB.normals[i].y;\r\n    }\r\n\r\n    const ret1 = b2FindMaxSeparation(localPolyA, localPolyB);\r\n    let edgeA = ret1.edgeIndex;\r\n    const separationA = ret1.maxSeparation;\r\n\r\n    const ret2 = b2FindMaxSeparation(localPolyB, localPolyA);\r\n    let edgeB = ret2.edgeIndex;\r\n    const separationB = ret2.maxSeparation;\r\n\r\n    const radius = localPolyA.radius + localPolyB.radius;\r\n\r\n    if (separationA > b2_speculativeDistance + radius || separationB > b2_speculativeDistance + radius)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    // Find incident edge\r\n    let flip;\r\n\r\n    if (separationA >= separationB)\r\n    {\r\n        flip = false;\r\n\r\n        const searchDirection = localPolyA.normals[edgeA];\r\n\r\n        // Find the incident edge on polyB\r\n        const count = localPolyB.count;\r\n        const normals = localPolyB.normals;\r\n        edgeB = 0;\r\n        let minDot = Number.MAX_VALUE;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const dot = searchDirection.x * normals[i].x + searchDirection.y * normals[i].y;\r\n\r\n            if (dot < minDot)\r\n            {\r\n                minDot = dot;\r\n                edgeB = i;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        flip = true;\r\n\r\n        const searchDirection = localPolyB.normals[edgeB];\r\n\r\n        // Find the incident edge on polyA\r\n        const count = localPolyA.count;\r\n        const normals = localPolyA.normals;\r\n        edgeA = 0;\r\n        let minDot = Number.MAX_VALUE;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const dot = searchDirection.x * normals[i].x + searchDirection.y * normals[i].y;\r\n\r\n            if (dot < minDot)\r\n            {\r\n                minDot = dot;\r\n                edgeA = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // let manifold = new b2Manifold();\r\n\r\n    // Using slop here to ensure vertex-vertex normal vectors can be safely normalized\r\n    // todo this means edge clipping needs to handle slightly non-overlapping edges.\r\n    if (separationA > 0.1 * b2_linearSlop || separationB > 0.1 * b2_linearSlop)\r\n    {\r\n        // Polygons are disjoint. Find closest points between reference edge and incident edge\r\n        // Reference edge on polygon A\r\n        const i11 = edgeA;\r\n        const i12 = edgeA + 1 < localPolyA.count ? edgeA + 1 : 0;\r\n        const i21 = edgeB;\r\n        const i22 = edgeB + 1 < localPolyB.count ? edgeB + 1 : 0;\r\n\r\n        const v11 = localPolyA.vertices[i11];\r\n        const v12 = localPolyA.vertices[i12];\r\n        const v21 = localPolyB.vertices[i21];\r\n        const v22 = localPolyB.vertices[i22];\r\n\r\n        const result = b2SegmentDistance(v11.x, v11.y, v12.x, v12.y, v21.x, v21.y, v22.x, v22.y);\r\n\r\n        // return {\r\n        //     fraction1,\r\n        //     fraction2,\r\n        //     distanceSquared\r\n        // };\r\n\r\n        if (result.fraction1 === 0.0 && result.fraction2 === 0.0)\r\n        {\r\n            // v11 - v21\r\n            let normalX = v21.x - v11.x;\r\n            let normalY = v21.y - v11.y;\r\n            console.assert(result.distanceSquared > 0.0);\r\n            const distance = Math.sqrt(result.distanceSquared);\r\n\r\n            if (distance > b2_speculativeDistance + radius)\r\n            {\r\n                return manifold.clear();\r\n            }\r\n            const invDistance = 1.0 / distance;\r\n            normalX *= invDistance;\r\n            normalY *= invDistance;\r\n\r\n            const c1X = v11.x + localPolyA.radius * normalX;\r\n            const c1Y = v11.y + localPolyA.radius * normalY;\r\n            const c2X = v21.x - localPolyB.radius * normalX;\r\n            const c2Y = v21.y - localPolyB.radius * normalY;\r\n\r\n            // manifold.normal = new b2Vec2(normalX, normalY);\r\n            manifold.normalX = normalX;\r\n            manifold.normalY = normalY;\r\n            const mp = manifold.points[0];\r\n            mp.anchorAX = (c1X + c2X) * 0.5;\r\n            mp.anchorAY = (c1Y + c2Y) * 0.5;\r\n            mp.separation = distance - radius;\r\n            mp.id = B2_MAKE_ID(i11, i21);\r\n            manifold.pointCount = 1;\r\n        }\r\n        else if (result.fraction1 === 0.0 && result.fraction2 === 1.0)\r\n        {\r\n            // v11 - v22\r\n            let normalX = v22.x - v11.x;\r\n            let normalY = v22.y - v11.y;\r\n            console.assert(result.distanceSquared > 0.0);\r\n            const distance = Math.sqrt(result.distanceSquared);\r\n\r\n            if (distance > b2_speculativeDistance + radius)\r\n            {\r\n                return manifold.clear();\r\n            }\r\n            const invDistance = 1.0 / distance;\r\n            normalX *= invDistance;\r\n            normalY *= invDistance;\r\n\r\n            const c1X = v11.x + localPolyA.radius * normalX;\r\n            const c1Y = v11.y + localPolyA.radius * normalY;\r\n            const c2X = v22.x - localPolyB.radius * normalX;\r\n            const c2Y = v22.y - localPolyB.radius * normalY;\r\n\r\n            manifold.normalX = normalX;\r\n            manifold.normalY = normalY;\r\n            const mp = new b2ManifoldPoint();\r\n            mp.anchorAX = (c1X + c2X) * 0.5;\r\n            mp.anchorAY = (c1Y + c2Y) * 0.5;\r\n            mp.separation = distance - radius;\r\n            mp.id = B2_MAKE_ID(i11, i22);\r\n            manifold.points[0] = mp;\r\n            manifold.pointCount = 1;\r\n        }\r\n        else if (result.fraction1 === 1.0 && result.fraction2 === 0.0)\r\n        {\r\n            // v12 - v21\r\n            let normalX = v21.x - v12.x;\r\n            let normalY = v21.y - v12.y;\r\n            console.assert(result.distanceSquared > 0.0);\r\n            const distance = Math.sqrt(result.distanceSquared);\r\n\r\n            if (distance > b2_speculativeDistance + radius)\r\n            {\r\n                return manifold.clear();\r\n            }\r\n            const invDistance = 1.0 / distance;\r\n            normalX *= invDistance;\r\n            normalY *= invDistance;\r\n\r\n            const c1X = v12.x + localPolyA.radius * normalX;\r\n            const c1Y = v12.y + localPolyA.radius * normalY;\r\n            const c2X = v21.x - localPolyB.radius * normalX;\r\n            const c2Y = v21.y - localPolyB.radius * normalY;\r\n\r\n            manifold.normalX = normalX;\r\n            manifold.normalY = normalY;\r\n            const mp = new b2ManifoldPoint();\r\n            mp.anchorAX = (c1X + c2X) * 0.5;\r\n            mp.anchorAY = (c1Y + c2Y) * 0.5;\r\n            mp.separation = distance - radius;\r\n            mp.id = B2_MAKE_ID(i12, i21);\r\n            manifold.points[0] = mp;\r\n            manifold.pointCount = 1;\r\n        }\r\n        else if (result.fraction1 === 1.0 && result.fraction2 === 1.0)\r\n        {\r\n            // v12 - v22\r\n            let normalX = v22.x - v12.x;\r\n            let normalY = v22.y - v12.y;\r\n            console.assert(result.distanceSquared > 0.0);\r\n            const distance = Math.sqrt(result.distanceSquared);\r\n\r\n            if (distance > b2_speculativeDistance + radius)\r\n            {\r\n                return manifold.clear();\r\n            }\r\n            const invDistance = 1.0 / distance;\r\n            normalX *= invDistance;\r\n            normalY *= invDistance;\r\n\r\n            const c1X = v12.x + localPolyA.radius * normalX;\r\n            const c1Y = v12.y + localPolyA.radius * normalY;\r\n            const c2X = v22.x - localPolyB.radius * normalX;\r\n            const c2Y = v22.y - localPolyB.radius * normalY;\r\n\r\n            manifold.normalX = normalX;\r\n            manifold.normalY = normalY;\r\n            const mp = new b2ManifoldPoint();\r\n            mp.anchorAX = (c1X + c2X) * 0.5;\r\n            mp.anchorAY = (c1Y + c2Y) * 0.5;\r\n            mp.separation = distance - radius;\r\n            mp.id = B2_MAKE_ID(i12, i22);\r\n            manifold.points[0] = mp;\r\n            manifold.pointCount = 1;\r\n        }\r\n        else\r\n        {\r\n            // Edge region\r\n            b2ClipPolygons(localPolyA, localPolyB, edgeA, edgeB, flip, manifold);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Polygons overlap\r\n        b2ClipPolygons(localPolyA, localPolyB, edgeA, edgeB, flip, manifold);\r\n    }\r\n\r\n    // Convert manifold to world space\r\n    if (manifold.pointCount > 0)\r\n    {\r\n        const tmpx = manifold.normalX;\r\n        manifold.normalX = xfA.q.c * manifold.normalX - xfA.q.s * manifold.normalY;\r\n        manifold.normalY = xfA.q.s * tmpx + xfA.q.c * manifold.normalY;\r\n\r\n        for (let i = 0; i < manifold.pointCount; ++i)\r\n        {\r\n            const mp = manifold.points[i];\r\n\r\n            const addX = mp.anchorAX + originX;\r\n            const addY = mp.anchorAY + originY;\r\n            mp.anchorAX = xfA.q.c * addX - xfA.q.s * addY;\r\n            mp.anchorAY = xfA.q.s * addX + xfA.q.c * addY;\r\n            mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n            mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n            mp.pointX = xfA.p.x + mp.anchorAX;\r\n            mp.pointY = xfA.p.y + mp.anchorAY;\r\n        }\r\n    }\r\n\r\n    return manifold;\r\n}\r\n\r\n/**\r\n * @function b2CollideSegmentAndCircle\r\n * @description\r\n * Computes collision detection between a line segment and a circle by converting\r\n * the segment to a zero-radius capsule and using capsule-circle collision.\r\n * @param {b2Segment} segmentA - The line segment shape\r\n * @param {b2Transform} xfA - Transform for segmentA\r\n * @param {b2Circle} circleB - The circle shape\r\n * @param {b2Transform} xfB - Transform for circleB\r\n * @param {b2Manifold} manifold - The collision manifold to populate\r\n * @returns {b2Manifold} The collision manifold containing contact information\r\n */\r\nexport function b2CollideSegmentAndCircle(segmentA, xfA, circleB, xfB, manifold)\r\n{\r\n    const capsuleA = new b2Capsule();\r\n    capsuleA.center1 = segmentA.point1;\r\n    capsuleA.center2 = segmentA.point2;\r\n    capsuleA.radius = 0.0;\r\n\r\n    return b2CollideCapsuleAndCircle(capsuleA, xfA, circleB, xfB, manifold);\r\n}\r\n\r\n/**\r\n * @function b2CollideSegmentAndPolygon\r\n * @description\r\n * Computes collision manifold between a line segment and a polygon by converting\r\n * the segment into a zero-width capsule and using polygon collision detection.\r\n * @param {b2Segment} segmentA - The line segment\r\n * @param {b2Transform} xfA - Transform for segmentA\r\n * @param {b2Polygon} polygonB - The polygon to test collision against\r\n * @param {b2Transform} xfB - Transform for polygonB\r\n * @param {b2Manifold} manifold - The manifold to populate with collision data\r\n * @returns {b2Manifold} Collision manifold containing contact points and normal\r\n */\r\nexport function b2CollideSegmentAndPolygon(segmentA, xfA, polygonB, xfB, manifold)\r\n{\r\n    const polygonA = b2MakeCapsule(segmentA.point1, segmentA.point2, 0.0);\r\n\r\n    return b2CollidePolygons(polygonA, xfA, polygonB, xfB, manifold);\r\n}\r\n\r\n// Assuming similar structures exist for b2Manifold, b2Transform, b2ChainSegment, b2Circle, etc.\r\n/**\r\n * @function b2CollideChainSegmentAndCircle\r\n * @description\r\n * Computes collision detection between a chain segment and a circle.\r\n * @param {Object} chainSegmentA - A chain segment with properties segment (containing point1 and point2) and ghost points (ghost1, ghost2)\r\n * @param {Object} xfA - Transform for chain segment containing position (p) and rotation (q)\r\n * @param {Object} circleB - Circle object with center point and radius\r\n * @param {Object} xfB - Transform for circle containing position (p) and rotation (q)\r\n * @param {Object} manifold - Contact manifold to store collision results\r\n * @returns {Object} The manifold object containing collision data:\r\n * - normalX/Y: collision normal in world coordinates\r\n * - points: array with contact point data including:\r\n * - anchorA/B: contact points in local coordinates\r\n * - point: contact point in world coordinates\r\n * - separation: distance between shapes\r\n * - id: contact ID\r\n * - pointCount: number of contact points\r\n */\r\nexport function b2CollideChainSegmentAndCircle(chainSegmentA, xfA, circleB, xfB, manifold)\r\n{\r\n    // let manifold = new b2Manifold();\r\n\r\n    b2InvMulTransformsOut(xfA, xfB, xf);\r\n\r\n    // Compute circle in frame of segment\r\n    const pB = b2TransformPoint(xf, circleB.center);\r\n\r\n    const p1 = chainSegmentA.segment.point1;\r\n    const p2 = chainSegmentA.segment.point2;\r\n    const e = b2Sub(p2, p1);\r\n\r\n    // Normal points to the right\r\n    const offset = b2Dot(b2RightPerp(e), b2Sub(pB, p1));\r\n\r\n    if (offset < 0.0)\r\n    {\r\n        // collision is one-sided\r\n        return manifold.clear();\r\n    }\r\n\r\n    // Barycentric coordinates\r\n    const u = b2Dot(e, b2Sub(p2, pB));\r\n    const v = b2Dot(e, b2Sub(pB, p1));\r\n\r\n    let pA;\r\n\r\n    if (v <= 0.0)\r\n    {\r\n        // Behind point1?\r\n        // Is pB in the Voronoi region of the previous edge?\r\n        const prevEdge = b2Sub(p1, chainSegmentA.ghost1);\r\n        const uPrev = b2Dot(prevEdge, b2Sub(pB, p1));\r\n\r\n        if (uPrev <= 0.0)\r\n        {\r\n            return manifold.clear();\r\n        }\r\n\r\n        pA = p1;\r\n    }\r\n    else if (u <= 0.0)\r\n    {\r\n        // Ahead of point2?\r\n        const nextEdge = b2Sub(chainSegmentA.ghost2, p2);\r\n        const vNext = b2Dot(nextEdge, b2Sub(pB, p2));\r\n\r\n        // Is pB in the Voronoi region of the next edge?\r\n        if (vNext > 0.0)\r\n        {\r\n            return manifold.clear();\r\n        }\r\n\r\n        pA = p2;\r\n    }\r\n    else\r\n    {\r\n        const ee = b2Dot(e, e);\r\n        pA = new b2Vec2(u * p1.x + v * p2.x, u * p1.y + v * p2.y);\r\n        pA = ee > 0.0 ? b2MulSV(1.0 / ee, pA) : p1;\r\n    }\r\n\r\n    const res = b2GetLengthAndNormalize(b2Sub(pB, pA));\r\n    const distance = res.length;\r\n    const normal = res.normal;\r\n\r\n    const radius = circleB.radius;\r\n    const separation = distance - radius;\r\n\r\n    if (separation > b2_speculativeDistance)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    const cA = pA;\r\n    const cB = b2MulAdd(pB, -radius, normal);\r\n    const contactPointA = b2Lerp(cA, cB, 0.5);\r\n\r\n    // manifold.normal = b2RotateVector(xfA.q, normal);\r\n    manifold.normalX = xfA.q.c * normal.x - xfA.q.s * normal.y;\r\n    manifold.normalY = xfA.q.s * normal.x + xfA.q.c * normal.y;\r\n\r\n    const mp = manifold.points[0];\r\n\r\n    // mp.anchorA = b2RotateVector(xfA.q, contactPointA);\r\n    mp.anchorAX = xfA.q.c * contactPointA.x - xfA.q.s * contactPointA.y;\r\n    mp.anchorAY = xfA.q.s * contactPointA.x + xfA.q.c * contactPointA.y;\r\n\r\n    // mp.anchorB = b2Add(mp.anchorA, b2Sub(xfA.p, xfB.p));\r\n    mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n    mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n\r\n    // mp.point = b2Add(xfA.p, mp.anchorA);\r\n    mp.pointX = xfA.p.x + mp.anchorAX;\r\n    mp.pointY = xfA.p.y + mp.anchorAY;\r\n    mp.separation = separation;\r\n    mp.id = 0;\r\n    manifold.pointCount = 1;\r\n\r\n    return manifold;\r\n}\r\n\r\n/**\r\n * @function b2CollideChainSegmentAndCapsule\r\n * @description\r\n * Computes collision between a chain segment and a capsule by converting the capsule\r\n * to a polygon and delegating to the segment-polygon collision function.\r\n * @param {b2ChainSegment} segmentA - The chain segment shape\r\n * @param {b2Transform} xfA - Transform for segmentA\r\n * @param {b2Capsule} capsuleB - The capsule shape defined by two centers and a radius\r\n * @param {b2Transform} xfB - Transform for capsuleB\r\n * @param {b2DistanceCache} cache - Simplex cache for persistent contact information\r\n * @param {b2Manifold} manifold - Contact manifold to store collision results\r\n * @returns {b2Manifold} - Modified manifold\r\n */\r\nexport function b2CollideChainSegmentAndCapsule(segmentA, xfA, capsuleB, xfB, cache, manifold)\r\n{\r\n    const polyB = b2MakeCapsule(capsuleB.center1, capsuleB.center2, capsuleB.radius);\r\n\r\n    return b2CollideChainSegmentAndPolygon(segmentA, xfA, polyB, xfB, cache, manifold);\r\n}\r\n\r\nfunction b2ClipSegments(a1, a2, b1, b2, normal, ra, rb, id1, id2, manifold)\r\n{\r\n    const tangent = b2LeftPerp(normal);\r\n\r\n    // Barycentric coordinates of each point relative to a1 along tangent\r\n    const lower1 = 0.0;\r\n    const upper1 = b2Dot(b2Sub(a2, a1), tangent);\r\n\r\n    // Incident edge points opposite of tangent due to CCW winding\r\n    const upper2 = b2Dot(b2Sub(b1, a1), tangent);\r\n    const lower2 = b2Dot(b2Sub(b2, a1), tangent);\r\n\r\n    // Do segments overlap?\r\n    if (upper2 < lower1 || upper1 < lower2)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    let vLower;\r\n\r\n    if (lower2 < lower1 && upper2 - lower2 > eps)\r\n    {\r\n        vLower = b2Lerp(b2, b1, (lower1 - lower2) / (upper2 - lower2));\r\n    }\r\n    else\r\n    {\r\n        vLower = b2;\r\n    }\r\n\r\n    let vUpper;\r\n\r\n    if (upper2 > upper1 && upper2 - lower2 > eps)\r\n    {\r\n        vUpper = b2Lerp(b2, b1, (upper1 - lower2) / (upper2 - lower2));\r\n    }\r\n    else\r\n    {\r\n        vUpper = b1;\r\n    }\r\n\r\n    // todo vLower can be very close to vUpper, reduce to one point?\r\n\r\n    const separationLower = b2Dot(b2Sub(vLower, a1), normal);\r\n    const separationUpper = b2Dot(b2Sub(vUpper, a1), normal);\r\n\r\n    // Put contact points at midpoint, accounting for radii\r\n    vLower = b2MulAdd(vLower, 0.5 * (ra - rb - separationLower), normal);\r\n    vUpper = b2MulAdd(vUpper, 0.5 * (ra - rb - separationUpper), normal);\r\n\r\n    const radius = ra + rb;\r\n\r\n    manifold.normalX = normal.x;        // PJB - manifold.normal = normal;  <<< reference copy!!\r\n    manifold.normalY = normal.y;\r\n\r\n    const p0 = manifold.points[0];\r\n    p0.anchorAX = vLower.x;\r\n    p0.anchorAY = vLower.y;\r\n    p0.separation = separationLower - radius;\r\n    p0.id = id1;\r\n\r\n    const p1 = manifold.points[1];\r\n\r\n    // p1.anchorA = vUpper;\r\n    p1.anchorAX = vUpper.x;\r\n    p1.anchorAY = vUpper.y;\r\n    p1.separation = separationUpper - radius;\r\n    p1.id = id2;\r\n\r\n    manifold.pointCount = 2;\r\n\r\n    return manifold;\r\n}\r\n\r\nconst b2NormalType = {\r\n    b2_normalSkip: 0,\r\n    b2_normalAdmit: 1,\r\n    b2_normalSnap: 2\r\n};\r\n\r\nfunction b2ClassifyNormal(params, normal)\r\n{\r\n    const sinTol = 0.01;\r\n\r\n    if (b2Dot(normal, params.edge1) <= 0.0)\r\n    {\r\n        // Normal points towards the segment tail\r\n        if (params.convex1)\r\n        {\r\n            if (b2Cross(normal, params.normal0) > sinTol)\r\n            {\r\n                return b2NormalType.b2_normalSkip;\r\n            }\r\n\r\n            return b2NormalType.b2_normalAdmit;\r\n        }\r\n        else\r\n        {\r\n            return b2NormalType.b2_normalSnap;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Normal points towards segment head\r\n        if (params.convex2)\r\n        {\r\n            if (b2Cross(params.normal2, normal) > sinTol)\r\n            {\r\n                return b2NormalType.b2_normalSkip;\r\n            }\r\n\r\n            return b2NormalType.b2_normalAdmit;\r\n        }\r\n        else\r\n        {\r\n            return b2NormalType.b2_normalSnap;\r\n        }\r\n    }\r\n}\r\n\r\nclass b2ChainSegmentParams\r\n{\r\n    constructor()\r\n    {\r\n        this.edge1 = new b2Vec2();\r\n        this.normal0 = new b2Vec2();\r\n        this.normal2 = new b2Vec2();\r\n        this.convex1 = false;\r\n        this.convex2 = false;\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * @function b2CollideChainSegmentAndPolygon\r\n * @param {b2ChainSegment} chainSegmentA - The chain segment shape A\r\n * @param {b2Transform} xfA - Transform for shape A\r\n * @param {b2Polygon} polygonB - The polygon shape B\r\n * @param {b2Transform} xfB - Transform for shape B\r\n * @param {b2DistanceCache} cache - Cache for distance calculations\r\n * @param {b2Manifold} manifold - The contact manifold to populate\r\n * @returns {b2Manifold} The populated contact manifold\r\n * @description\r\n * Computes the collision manifold between a chain segment (a segment with rounded corners)\r\n * and a polygon. The function handles edge cases including convex/concave corners and\r\n * determines contact points and normals. The manifold is populated with contact points\r\n * and can contain 0, 1 or 2 contact points depending on the collision configuration.\r\n */\r\nexport function b2CollideChainSegmentAndPolygon(chainSegmentA, xfA, polygonB, xfB, cache, manifold)\r\n{\r\n    b2InvMulTransformsOut(xfA, xfB, xf);\r\n\r\n    const centroidB = b2TransformPoint(xf, polygonB.centroid);\r\n    const radiusB = polygonB.radius;\r\n\r\n    const p1 = chainSegmentA.segment.point1;\r\n    const p2 = chainSegmentA.segment.point2;\r\n\r\n    const edge1 = b2Normalize(b2Sub(p2, p1));\r\n\r\n    const chainParams = new b2ChainSegmentParams();\r\n    chainParams.edge1 = edge1.clone();\r\n\r\n    const convexTol = 0.01;\r\n    const edge0 = b2Normalize(b2Sub(p1, chainSegmentA.ghost1));\r\n    chainParams.normal0 = b2RightPerp(edge0);\r\n    chainParams.convex1 = b2Cross(edge0, edge1) >= convexTol;\r\n\r\n    const edge2 = b2Normalize(b2Sub(chainSegmentA.ghost2, p2));\r\n    chainParams.normal2 = b2RightPerp(edge2);\r\n    chainParams.convex2 = b2Cross(edge1, edge2) >= convexTol;\r\n\r\n    const normal1 = b2RightPerp(edge1);\r\n    const behind1 = b2Dot(normal1, b2Sub(centroidB, p1)) < 0.0;\r\n    let behind0 = true;\r\n    let behind2 = true;\r\n\r\n    if (chainParams.convex1)\r\n    {\r\n        behind0 = b2Dot(chainParams.normal0, b2Sub(centroidB, p1)) < 0.0;\r\n    }\r\n\r\n    if (chainParams.convex2)\r\n    {\r\n        behind2 = b2Dot(chainParams.normal2, b2Sub(centroidB, p2)) < 0.0;\r\n    }\r\n\r\n    if (behind1 && behind0 && behind2)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    const count = polygonB.count;\r\n    const vertices = [];\r\n    const normals = [];\r\n\r\n    for (let i = 0; i < count; ++i)\r\n    {\r\n        vertices[i] = b2TransformPoint(xf, polygonB.vertices[i]);\r\n        normals[i] = b2RotateVector(xf.q, polygonB.normals[i]);\r\n    }\r\n\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = b2MakeProxy([ chainSegmentA.segment.point1, chainSegmentA.segment.point2 ], 2, 0.0);\r\n    input.proxyB = b2MakeProxy(vertices, count, 0.0);\r\n    input.transformA = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.useRadii = false;\r\n\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    if (output.distance > radiusB + b2_speculativeDistance)\r\n    {\r\n        return manifold.clear();\r\n    }\r\n\r\n    const n0 = chainParams.convex1 ? chainParams.normal0 : normal1;\r\n    const n2 = chainParams.convex2 ? chainParams.normal2 : normal1;\r\n\r\n    let incidentIndex = -1;\r\n    let incidentNormal = -1;\r\n\r\n    if (behind1 == false && output.distance > 0.1 * b2_linearSlop)\r\n    {\r\n        if (cache.count == 1)\r\n        {\r\n            const pA = output.pointA;\r\n            const pB = output.pointB;\r\n\r\n            const normal = b2Normalize(b2Sub(pB, pA));\r\n\r\n            const type = b2ClassifyNormal(chainParams, normal);\r\n\r\n            if (type == b2NormalType.b2_normalSkip)\r\n            {\r\n                return manifold.clear();\r\n            }\r\n\r\n            if (type == b2NormalType.b2_normalAdmit)\r\n            {\r\n                // manifold.normal = b2RotateVector(xfA.q, normal);\r\n                manifold.normalX = xfA.q.c * normal.x - xfA.q.s * normal.y;\r\n                manifold.normalY = xfA.q.s * normal.x + xfA.q.c * normal.y;\r\n\r\n                // PJB - renamed cp to mp (it's a manifold point, not a contact/constraint point... confirmed from the C)\r\n                const mp = new b2ManifoldPoint();\r\n\r\n                // mp.anchorA = b2RotateVector(xfA.q, contactPointA);\r\n                mp.anchorAX = xfA.q.c * pA.x - xfA.q.s * pA.y;\r\n                mp.anchorAY = xfA.q.s * pA.x + xfA.q.c * pA.y;\r\n\r\n                // mp.anchorB = b2Add(mp.anchorA, b2Sub(xfA.p, xfB.p));\r\n                mp.anchorBX = mp.anchorAX + (xfA.p.x - xfB.p.x);\r\n                mp.anchorBY = mp.anchorAY + (xfA.p.y - xfB.p.y);\r\n\r\n                // mp.point = b2Add(xfA.p, mp.anchorA);\r\n                mp.pointX = xfA.p.x + mp.anchorAX;\r\n                mp.pointY = xfA.p.y + mp.anchorAY;\r\n                mp.separation = output.distance - radiusB;\r\n                mp.id = B2_MAKE_ID(cache.indexA[0], cache.indexB[0]);\r\n                manifold.points[0] = mp;\r\n                manifold.pointCount = 1;\r\n\r\n                return manifold;\r\n            }\r\n\r\n            incidentIndex = cache.indexB[0];\r\n        }\r\n        else\r\n        {\r\n            console.assert(cache.count == 2);\r\n\r\n            const ia1 = cache.indexA[0];\r\n            const ia2 = cache.indexA[1];\r\n            let ib1 = cache.indexB[0];\r\n            let ib2 = cache.indexB[1];\r\n\r\n            if (ia1 == ia2)\r\n            {\r\n                console.assert(ib1 != ib2);\r\n\r\n                let normalB = b2Sub(output.pointA, output.pointB);\r\n                let dot1 = b2Dot(normalB, normals[ib1]);\r\n                let dot2 = b2Dot(normalB, normals[ib2]);\r\n                const ib = dot1 > dot2 ? ib1 : ib2;\r\n\r\n                normalB = normals[ib];\r\n\r\n                const type = b2ClassifyNormal(chainParams, b2Neg(normalB));\r\n\r\n                if (type == b2NormalType.b2_normalSkip)\r\n                {\r\n                    return manifold.clear();\r\n                }\r\n\r\n                if (type == b2NormalType.b2_normalAdmit)\r\n                {\r\n                    ib1 = ib;\r\n                    ib2 = ib < count - 1 ? ib + 1 : 0;\r\n\r\n                    const b1 = vertices[ib1];\r\n                    const b2 = vertices[ib2];\r\n\r\n                    dot1 = b2Dot(normalB, b2Sub(p1, b1));\r\n                    dot2 = b2Dot(normalB, b2Sub(p2, b1));\r\n\r\n                    if (dot1 < dot2)\r\n                    {\r\n                        if (b2Dot(n0, normalB) < b2Dot(normal1, normalB))\r\n                        {\r\n                            return manifold.clear();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if (b2Dot(n2, normalB) < b2Dot(normal1, normalB))\r\n                        {\r\n                            return manifold.clear();\r\n                        }\r\n                    }\r\n\r\n                    b2ClipSegments(b1, b2, p1, p2, normalB, radiusB, 0.0, B2_MAKE_ID(ib1, 1), B2_MAKE_ID(ib2, 0), manifold);\r\n\r\n                    // manifold.normal = b2RotateVector(xfA.q, b2Neg(normalB));\r\n                    manifold.normalX = xfA.q.c * -normalB.x - xfA.q.s * -normalB.y;\r\n                    manifold.normalY = xfA.q.s * -normalB.x + xfA.q.c * -normalB.y;\r\n\r\n                    // manifold.points[0].anchorA = b2RotateVector(xfA.q, manifold.points[0].anchorA);\r\n                    manifold.points[0].anchorAX = xfA.q.c * manifold.points[0].anchorAX - xfA.q.s * manifold.points[0].anchorAY;\r\n                    manifold.points[0].anchorAY = xfA.q.s * manifold.points[0].anchorAX + xfA.q.c * manifold.points[0].anchorAY;\r\n\r\n                    // manifold.points[1].anchorA = b2RotateVector(xfA.q, manifold.points[1].anchorA);\r\n                    manifold.points[1].anchorAX = xfA.q.c * manifold.points[1].anchorAX - xfA.q.s * manifold.points[1].anchorAY;\r\n                    manifold.points[1].anchorAY = xfA.q.s * manifold.points[1].anchorAX + xfA.q.c * manifold.points[1].anchorAY;\r\n                    const pAB = b2Sub(xfA.p, xfB.p);\r\n\r\n                    // manifold.points[0].anchorB = b2Add(manifold.points[0].anchorA, pAB);\r\n                    manifold.points[0].anchorBX = manifold.points[0].anchorAX + pAB.x;\r\n                    manifold.points[0].anchorBY = manifold.points[0].anchorAY + pAB.y;\r\n\r\n                    // manifold.points[1].anchorB = b2Add(manifold.points[1].anchorA, pAB);\r\n                    manifold.points[1].anchorBX = manifold.points[1].anchorAX + pAB.x;\r\n                    manifold.points[1].anchorBY = manifold.points[1].anchorAY + pAB.y;\r\n\r\n                    // manifold.points[0].point = b2Add(xfA.p, manifold.points[0].anchorA);\r\n                    manifold.points[0].pointX = xfA.p.x + manifold.points[0].anchorAX;\r\n                    manifold.points[0].pointY = xfA.p.y + manifold.points[0].anchorAY;\r\n\r\n                    // manifold.points[1].point = b2Add(xfA.p, manifold.points[1].anchorA);\r\n                    manifold.points[1].pointX = xfA.p.x + manifold.points[1].anchorAX;\r\n                    manifold.points[1].pointY = xfA.p.y + manifold.points[1].anchorAY;\r\n\r\n                    return manifold;\r\n                }\r\n\r\n                incidentNormal = ib;\r\n            }\r\n            else\r\n            {\r\n                const dot1 = b2Dot(normal1, b2Sub(vertices[ib1], p1));\r\n                const dot2 = b2Dot(normal1, b2Sub(vertices[ib2], p2));\r\n                incidentIndex = dot1 < dot2 ? ib1 : ib2;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // SAT edge normal\r\n        let edgeSeparation = Number.MAX_VALUE;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const s = b2Dot(normal1, b2Sub(vertices[i], p1));\r\n\r\n            if (s < edgeSeparation)\r\n            {\r\n                edgeSeparation = s;\r\n                incidentIndex = i;\r\n            }\r\n        }\r\n\r\n        // Check convex neighbor for edge separation\r\n        if (chainParams.convex1)\r\n        {\r\n            let s0 = Number.MAX_VALUE;\r\n\r\n            for (let i = 0; i < count; ++i)\r\n            {\r\n                const s = b2Dot(chainParams.normal0, b2Sub(vertices[i], p1));\r\n\r\n                if (s < s0)\r\n                {\r\n                    s0 = s;\r\n                }\r\n            }\r\n\r\n            if (s0 > edgeSeparation)\r\n            {\r\n                edgeSeparation = s0;\r\n                incidentIndex = -1;\r\n            }\r\n        }\r\n\r\n        if (chainParams.convex2)\r\n        {\r\n            let s2 = Number.MAX_VALUE;\r\n\r\n            for (let i = 0; i < count; ++i)\r\n            {\r\n                const s = b2Dot(chainParams.normal2, b2Sub(vertices[i], p2));\r\n\r\n                if (s < s2)\r\n                {\r\n                    s2 = s;\r\n                }\r\n            }\r\n\r\n            if (s2 > edgeSeparation)\r\n            {\r\n                edgeSeparation = s2;\r\n                incidentIndex = -1;\r\n            }\r\n        }\r\n\r\n        // SAT polygon normals\r\n        let polygonSeparation = -Number.MAX_VALUE;\r\n        let referenceIndex = -1;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const n = normals[i];\r\n\r\n            const type = b2ClassifyNormal(chainParams, b2Neg(n));\r\n\r\n            if (type != b2NormalType.b2_normalAdmit)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const p = vertices[i];\r\n            const s = Math.min(b2Dot(n, b2Sub(p2, p)), b2Dot(n, b2Sub(p1, p)));\r\n\r\n            if (s > polygonSeparation)\r\n            {\r\n                polygonSeparation = s;\r\n                referenceIndex = i;\r\n            }\r\n        }\r\n\r\n        if (polygonSeparation > edgeSeparation)\r\n        {\r\n            const ia1 = referenceIndex;\r\n            const ia2 = ia1 < count - 1 ? ia1 + 1 : 0;\r\n            const a1 = vertices[ia1];\r\n            const a2 = vertices[ia2];\r\n\r\n            const n = normals[ia1];\r\n\r\n            const dot1 = b2Dot(n, b2Sub(p1, a1));\r\n            const dot2 = b2Dot(n, b2Sub(p2, a1));\r\n\r\n            if (dot1 < dot2)\r\n            {\r\n                if (b2Dot(n0, n) < b2Dot(normal1, n))\r\n                {\r\n                    return manifold.clear();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (b2Dot(n2, n) < b2Dot(normal1, n))\r\n                {\r\n                    return manifold.clear();\r\n                }\r\n            }\r\n\r\n            b2ClipSegments(a1, a2, p1, p2, normals[ia1], radiusB, 0.0, B2_MAKE_ID(ia1, 1), B2_MAKE_ID(ia2, 0), manifold);\r\n\r\n            // manifold.normal = b2RotateVector(xfA.q, b2Neg(normals[ia1]));\r\n            manifold.normalX = xfA.q.c * -normals[ia1].x - xfA.q.s * -normals[ia1].y;\r\n            manifold.normalY = xfA.q.s * -normals[ia1].x + xfA.q.c * -normals[ia1].y;\r\n\r\n            // manifold.points[0].anchorA = b2RotateVector(xfA.q, manifold.points[0].anchorA);\r\n            manifold.points[0].anchorAX = xfA.q.c * manifold.points[0].anchorAX - xfA.q.s * manifold.points[0].anchorAY;\r\n            manifold.points[0].anchorAY = xfA.q.s * manifold.points[0].anchorAX + xfA.q.c * manifold.points[0].anchorAY;\r\n\r\n            // manifold.points[1].anchorA = b2RotateVector(xfA.q, manifold.points[1].anchorA);\r\n            manifold.points[1].anchorAX = xfA.q.c * manifold.points[1].anchorAX - xfA.q.s * manifold.points[1].anchorAY;\r\n            manifold.points[1].anchorAY = xfA.q.s * manifold.points[1].anchorAX + xfA.q.c * manifold.points[1].anchorAY;\r\n            const pAB = b2Sub(xfA.p, xfB.p);\r\n\r\n            // manifold.points[0].anchorB = b2Add(manifold.points[0].anchorA, pAB);\r\n            manifold.points[0].anchorBX = manifold.points[0].anchorAX + pAB.x;\r\n            manifold.points[0].anchorBY = manifold.points[0].anchorAY + pAB.y;\r\n\r\n            // manifold.points[1].anchorB = b2Add(manifold.points[1].anchorA, pAB);\r\n            manifold.points[1].anchorBX = manifold.points[1].anchorAX + pAB.x;\r\n            manifold.points[1].anchorBY = manifold.points[1].anchorAY + pAB.y;\r\n\r\n            // manifold.points[0].point = b2Add(xfA.p, manifold.points[0].anchorA);\r\n            manifold.points[0].pointX = xfA.p.x + manifold.points[0].anchorAX;\r\n            manifold.points[0].pointY = xfA.p.y + manifold.points[0].anchorAY;\r\n\r\n            // manifold.points[1].point = b2Add(xfA.p, manifold.points[1].anchorA);\r\n            manifold.points[1].pointX = xfA.p.x + manifold.points[1].anchorAX;\r\n            manifold.points[1].pointY = xfA.p.y + manifold.points[1].anchorAY;\r\n\r\n            return manifold;\r\n        }\r\n\r\n        if (incidentIndex == -1)\r\n        {\r\n            return manifold.clear();\r\n        }\r\n    }\r\n\r\n    console.assert(incidentNormal != -1 || incidentIndex != -1);\r\n\r\n    let b1, b2;\r\n    let ib1, ib2;\r\n\r\n    if (incidentNormal != -1)\r\n    {\r\n        ib1 = incidentNormal;\r\n        ib2 = ib1 < count - 1 ? ib1 + 1 : 0;\r\n        b1 = vertices[ib1];\r\n        b2 = vertices[ib2];\r\n    }\r\n    else\r\n    {\r\n        const i2 = incidentIndex;\r\n        const i1 = i2 > 0 ? i2 - 1 : count - 1;\r\n        const d1 = b2Dot(normal1, normals[i1]);\r\n        const d2 = b2Dot(normal1, normals[i2]);\r\n\r\n        if (d1 < d2)\r\n        {\r\n            ib1 = i1;\r\n            ib2 = i2;\r\n            b1 = vertices[ib1];\r\n            b2 = vertices[ib2];\r\n        }\r\n        else\r\n        {\r\n            ib1 = i2;\r\n            ib2 = i2 < count - 1 ? i2 + 1 : 0;\r\n            b1 = vertices[ib1];\r\n            b2 = vertices[ib2];\r\n        }\r\n    }\r\n\r\n    b2ClipSegments(p1, p2, b1, b2, normal1, 0.0, radiusB, B2_MAKE_ID(0, ib2), B2_MAKE_ID(1, ib1), manifold);\r\n\r\n    // manifold.normal = b2RotateVector(xfA.q, manifold.normal);\r\n    manifold.normalX = xfA.q.c * manifold.normalX - xfA.q.s * manifold.normalY;\r\n    manifold.normalY = xfA.q.s * manifold.normalX + xfA.q.c * manifold.normalY;\r\n\r\n    // manifold.points[0].anchorA = b2RotateVector(xfA.q, manifold.points[0].anchorA);\r\n    manifold.points[0].anchorAX = xfA.q.c * manifold.points[0].anchorAX - xfA.q.s * manifold.points[0].anchorAY;\r\n    manifold.points[0].anchorAY = xfA.q.s * manifold.points[0].anchorAX + xfA.q.c * manifold.points[0].anchorAY;\r\n\r\n    // manifold.points[1].anchorA = b2RotateVector(xfA.q, manifold.points[1].anchorA);\r\n    manifold.points[1].anchorAX = xfA.q.c * manifold.points[1].anchorAX - xfA.q.s * manifold.points[1].anchorAY;\r\n    manifold.points[1].anchorAY = xfA.q.s * manifold.points[1].anchorAX + xfA.q.c * manifold.points[1].anchorAY;\r\n    const pAB = b2Sub(xfA.p, xfB.p);\r\n\r\n    // manifold.points[0].anchorB = b2Add(manifold.points[0].anchorA, pAB);\r\n    manifold.points[0].anchorBX = manifold.points[0].anchorAX + pAB.x;\r\n    manifold.points[0].anchorBY = manifold.points[0].anchorAY + pAB.y;\r\n\r\n    // manifold.points[1].anchorB = b2Add(manifold.points[1].anchorA, pAB);\r\n    manifold.points[1].anchorBX = manifold.points[1].anchorAX + pAB.x;\r\n    manifold.points[1].anchorBY = manifold.points[1].anchorAY + pAB.y;\r\n\r\n    // manifold.points[0].point = b2Add(xfA.p, manifold.points[0].anchorA);\r\n    manifold.points[0].pointX = xfA.p.x + manifold.points[0].anchorAX;\r\n    manifold.points[0].pointY = xfA.p.y + manifold.points[0].anchorAY;\r\n\r\n    // manifold.points[1].point = b2Add(xfA.p, manifold.points[1].anchorA);\r\n    manifold.points[1].pointX = xfA.p.x + manifold.points[1].anchorAX;\r\n    manifold.points[1].pointY = xfA.p.y + manifold.points[1].anchorAY;\r\n\r\n    return manifold;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_NULL_INDEX, b2_graphColorCount } from './include/core_h.js';\r\nimport { B2_SHAPE_PAIR_KEY, b2AddKey, b2RemoveKey } from './include/table_h.js';\r\nimport { b2AddContact, b2RemoveContact } from './include/block_array_h.js';\r\nimport { b2AllocId, b2FreeId } from './include/id_pool_h.js';\r\nimport {\r\n    b2CollideCapsuleAndCircle,\r\n    b2CollideCapsules,\r\n    b2CollideChainSegmentAndCapsule,\r\n    b2CollideChainSegmentAndCircle,\r\n    b2CollideChainSegmentAndPolygon,\r\n    b2CollideCircles,\r\n    b2CollidePolygonAndCapsule,\r\n    b2CollidePolygonAndCircle,\r\n    b2CollidePolygons,\r\n    b2CollideSegmentAndCapsule,\r\n    b2CollideSegmentAndCircle,\r\n    b2CollideSegmentAndPolygon\r\n} from './include/manifold_h.js';\r\nimport { b2ContactEndTouchEvent, b2SensorEndTouchEvent, b2ShapeType } from './include/types_h.js';\r\nimport { b2DistanceCache, b2DistanceInput, b2Manifold } from './include/collision_h.js';\r\nimport { b2GetBody, b2WakeBody } from './include/body_h.js';\r\n\r\nimport { b2ContactSimFlags } from './include/contact_h.js';\r\nimport { b2MakeShapeDistanceProxy } from './include/shape_h.js';\r\nimport { b2RemoveContactFromGraph } from './include/constraint_graph_h.js';\r\nimport { b2SetType } from './include/world_h.js';\r\nimport { b2ShapeDistance } from './include/distance_h.js';\r\nimport { b2ShapeId } from './include/id_h.js';\r\nimport { b2UnlinkContact } from './include/island_h.js';\r\nimport { eps } from './include/math_functions_h.js';\r\n\r\n/**\r\n * @namespace Contact\r\n */\r\n\r\nexport const b2ContactFlags = {\r\n    b2_contactTouchingFlag: 0x00000001,\r\n    b2_contactHitEventFlag: 0x00000002,\r\n    b2_contactSensorFlag: 0x0000004,\r\n    b2_contactSensorTouchingFlag: 0x00000008,\r\n    b2_contactEnableSensorEvents: 0x00000010,\r\n    b2_contactEnableContactEvents: 0x00000020,\r\n};\r\n\r\nexport class b2ContactEdge\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyId = 0;\r\n        this.prevKey = 0;\r\n        this.nextKey = 0;\r\n    }\r\n}\r\n\r\nexport class b2Contact\r\n{\r\n    constructor()\r\n    {\r\n        this.setIndex = 0;\r\n        this.colorIndex = 0;\r\n        this.localIndex = 0;\r\n        this.edges = [ new b2ContactEdge(), new b2ContactEdge() ];\r\n        this.shapeIdA = 0;\r\n        this.shapeIdB = 0;\r\n        this.islandPrev = 0;\r\n        this.islandNext = 0;\r\n        this.islandId = B2_NULL_INDEX;\r\n        this.contactId = B2_NULL_INDEX;\r\n        this.flags = 0;\r\n        this.isMarked = false;\r\n    }\r\n}\r\n\r\nexport class b2ContactSim\r\n{\r\n    constructor(manifold = new b2Manifold())\r\n    {\r\n        // GlobalDebug.b2ContactSimCount++;\r\n        this.contactId = 0;\r\n        this._bodyIdA = B2_NULL_INDEX;           // debug only\r\n        this._bodyIdB = B2_NULL_INDEX;           // debug only\r\n        this.bodySimIndexA = 0;\r\n        this.bodySimIndexB = 0;\r\n        this.shapeIdA = 0;\r\n        this.shapeIdB = 0;\r\n        this.invMassA = 0;\r\n        this.invIA = 0;\r\n        this.invMassB = 0;\r\n        this.invIB = 0;\r\n        this.manifold = manifold;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n        this.tangentSpeed = 0;\r\n        this.simFlags = 0;\r\n        this.cache = new b2DistanceCache();\r\n    }\r\n\r\n    set(src)\r\n    {\r\n        this.contactId = src.contactId;\r\n        this._bodyIdA = src._bodyIdA;\r\n        this._bodyIdB = src._bodyIdB;\r\n        this.bodySimIndexA = src.bodySimIndexA;\r\n        this.bodySimIndexB = src.bodySimIndexB;\r\n        this.shapeIdA = src.shapeIdA;\r\n        this.shapeIdB = src.shapeIdB;\r\n        this.invMassA = src.invMassA;\r\n        this.invIA = src.invIA;\r\n        this.invMassB = src.invMassB;\r\n        this.invIB = src.invIB;\r\n        src.manifold.copyTo(this.manifold);\r\n        this.friction = src.friction;\r\n        this.restitution = src.restitution;\r\n        this.tangentSpeed = src.tangentSpeed;\r\n        this.simFlags = src.simFlags;\r\n        this.cache = src.cache.clone();\r\n    }\r\n}\r\n\r\n// Friction mixing law. The idea is to allow either shape to drive the friction to zero.\r\n// For example, anything slides on ice.\r\nfunction b2MixFriction(friction1, friction2)\r\n{\r\n    return Math.sqrt(friction1 * friction2);\r\n}\r\n\r\n// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.\r\n// For example, a superball bounces on anything.\r\nfunction b2MixRestitution(restitution1, restitution2)\r\n{\r\n    return Math.max(restitution1, restitution2);\r\n}\r\n\r\n// todo make relative for all\r\n// typedef b2Manifold b2ManifoldFcn(const b2Shape* shapeA, const b2Shape* shapeB, b2Transform xfB, b2DistanceCache* cache);\r\n// function b2ManifoldFcn(shapeA, xfA, shapeB, xfB, cache) {\r\n// }\r\n// this is a callback declaration, not required in JS\r\n\r\nclass b2ContactRegister\r\n{\r\n    constructor(fcn = null, primary = false)\r\n    {\r\n        this.fcn = fcn;\r\n        this.primary = primary;\r\n    }\r\n}\r\n\r\nconst s_registers = Array(b2ShapeType.b2_shapeTypeCount).fill().map(() =>\r\n    Array(b2ShapeType.b2_shapeTypeCount).fill().map(() => new b2ContactRegister())\r\n);\r\n\r\nlet s_initialized = false;\r\n\r\nexport function b2CircleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideCircles(shapeA.circle, xfA, shapeB.circle, xfB, manifold);\r\n}\r\n\r\nexport function b2CapsuleAndCircleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideCapsuleAndCircle(shapeA.capsule, xfA, shapeB.circle, xfB, manifold);\r\n}\r\n\r\nexport function b2CapsuleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideCapsules(shapeA.capsule, xfA, shapeB.capsule, xfB, manifold);\r\n}\r\n\r\nexport function b2PolygonAndCircleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollidePolygonAndCircle(shapeA.polygon, xfA, shapeB.circle, xfB, manifold);\r\n}\r\n\r\nexport function b2PolygonAndCapsuleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollidePolygonAndCapsule(shapeA.polygon, xfA, shapeB.capsule, xfB, manifold);\r\n}\r\n\r\nexport function b2PolygonManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollidePolygons(shapeA.polygon, xfA, shapeB.polygon, xfB, manifold);\r\n}\r\n\r\nexport function b2SegmentAndCircleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideSegmentAndCircle(shapeA.segment, xfA, shapeB.circle, xfB, manifold);\r\n}\r\n\r\nexport function b2SegmentAndCapsuleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideSegmentAndCapsule(shapeA.segment, xfA, shapeB.capsule, xfB, manifold);\r\n}\r\n\r\nexport function b2SegmentAndPolygonManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideSegmentAndPolygon(shapeA.segment, xfA, shapeB.polygon, xfB, manifold);\r\n}\r\n\r\nexport function b2ChainSegmentAndCircleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideChainSegmentAndCircle(shapeA.chainSegment, xfA, shapeB.circle, xfB, manifold);\r\n}\r\n\r\nexport function b2ChainSegmentAndCapsuleManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideChainSegmentAndCapsule(shapeA.chainSegment, xfA, shapeB.capsule, xfB, cache, manifold);\r\n}\r\n\r\nexport function b2ChainSegmentAndPolygonManifold(shapeA, xfA, shapeB, xfB, cache, manifold)\r\n{\r\n    return b2CollideChainSegmentAndPolygon(shapeA.chainSegment, xfA, shapeB.polygon, xfB, cache, manifold);\r\n}\r\n\r\nexport function b2AddType(fcn, type1, type2)\r\n{\r\n    console.assert(0 <= type1 && type1 < b2ShapeType.b2_shapeTypeCount);\r\n    console.assert(0 <= type2 && type2 < b2ShapeType.b2_shapeTypeCount);\r\n    s_registers[type1][type2].fcn = fcn;\r\n    s_registers[type1][type2].primary = true;\r\n\r\n    if ( type1 != type2 )\r\n    {\r\n        s_registers[type2][type1].fcn = fcn;\r\n        s_registers[type2][type1].primary = false;\r\n    }\r\n}\r\n\r\n// add callbacks for each manifold type\r\nexport function b2InitializeContactRegisters()\r\n{\r\n    if (s_initialized === false)\r\n    {\r\n        b2AddType(b2CircleManifold, b2ShapeType.b2_circleShape, b2ShapeType.b2_circleShape);\r\n        b2AddType(b2CapsuleAndCircleManifold, b2ShapeType.b2_capsuleShape, b2ShapeType.b2_circleShape);\r\n        b2AddType(b2CapsuleManifold, b2ShapeType.b2_capsuleShape, b2ShapeType.b2_capsuleShape);\r\n        b2AddType(b2PolygonAndCircleManifold, b2ShapeType.b2_polygonShape, b2ShapeType.b2_circleShape);\r\n        b2AddType(b2PolygonAndCapsuleManifold, b2ShapeType.b2_polygonShape, b2ShapeType.b2_capsuleShape);\r\n        b2AddType(b2PolygonManifold, b2ShapeType.b2_polygonShape, b2ShapeType.b2_polygonShape);\r\n        b2AddType(b2SegmentAndCircleManifold, b2ShapeType.b2_segmentShape, b2ShapeType.b2_circleShape);\r\n        b2AddType(b2SegmentAndCapsuleManifold, b2ShapeType.b2_segmentShape, b2ShapeType.b2_capsuleShape);\r\n        b2AddType(b2SegmentAndPolygonManifold, b2ShapeType.b2_segmentShape, b2ShapeType.b2_polygonShape);\r\n        b2AddType(b2ChainSegmentAndCircleManifold, b2ShapeType.b2_chainSegmentShape, b2ShapeType.b2_circleShape);\r\n        b2AddType(b2ChainSegmentAndCapsuleManifold, b2ShapeType.b2_chainSegmentShape, b2ShapeType.b2_capsuleShape);\r\n        b2AddType(b2ChainSegmentAndPolygonManifold, b2ShapeType.b2_chainSegmentShape, b2ShapeType.b2_polygonShape);\r\n        s_initialized = true;\r\n    }\r\n}\r\n\r\nexport function b2CreateContact(world, shapeA, shapeB)\r\n{\r\n    const type1 = shapeA.type;\r\n    const type2 = shapeB.type;\r\n\r\n    if (s_registers[type1][type2].fcn === null)\r\n    {\r\n        // For example, no segment vs segment collision\r\n        return;\r\n    }\r\n\r\n    if (s_registers[type1][type2].primary === false)\r\n    {\r\n        // flip order\r\n        b2CreateContact(world, shapeB, shapeA);\r\n\r\n        return;\r\n    }\r\n\r\n    const bodyA = b2GetBody(world, shapeA.bodyId);\r\n    const bodyB = b2GetBody(world, shapeB.bodyId);\r\n\r\n    let setIndex;\r\n\r\n    if (bodyA.setIndex === b2SetType.b2_awakeSet || bodyB.setIndex === b2SetType.b2_awakeSet)\r\n    {\r\n        setIndex = b2SetType.b2_awakeSet;\r\n    }\r\n    else\r\n    {\r\n        // sleeping and non-touching contacts live in the disabled set\r\n        // later if this set is found to be touching then the sleeping\r\n        // islands will be linked and the contact moved to the merged island\r\n        setIndex = b2SetType.b2_disabledSet;\r\n    }\r\n\r\n    const set = world.solverSetArray[setIndex];\r\n\r\n    // Create contact key and contact\r\n    const contactId = b2AllocId(world.contactIdPool);\r\n\r\n    // grow array until contactId will fit in it\r\n    while (world.contactArray.length <= contactId)\r\n    {\r\n        world.contactArray.push(new b2Contact());\r\n    }\r\n\r\n    const shapeIdA = shapeA.id;\r\n    const shapeIdB = shapeB.id;\r\n\r\n    const contact = world.contactArray[contactId];\r\n    contact.contactId = contactId;\r\n    contact.setIndex = setIndex;\r\n    contact.colorIndex = B2_NULL_INDEX;\r\n    contact.localIndex = set.contacts.count;\r\n    contact.islandId = B2_NULL_INDEX;\r\n    contact.islandPrev = B2_NULL_INDEX;\r\n    contact.islandNext = B2_NULL_INDEX;\r\n    contact.shapeIdA = shapeIdA;\r\n    contact.shapeIdB = shapeIdB;\r\n    contact.isMarked = false;\r\n    contact.flags = 0;\r\n\r\n    if (shapeA.isSensor || shapeB.isSensor)\r\n    {\r\n        contact.flags |= b2ContactFlags.b2_contactSensorFlag;\r\n    }\r\n\r\n    if (shapeA.enableSensorEvents || shapeB.enableSensorEvents)\r\n    {\r\n        contact.flags |= b2ContactFlags.b2_contactEnableSensorEvents;\r\n    }\r\n\r\n    if (shapeA.enableContactEvents || shapeB.enableContactEvents)\r\n    {\r\n        contact.flags |= b2ContactFlags.b2_contactEnableContactEvents;\r\n    }\r\n\r\n    // Connect to body A\r\n    {\r\n        contact.edges[0].bodyId = shapeA.bodyId;\r\n        contact.edges[0].prevKey = B2_NULL_INDEX;\r\n        contact.edges[0].nextKey = bodyA.headContactKey;\r\n\r\n        const keyA = (contactId << 1) | 0;\r\n        const headContactKey = bodyA.headContactKey;\r\n\r\n        if (headContactKey !== B2_NULL_INDEX)\r\n        {\r\n            const headContact = world.contactArray[headContactKey >> 1];\r\n            headContact.edges[headContactKey & 1].prevKey = keyA;\r\n        }\r\n        bodyA.headContactKey = keyA;\r\n        bodyA.contactCount += 1;\r\n    }\r\n\r\n    // Connect to body B\r\n    {\r\n        contact.edges[1].bodyId = shapeB.bodyId;\r\n        contact.edges[1].prevKey = B2_NULL_INDEX;\r\n        contact.edges[1].nextKey = bodyB.headContactKey;\r\n\r\n        const keyB = (contactId << 1) | 1;\r\n        const headContactKey = bodyB.headContactKey;\r\n\r\n        if (bodyB.headContactKey !== B2_NULL_INDEX)\r\n        {\r\n            const headContact = world.contactArray[headContactKey >> 1];\r\n            headContact.edges[headContactKey & 1].prevKey = keyB;\r\n        }\r\n        bodyB.headContactKey = keyB;\r\n        bodyB.contactCount += 1;\r\n    }\r\n\r\n    // Add to pair set for fast lookup\r\n    const pairKey = B2_SHAPE_PAIR_KEY(shapeIdA, shapeIdB);\r\n    b2AddKey(world.broadPhase.pairSet, pairKey);\r\n\r\n    // Contacts are created as non-touching. Later if they are found to be touching\r\n    // they will link islands and be moved into the constraint graph.\r\n    const contactSim = b2AddContact(set.contacts);\r\n    contactSim.contactId = contactId;\r\n\r\n    // #if B2_VALIDATE\r\n    contactSim._bodyIdA = shapeA.bodyId;     // debug only\r\n    contactSim._bodyIdB = shapeB.bodyId;     // debug only\r\n    console.assert(contactSim._bodyIdA !== contactSim._bodyIdB);\r\n\r\n    // #endif\r\n\r\n    contactSim.bodySimIndexA = B2_NULL_INDEX;\r\n    contactSim.bodySimIndexB = B2_NULL_INDEX;\r\n    contactSim.invMassA = 0.0;\r\n    contactSim.invIA = 0.0;\r\n    contactSim.invMassB = 0.0;\r\n    contactSim.invIB = 0.0;\r\n    contactSim.shapeIdA = shapeIdA;\r\n    contactSim.shapeIdB = shapeIdB;\r\n\r\n    // contactSim.cache = new b2DistanceCache();\r\n    // contactSim.manifold = new b2Manifold();\r\n    contactSim.friction = b2MixFriction(shapeA.friction, shapeB.friction);\r\n    contactSim.restitution = b2MixRestitution(shapeA.restitution, shapeB.restitution);\r\n    contactSim.tangentSpeed = 0.0;\r\n    contactSim.simFlags = 0;\r\n\r\n    if (shapeA.enablePreSolveEvents || shapeB.enablePreSolveEvents)\r\n    {\r\n        contactSim.simFlags |= b2ContactSimFlags.b2_simEnablePreSolveEvents;\r\n    }\r\n}\r\n\r\nexport function b2DestroyContact(world, contact, wakeBodies)\r\n{\r\n    // Remove pair from set\r\n    const pairKey = B2_SHAPE_PAIR_KEY(contact.shapeIdA, contact.shapeIdB);\r\n    b2RemoveKey(world.broadPhase.pairSet, pairKey);\r\n\r\n    const edgeA = contact.edges[0];\r\n    const edgeB = contact.edges[1];\r\n\r\n    const bodyIdA = edgeA.bodyId;\r\n    const bodyIdB = edgeB.bodyId;\r\n    const bodyA = b2GetBody(world, bodyIdA);\r\n    const bodyB = b2GetBody(world, bodyIdB);\r\n\r\n    const flags = contact.flags;\r\n\r\n    if ((flags & (b2ContactFlags.b2_contactTouchingFlag | b2ContactFlags.b2_contactSensorTouchingFlag)) != 0 && (flags & (b2ContactFlags.b2_contactEnableContactEvents | b2ContactFlags.b2_contactEnableSensorEvents)) != 0)\r\n    {\r\n        const worldId = world.worldId;\r\n        const shapeA = world.shapeArray[contact.shapeIdA];\r\n        const shapeB = world.shapeArray[contact.shapeIdB];\r\n        const shapeIdA = new b2ShapeId(shapeA.id + 1, worldId, shapeA.revision);\r\n        const shapeIdB = new b2ShapeId(shapeB.id + 1, worldId, shapeB.revision);\r\n\r\n        // Was touching?\r\n        if ((flags & b2ContactFlags.b2_contactTouchingFlag) != 0 && (flags & b2ContactFlags.b2_contactEnableContactEvents) != 0)\r\n        {\r\n            console.assert( ( flags & b2ContactFlags.b2_contactSensorFlag ) == 0 );\r\n            const event = new b2ContactEndTouchEvent(shapeIdA, shapeIdB);\r\n            world.contactEndArray.push(event);\r\n        }\r\n\r\n        if ((flags & b2ContactFlags.b2_contactSensorTouchingFlag) != 0 && (flags & b2ContactFlags.b2_contactEnableSensorEvents) != 0)\r\n        {\r\n            console.assert( ( flags & b2ContactFlags.b2_contactSensorFlag ) != 0 );\r\n            console.assert( shapeA.isSensor == true || shapeB.isSensor == true );\r\n            console.assert( shapeA.isSensor != shapeB.isSensor );\r\n\r\n            const event = new b2SensorEndTouchEvent();\r\n\r\n            if (shapeA.isSensor)\r\n            {\r\n                event.sensorShapeId = shapeIdA;\r\n                event.visitorShapeId = shapeIdB;\r\n            }\r\n            else\r\n            {\r\n                event.sensorShapeId = shapeIdB;\r\n                event.visitorShapeId = shapeIdA;\r\n            }\r\n\r\n            world.sensorEndEventArray.push(event);\r\n        }\r\n    }\r\n\r\n    // Remove from body A\r\n    if (edgeA.prevKey !== B2_NULL_INDEX)\r\n    {\r\n        const prevContact = world.contactArray[edgeA.prevKey >> 1];\r\n        const prevEdge = prevContact.edges[edgeA.prevKey & 1];\r\n        prevEdge.nextKey = edgeA.nextKey;\r\n    }\r\n\r\n    if (edgeA.nextKey !== B2_NULL_INDEX)\r\n    {\r\n        const nextContact = world.contactArray[edgeA.nextKey >> 1];\r\n        const nextEdge = nextContact.edges[edgeA.nextKey & 1];\r\n        nextEdge.prevKey = edgeA.prevKey;\r\n    }\r\n\r\n    const contactId = contact.contactId;\r\n\r\n    const edgeKeyA = (contactId << 1) | 0;\r\n\r\n    if (bodyA.headContactKey === edgeKeyA)\r\n    {\r\n        bodyA.headContactKey = edgeA.nextKey;\r\n    }\r\n\r\n    bodyA.contactCount -= 1;\r\n\r\n    // Remove from body B\r\n    if (edgeB.prevKey !== B2_NULL_INDEX)\r\n    {\r\n        const prevContact = world.contactArray[edgeB.prevKey >> 1];\r\n        const prevEdge = prevContact.edges[edgeB.prevKey & 1];\r\n        prevEdge.nextKey = edgeB.nextKey;\r\n    }\r\n\r\n    if (edgeB.nextKey !== B2_NULL_INDEX)\r\n    {\r\n        const nextContact = world.contactArray[edgeB.nextKey >> 1];\r\n        const nextEdge = nextContact.edges[edgeB.nextKey & 1];\r\n        nextEdge.prevKey = edgeB.prevKey;\r\n    }\r\n\r\n    const edgeKeyB = (contactId << 1) | 1;\r\n\r\n    if (bodyB.headContactKey === edgeKeyB)\r\n    {\r\n        bodyB.headContactKey = edgeB.nextKey;\r\n    }\r\n\r\n    bodyB.contactCount -= 1;\r\n\r\n    // Remove contact from the array that owns it\r\n    if (contact.islandId !== B2_NULL_INDEX)\r\n    {\r\n        b2UnlinkContact(world, contact);\r\n    }\r\n\r\n    if (contact.colorIndex !== B2_NULL_INDEX)\r\n    {\r\n        // contact is an active constraint\r\n        console.assert(contact.setIndex == b2SetType.b2_awakeSet);\r\n        b2RemoveContactFromGraph(world, bodyIdA, bodyIdB, contact.colorIndex, contact.localIndex);\r\n    }\r\n    else\r\n    {\r\n        // contact is non-touching or is sleeping or is a sensor\r\n        console.assert(contact.setIndex != b2SetType.b2_awakeSet ||\r\n            (contact.flags & b2ContactFlags.b2_contactTouchingFlag) == 0 ||\r\n            (contact.flags & b2ContactFlags.b2_contactSensorFlag) != 0);\r\n        const set = world.solverSetArray[contact.setIndex];\r\n        const movedIndex = b2RemoveContact(set.contacts, contact.localIndex);\r\n\r\n        if (movedIndex !== B2_NULL_INDEX)\r\n        {\r\n            const movedContact = set.contacts.data[contact.localIndex];\r\n            world.contactArray[movedContact.contactId].localIndex = contact.localIndex;\r\n        }\r\n    }\r\n\r\n    contact.contactId = B2_NULL_INDEX;\r\n    contact.setIndex = B2_NULL_INDEX;\r\n    contact.colorIndex = B2_NULL_INDEX;\r\n    contact.localIndex = B2_NULL_INDEX;\r\n\r\n    b2FreeId(world.contactIdPool, contactId);\r\n\r\n    if (wakeBodies)\r\n    {\r\n        b2WakeBody(world, bodyA);\r\n        b2WakeBody(world, bodyB);\r\n    }\r\n}\r\n\r\nexport function b2GetContactSim(world, contact)\r\n{\r\n    if (contact.setIndex === b2SetType.b2_awakeSet && contact.colorIndex !== B2_NULL_INDEX)\r\n    {\r\n        // contact lives in constraint graph\r\n        console.assert(0 <= contact.colorIndex && contact.colorIndex < b2_graphColorCount);\r\n        const color = world.constraintGraph.colors[contact.colorIndex];\r\n        console.assert(0 <= contact.localIndex && contact.localIndex < color.contacts.count);\r\n\r\n        const sim = color.contacts.data[contact.localIndex];\r\n\r\n        // console.assert(sim._bodyIdA !== B2_NULL_INDEX); //, (new Error().stack));\r\n        // console.assert(sim._bodyIdB !== B2_NULL_INDEX); //, (new Error().stack));\r\n        return sim;\r\n    }\r\n\r\n    // contact lives in the solver set contacts list\r\n    const set = world.solverSetArray[contact.setIndex];\r\n    console.assert(0 <= contact.localIndex && contact.localIndex <= set.contacts.count);\r\n\r\n    return set.contacts.data[contact.localIndex];\r\n}\r\n\r\nexport function b2ShouldShapesCollide(filterA, filterB)\r\n{\r\n    if (filterA.groupIndex === filterB.groupIndex && filterA.groupIndex !== 0)\r\n    {\r\n        return filterA.groupIndex > 0;\r\n    }\r\n\r\n    const collide = (filterA.maskBits & filterB.categoryBits) !== 0 && (filterA.categoryBits & filterB.maskBits) !== 0;\r\n\r\n    return collide;\r\n}\r\n\r\nfunction b2TestShapeOverlap(shapeA, xfA, shapeB, xfB, cache)\r\n{\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = b2MakeShapeDistanceProxy(shapeA);\r\n    input.proxyB = b2MakeShapeDistanceProxy(shapeB);\r\n    input.transformA = xfA;\r\n    input.transformB = xfB;\r\n    input.useRadii = true;\r\n\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    return output.distance < 10.0 * eps;\r\n}\r\n\r\nconst oldManifold = new b2Manifold();\r\n\r\nexport function b2UpdateContact(world, contactSim, shapeA, transformA, centerOffsetA, shapeB, transformB, centerOffsetB)\r\n{\r\n    let touching;\r\n\r\n    // Is this contact a sensor?\r\n    if (shapeA.isSensor || shapeB.isSensor)\r\n    {\r\n        // Sensors don't generate manifolds or hit events\r\n        touching = b2TestShapeOverlap(shapeA, transformA, shapeB, transformB, contactSim.cache);\r\n    }\r\n    else\r\n    {\r\n        // Copy the existing manifold for matching just below...\r\n        contactSim.manifold.copyTo(oldManifold);\r\n\r\n        // Compute new manifold\r\n        const fcn = s_registers[shapeA.type][shapeB.type].fcn;\r\n\r\n        // Re-use the existing manifold\r\n        fcn(shapeA, transformA, shapeB, transformB, contactSim.cache, contactSim.manifold);\r\n\r\n        const pointCount = contactSim.manifold.pointCount;\r\n        touching = pointCount > 0;\r\n\r\n        if ( touching && world.preSolveFcn && ( contactSim.simFlags & b2ContactSimFlags.b2_simEnablePreSolveEvents ) != 0 )\r\n        {\r\n            const shapeIdA = new b2ShapeId(shapeA.id + 1, world.worldId, shapeA.revision);\r\n            const shapeIdB = new b2ShapeId(shapeB.id + 1, world.worldId, shapeB.revision);\r\n\r\n            // this call assumes thread safety\r\n            touching = world.preSolveFcn( shapeIdA, shapeIdB, contactSim.manifold, world.preSolveContext );\r\n\r\n            if ( touching == false )\r\n            {\r\n                // disable contact\r\n                contactSim.manifold.pointCount = 0;\r\n            }\r\n        }\r\n\r\n        if (touching && (shapeA.enableHitEvents || shapeB.enableHitEvents))\r\n        {\r\n            contactSim.simFlags |= b2ContactSimFlags.b2_simEnableHitEvent;\r\n        }\r\n        else\r\n        {\r\n            contactSim.simFlags &= ~b2ContactSimFlags.b2_simEnableHitEvent;\r\n        }\r\n\r\n        // Match old contact ids to new contact ids and copy the\r\n        // stored impulses to warm start the solver.\r\n        for (let i = 0; i < pointCount; ++i)\r\n        {\r\n            const mp2 = contactSim.manifold.points[i];\r\n\r\n            // shift anchors to be center of mass relative\r\n            // mp2.anchorA = b2Sub(mp2.anchorA, centerOffsetA);\r\n            mp2.anchorAX -= centerOffsetA.x;\r\n            mp2.anchorAY -= centerOffsetA.y;\r\n\r\n            // mp2.anchorB = b2Sub(mp2.anchorB, centerOffsetB);\r\n            mp2.anchorBX -= centerOffsetB.x;\r\n            mp2.anchorBY -= centerOffsetB.y;\r\n\r\n            mp2.normalImpulse = 0.0;\r\n            mp2.tangentImpulse = 0.0;\r\n            mp2.maxNormalImpulse = 0.0;\r\n            mp2.normalVelocity = 0.0;\r\n            mp2.persisted = false;\r\n\r\n            const id2 = mp2.id;\r\n\r\n            for (let j = 0, l = oldManifold.pointCount; j < l; ++j)\r\n            {\r\n                const mp1 = oldManifold.points[j];\r\n\r\n                if (mp1.id === id2)\r\n                {\r\n                    mp2.normalImpulse = mp1.normalImpulse;\r\n                    mp2.tangentImpulse = mp1.tangentImpulse;\r\n                    mp2.persisted = true;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (touching)\r\n    {\r\n        contactSim.simFlags |= b2ContactSimFlags.b2_simTouchingFlag;\r\n    }\r\n    else\r\n    {\r\n        contactSim.simFlags &= ~b2ContactSimFlags.b2_simTouchingFlag;\r\n    }\r\n\r\n    return touching;\r\n}\r\n\r\nexport function b2ComputeManifold(shapeA, transformA, shapeB, transformB, manifold)\r\n{\r\n    const fcn = s_registers[shapeA.type][shapeB.type].fcn;\r\n    const cache = new b2DistanceCache();\r\n\r\n    return fcn( shapeA, transformA, shapeB, transformB, cache, manifold );\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nexport {\r\n    b2ContactFlags,\r\n    b2ContactSim, b2Contact, b2ContactEdge,\r\n    b2InitializeContactRegisters, b2CreateContact, b2DestroyContact, b2GetContactSim, b2ShouldShapesCollide, b2UpdateContact\r\n} from '../contact_c.js';\r\n\r\nexport const b2ContactSimFlags = {\r\n    b2_simTouchingFlag: 0x00010000,\r\n    b2_simDisjoint: 0x00020000,\r\n    b2_simStartedTouching: 0x00040000,\r\n    b2_simStoppedTouching: 0x00080000,\r\n    b2_simEnableHitEvent: 0x00100000,\r\n    b2_simEnablePreSolveEvents: 0x00200000,\r\n};\r\n\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport {\r\n    B2_SHAPE_PAIR_KEY,\r\n    b2AddKey,\r\n    b2ClearSet,\r\n    b2ContainsKey,\r\n    b2CreateSet,\r\n    b2DestroySet,\r\n    b2RemoveKey\r\n} from \"./include/table_h.js\";\r\nimport { b2AllocateStackItem, b2FreeStackItem } from \"./include/stack_allocator_h.js\";\r\nimport { b2CreateContact, b2ShouldShapesCollide } from \"./include/contact_h.js\";\r\nimport { b2DynamicTree, b2DynamicTree_GetUserData, b2DynamicTree_QueryAll } from \"./include/dynamic_tree_h.js\";\r\nimport {\r\n    b2DynamicTree_Create,\r\n    b2DynamicTree_CreateProxy,\r\n    b2DynamicTree_Destroy,\r\n    b2DynamicTree_DestroyProxy,\r\n    b2DynamicTree_EnlargeProxy,\r\n    b2DynamicTree_MoveProxy,\r\n    b2DynamicTree_Rebuild\r\n} from \"./include/dynamic_tree_h.js\";\r\nimport { b2GetBody, b2ShouldBodiesCollide } from \"./include/body_h.js\";\r\n\r\nimport { B2_NULL_INDEX } from \"./include/core_h.js\";\r\nimport { b2AABB_Overlaps } from \"./include/aabb_h.js\";\r\nimport { b2BodyType } from \"./include/types_h.js\";\r\nimport { b2ShapeId } from \"./include/id_h.js\";\r\nimport { b2ValidateSolverSets } from \"./world_c.js\";\r\n\r\n/**\r\n * @namespace Broadphase\r\n */\r\n\r\n/**\r\n * @description The broad-phase is used for computing pairs and performing volume queries and ray casts.\r\n * This broad-phase does not persist pairs. Instead, this reports potentially new pairs.\r\n * It is up to the client to consume the new pairs and to track subsequent overlap.\r\n */\r\nclass b2BroadPhase\r\n{\r\n    constructor()\r\n    {\r\n        this.trees = new Array(b2BodyType.b2_bodyTypeCount).fill().map(() => new b2DynamicTree());\r\n\r\n        // this.proxyCount = 0;\r\n        this.moveSet = null;\r\n        this.moveArray = null;\r\n        this.moveResults = null;\r\n        this.movePairs = null;\r\n        this.movePairCapacity = 0;\r\n        this.movePairIndex = 0;\r\n        this.pairSet = null;\r\n    }\r\n}\r\n\r\n// Store the proxy type in the lower 2 bits of the proxy key. This leaves 30 bits for the id.\r\nconst B2_PROXY_TYPE = (KEY) => KEY & 3;\r\nconst B2_PROXY_ID = (KEY) => KEY >> 2;\r\nconst B2_PROXY_KEY = (ID, TYPE) => (ID << 2) | TYPE;\r\n\r\n// This is what triggers new contact pairs to be created\r\n// Warning: this must be called in deterministic order\r\n// PJB: possible bug in C code, queryProxy is not uint64_t\r\n// PJB: note that return from b2AddKey is 'false' when the key is added... it returns the 'already added' status\r\nfunction b2BufferMove(bp, queryProxy)\r\n{\r\n    // Adding 1 because 0 is the sentinel\r\n    if (!b2AddKey(bp.moveSet, queryProxy + 1))\r\n    {\r\n        bp.moveArray.push(queryProxy);\r\n    }\r\n}\r\n\r\nfunction b2CreateBroadPhase(bp)\r\n{\r\n    // bp.proxyCount = 0;\r\n    bp.moveSet = b2CreateSet();\r\n    bp.moveArray = [];\r\n    bp.moveResults = null;\r\n    bp.movePairs = null;\r\n    bp.movePairCapacity = 0;\r\n    bp.movePairIndex = 0;\r\n    bp.pairSet = b2CreateSet();\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        bp.trees[i] = b2DynamicTree_Create();\r\n    }\r\n}\r\n\r\nfunction b2DestroyBroadPhase(bp)\r\n{\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Destroy(bp.trees[i]);\r\n    }\r\n\r\n    b2DestroySet(bp.moveSet);\r\n    bp.moveArray = null;\r\n    b2DestroySet(bp.pairSet);\r\n\r\n    Object.keys(bp).forEach(key => delete bp[key]);\r\n}\r\n\r\nfunction b2UnBufferMove(bp, proxyKey)\r\n{\r\n    const found = b2RemoveKey(bp.moveSet, proxyKey + 1);\r\n\r\n    if (found)\r\n    {\r\n        const count = bp.moveArray.length;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            if (bp.moveArray[i] === proxyKey)\r\n            {\r\n                // swap and pop to remove that element\r\n                bp.moveArray[i] = bp.moveArray[count - 1];\r\n                bp.moveArray.pop();\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction b2BroadPhase_CreateProxy(bp, proxyType, aabb, categoryBits, shapeIndex, forcePairCreation)\r\n{\r\n    console.assert(0 <= proxyType && proxyType < b2BodyType.b2_bodyTypeCount);\r\n    const proxyId = b2DynamicTree_CreateProxy(bp.trees[proxyType], aabb, categoryBits, shapeIndex);\r\n    const proxyKey = B2_PROXY_KEY(proxyId, proxyType);\r\n\r\n    if (proxyType !== b2BodyType.b2_staticBody || forcePairCreation)\r\n    {\r\n        b2BufferMove(bp, proxyKey);\r\n    }\r\n\r\n    return proxyKey;\r\n}\r\n\r\nfunction b2BroadPhase_DestroyProxy(bp, proxyKey)\r\n{\r\n    console.assert(bp.moveArray.length === bp.moveSet.size);\r\n    b2UnBufferMove(bp, proxyKey);\r\n\r\n    // --bp.proxyCount;\r\n\r\n    const proxyType = B2_PROXY_TYPE(proxyKey);\r\n    const proxyId = B2_PROXY_ID(proxyKey);\r\n\r\n    console.assert(0 <= proxyType && proxyType <= b2BodyType.b2_bodyTypeCount);\r\n    b2DynamicTree_DestroyProxy(bp.trees[proxyType], proxyId);\r\n}\r\n\r\nfunction b2BroadPhase_MoveProxy(bp, proxyKey, aabb)\r\n{\r\n    const proxyType = B2_PROXY_TYPE(proxyKey);\r\n    const proxyId = B2_PROXY_ID(proxyKey);\r\n\r\n    b2DynamicTree_MoveProxy(bp.trees[proxyType], proxyId, aabb);\r\n    b2BufferMove(bp, proxyKey);\r\n}\r\n\r\nfunction b2BroadPhase_EnlargeProxy(bp, proxyKey, aabb)\r\n{\r\n    console.assert(proxyKey !== B2_NULL_INDEX);\r\n    const typeIndex = B2_PROXY_TYPE(proxyKey);\r\n    const proxyId = B2_PROXY_ID(proxyKey);\r\n\r\n    console.assert(typeIndex !== b2BodyType.b2_staticBody);\r\n\r\n    b2DynamicTree_EnlargeProxy(bp.trees[typeIndex], proxyId, aabb);\r\n    b2BufferMove(bp, proxyKey);\r\n}\r\n\r\nclass b2MovePair\r\n{\r\n    constructor()\r\n    {\r\n        this.shapeIndexA = 0;\r\n        this.shapeIndexB = 0;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass b2MoveResult\r\n{\r\n    constructor()\r\n    {\r\n        this.pairList = null;\r\n    }\r\n}\r\n\r\nclass b2QueryPairContext\r\n{\r\n    constructor()\r\n    {\r\n        this.world = null;\r\n        this.moveResult = null;     // b2MoveResult\r\n        this.queryTreeType = 0;\r\n        this.queryProxyKey = 0;\r\n        this.queryShapeIndex = 0;\r\n    }\r\n}\r\n\r\nexport function b2PairQueryCallback(proxyId, shapeId, context)\r\n{\r\n    const queryContext = context;\r\n    const bp = queryContext.world.broadPhase;\r\n\r\n    const proxyKey = B2_PROXY_KEY(proxyId, queryContext.queryTreeType);\r\n\r\n    if (proxyKey === queryContext.queryProxyKey)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (queryContext.queryTreeType !== b2BodyType.b2_staticBody)\r\n    {\r\n        if (proxyKey < queryContext.queryProxyKey && b2ContainsKey(bp.moveSet, proxyKey + 1))\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    const pairKey = B2_SHAPE_PAIR_KEY(shapeId, queryContext.queryShapeIndex);\r\n\r\n    if (b2ContainsKey(bp.pairSet, pairKey)) // key in set.items\r\n    {\r\n        return true;\r\n    }\r\n\r\n    let shapeIdA, shapeIdB;\r\n\r\n    if (proxyKey < queryContext.queryProxyKey)\r\n    {\r\n        shapeIdA = shapeId;\r\n        shapeIdB = queryContext.queryShapeIndex;\r\n    }\r\n    else\r\n    {\r\n        shapeIdA = queryContext.queryShapeIndex;\r\n        shapeIdB = shapeId;\r\n    }\r\n\r\n    const world = queryContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeIdA);\r\n    // b2CheckId(world.shapeArray, shapeIdB);\r\n\r\n    const shapeA = world.shapeArray[shapeIdA];\r\n    const shapeB = world.shapeArray[shapeIdB];\r\n\r\n    const bodyIdA = shapeA.bodyId;\r\n    const bodyIdB = shapeB.bodyId;\r\n\r\n    if (bodyIdA === bodyIdB)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (!b2ShouldShapesCollide(shapeA.filter, shapeB.filter))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (shapeA.isSensor && shapeB.isSensor)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const bodyA = b2GetBody(world, bodyIdA);\r\n    const bodyB = b2GetBody(world, bodyIdB);\r\n\r\n    if (!b2ShouldBodiesCollide(world, bodyA, bodyB))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const customFilterFcn = queryContext.world.customFilterFcn;\r\n\r\n    if (customFilterFcn)\r\n    {\r\n        const idA = new b2ShapeId(shapeIdA + 1, world.worldId, shapeA.revision);\r\n        const idB = new b2ShapeId(shapeIdB + 1, world.worldId, shapeB.revision);\r\n        const shouldCollide = customFilterFcn(idA, idB, queryContext.world.customFilterContext);\r\n\r\n        if (!shouldCollide)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    const pairIndex = bp.movePairIndex++;\r\n\r\n    let pair;\r\n\r\n    if (pairIndex < bp.movePairCapacity)\r\n    {\r\n        pair = bp.movePairs[pairIndex];\r\n    }\r\n    else\r\n    {\r\n        pair = new b2MovePair();\r\n    }\r\n\r\n    pair.shapeIndexA = shapeIdA;\r\n    pair.shapeIndexB = shapeIdB;\r\n    pair.next = queryContext.moveResult.pairList;\r\n    queryContext.moveResult.pairList = pair;\r\n\r\n    return true;\r\n}\r\n\r\nfunction b2UpdateBroadPhasePairs(world)\r\n{\r\n    const bp = world.broadPhase;\r\n    const moveCount = bp.moveArray.length;\r\n    \r\n    if (moveCount === 0) { return; }\r\n\r\n    const alloc = world.stackAllocator;\r\n    bp.moveResults = b2AllocateStackItem(alloc, moveCount, \"move results\", () => new b2MoveResult());\r\n    \r\n    b2FindPairsTask(0, moveCount, world);\r\n\r\n    const shapes = world.shapeArray;\r\n\r\n    for (const result of bp.moveResults)\r\n    {\r\n        for (let pair = result.pairList; pair; pair = pair.next)\r\n        {\r\n            b2CreateContact(world, shapes[pair.shapeIndexA], shapes[pair.shapeIndexB]);\r\n        }\r\n    }\r\n\r\n    bp.moveArray.length = 0;\r\n    b2ClearSet(bp.moveSet);\r\n    b2FreeStackItem(alloc, bp.moveResults);\r\n    bp.moveResults = null;\r\n\r\n    b2ValidateSolverSets(world);\r\n}\r\n\r\nfunction b2FindPairsTask(startIndex, endIndex, world)\r\n{\r\n    const bp = world.broadPhase;\r\n    const queryContext = new b2QueryPairContext();\r\n    queryContext.world = world;\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const proxyKey = bp.moveArray[i];\r\n\r\n        if (proxyKey === B2_NULL_INDEX) { continue; }\r\n\r\n        const proxyType = B2_PROXY_TYPE(proxyKey);  // possible values = 0,1,2,3\r\n        const proxyId = B2_PROXY_ID(proxyKey);\r\n        queryContext.queryProxyKey = proxyKey;\r\n        \r\n        const baseTree = bp.trees[proxyType];\r\n        const fatAABB = baseTree.nodes[proxyId].aabb;   // b2DynamicTree_GetAABB(baseTree, proxyId);\r\n        queryContext.queryShapeIndex = b2DynamicTree_GetUserData(baseTree, proxyId);\r\n        \r\n        const moveResult = bp.moveResults[i];\r\n        moveResult.pairList = null;\r\n        queryContext.moveResult = moveResult;\r\n\r\n        if (proxyType === b2BodyType.b2_dynamicBody)\r\n        {\r\n            b2QueryTreeForPairs(bp, fatAABB, queryContext, b2BodyType.b2_kinematicBody);\r\n            b2QueryTreeForPairs(bp, fatAABB, queryContext, b2BodyType.b2_staticBody);\r\n        }\r\n        \r\n        queryContext.queryTreeType = b2BodyType.b2_dynamicBody;\r\n        b2DynamicTree_QueryAll(bp.trees[b2BodyType.b2_dynamicBody], fatAABB, queryContext);\r\n    }\r\n}\r\n\r\nfunction b2QueryTreeForPairs(bp, fatAABB, queryContext, treeType)\r\n{\r\n    queryContext.queryTreeType = treeType;\r\n    b2DynamicTree_QueryAll(bp.trees[treeType], fatAABB, queryContext);\r\n}\r\n\r\nfunction b2BroadPhase_TestOverlap(bp, proxyKeyA, proxyKeyB)\r\n{\r\n    const typeIndexA = B2_PROXY_TYPE(proxyKeyA);\r\n    const proxyIdA = B2_PROXY_ID(proxyKeyA);\r\n    const typeIndexB = B2_PROXY_TYPE(proxyKeyB);\r\n    const proxyIdB = B2_PROXY_ID(proxyKeyB);\r\n\r\n    const aabbA = bp.trees[typeIndexA].nodes[proxyIdA].aabb; // b2DynamicTree_GetAABB(bp.trees[typeIndexA], proxyIdA);\r\n    const aabbB = bp.trees[typeIndexB].nodes[proxyIdB].aabb; // b2DynamicTree_GetAABB(bp.trees[typeIndexB], proxyIdB);\r\n\r\n    return b2AABB_Overlaps(aabbA, aabbB);\r\n}\r\n\r\nfunction b2BroadPhase_RebuildTrees(bp)\r\n{\r\n    b2DynamicTree_Rebuild(bp.trees[b2BodyType.b2_dynamicBody]);\r\n    b2DynamicTree_Rebuild(bp.trees[b2BodyType.b2_kinematicBody]);\r\n}\r\n\r\nfunction b2BroadPhase_GetShapeIndex(bp, proxyKey)\r\n{\r\n    const typeIndex = B2_PROXY_TYPE(proxyKey);\r\n    const proxyId = B2_PROXY_ID(proxyKey);\r\n\r\n    return b2DynamicTree_GetUserData(bp.trees[typeIndex], proxyId);\r\n}\r\n\r\nexport {\r\n    b2BroadPhase,\r\n    B2_PROXY_ID,\r\n    B2_PROXY_KEY,\r\n    B2_PROXY_TYPE,\r\n    b2BufferMove,\r\n    b2CreateBroadPhase,\r\n    b2DestroyBroadPhase,\r\n    b2BroadPhase_CreateProxy,\r\n    b2BroadPhase_DestroyProxy,\r\n    b2BroadPhase_MoveProxy,\r\n    b2BroadPhase_EnlargeProxy,\r\n    b2BroadPhase_RebuildTrees,\r\n    b2BroadPhase_GetShapeIndex,\r\n    b2UpdateBroadPhasePairs,\r\n    b2BroadPhase_TestOverlap,\r\n};\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_DEFAULT_MASK_BITS, b2DistanceInput, b2RayCastInput, b2ShapeCastInput } from './include/collision_h.js';\r\nimport { B2_NULL_INDEX, b2_graphColorCount, b2_linearSlop } from './include/core_h.js';\r\nimport { B2_PROXY_TYPE, b2BroadPhase, b2BroadPhase_RebuildTrees, b2CreateBroadPhase, b2DestroyBroadPhase, b2UpdateBroadPhasePairs } from './include/broad_phase_h.js';\r\nimport {\r\n    GlobalDebug,\r\n    b2AABB,\r\n    b2AABB_IsValid,\r\n    b2ClampFloat,\r\n    b2Cross,\r\n    b2IsValid,\r\n    b2ManifoldPointWhere,\r\n    b2MulAdd,\r\n    b2MulSV,\r\n    b2Normalize,\r\n    b2RightPerp,\r\n    b2Rot,\r\n    b2Rot2Where,\r\n    b2Rot_IsValid,\r\n    b2Sub,\r\n    b2Transform,\r\n    b2TransformPoint,\r\n    b2TransformPointOut,\r\n    b2TransformPointOutXf,\r\n    b2Vec2,\r\n    b2Vec2Where,\r\n    b2Vec2_IsValid\r\n} from './include/math_functions_h.js';\r\nimport { b2AddContact, b2RemoveContact } from './include/block_array_h.js';\r\nimport { b2AddContactToGraph, b2RemoveContactFromGraph } from './include/constraint_graph_h.js';\r\nimport { b2AllocId, b2CreateIdPool, b2DestroyIdPool, b2GetIdCapacity, b2GetIdCount } from './include/id_pool_h.js';\r\nimport { b2BitSet, b2CreateBitSet, b2DestroyBitSet, b2InPlaceUnion, b2SetBit, b2SetBitCountAndClear } from './include/bitset_h.js';\r\nimport {\r\n    b2BodyEvents,\r\n    b2BodyType,\r\n    b2ContactBeginTouchEvent,\r\n    b2ContactEndTouchEvent,\r\n    b2ContactEvents,\r\n    b2RayResult,\r\n    b2SensorBeginTouchEvent,\r\n    b2SensorEndTouchEvent,\r\n    b2SensorEvents,\r\n    b2ShapeType,\r\n    b2Validation\r\n} from './include/types_h.js';\r\nimport { b2BodyId, b2ShapeId, b2WorldId } from './include/id_h.js';\r\nimport { b2ComputeCapsuleAABB, b2ComputeCircleAABB, b2ComputePolygonAABB } from './include/geometry_h.js';\r\nimport { b2ConstraintGraph, b2CreateGraph, b2DestroyGraph, b2_overflowIndex } from './include/constraint_graph_h.js';\r\nimport { b2Contact, b2ContactFlags, b2ContactSimFlags, b2DestroyContact, b2GetContactSim, b2InitializeContactRegisters, b2UpdateContact } from './include/contact_h.js';\r\nimport { b2CreateStackAllocator, b2DestroyStackAllocator, b2GetStackAllocation, b2StackAllocator } from './include/stack_allocator_h.js';\r\nimport { b2DestroySolverSet, b2SolverSet, b2WakeSolverSet } from './include/solver_set_h.js';\r\nimport { b2DrawJoint, b2GetJointSim } from './include/joint_h.js';\r\nimport { b2DynamicTree_Query, b2DynamicTree_RayCast, b2DynamicTree_ShapeCast } from './include/dynamic_tree_h.js';\r\nimport { b2GetBody, b2GetBodySim, b2GetBodyTransformQuick, b2WakeBody } from './include/body_h.js';\r\nimport { b2GetShapeCentroid, b2GetShapePerimeter, b2MakeShapeDistanceProxy, b2RayCastShape, b2ShapeCastShape } from './include/shape_h.js';\r\nimport { b2LinkContact, b2UnlinkContact } from './include/island_h.js';\r\nimport { b2MakeProxy, b2ShapeDistance } from './include/distance_h.js';\r\nimport { b2MakeSoft, b2Solve, b2StepContext } from './include/solver_h.js';\r\n\r\nimport { b2AABB_Overlaps } from './include/aabb_h.js';\r\nimport { b2CTZ64 } from './include/ctz_h.js';\r\nimport { b2DistanceCache } from './include/collision_h.js';\r\nimport { b2HexColor } from './include/types_h.js';\r\n\r\n/**\r\n * @namespace World\r\n */\r\n\r\n/**\r\n * @import {b2WorldDef, b2DebugDraw, b2QueryFilter} from './include/types_h.js'\r\n * @import {b2ChainId, b2JointId} from './include/id_h.js'\r\n * @import {b2PreSolveFcn, b2CastResultFcn, b2OverlapResultFcn, b2CustomFilterFcn} from './include/types_h.js'\r\n * @import {b2TreeStats, b2Circle, b2Capsule, b2Polygon} from './include/collision_h.js'\r\n */\r\n\r\nexport const B2_MAX_WORLDS = 32;\r\n\r\nexport const b2SetType =\r\n{\r\n    b2_staticSet: 0,\r\n    b2_disabledSet: 1,\r\n    b2_awakeSet: 2,\r\n    b2_firstSleepingSet: 3,\r\n};\r\n\r\nexport class b2World\r\n{\r\n    stackAllocator = new b2StackAllocator();\r\n    broadPhase = new b2BroadPhase();\r\n    constraintGraph = new b2ConstraintGraph();\r\n\r\n    // bodyIdPool = new b2IdPool();\r\n    bodyArray = [];\r\n\r\n    // solverSetIdPool = new b2IdPool();\r\n\r\n    /** @type {b2SolverSet[]} */\r\n    solverSetArray = [];\r\n\r\n    // jointIdPool = new b2IdPool();\r\n    jointArray = [];\r\n\r\n    // contactIdPool = new b2IdPool();\r\n\r\n    /** @type {b2Contact[]} */\r\n    contactArray = [];\r\n\r\n    // islandIdPool = new b2IdPool();\r\n    islandArray = [];\r\n\r\n    // shapeIdPool = new b2IdPool();\r\n    // chainIdPool = new b2IdPool();\r\n    shapeArray = [];\r\n    chainArray = [];\r\n    taskContextArray = [];\r\n    bodyMoveEventArray = [];\r\n    sensorBeginEventArray = [];\r\n    sensorEndEventArray = [];\r\n    contactBeginArray = [];\r\n    contactEndArray = [];\r\n    contactHitArray = [];\r\n    debugBodySet = new b2BitSet();\r\n    debugJointSet = new b2BitSet();\r\n    debugContactSet = new b2BitSet();\r\n    stepIndex = 0;\r\n    splitIslandId = 0;\r\n    gravity = new b2Vec2(0, 0);\r\n    hitEventThreshold = 0;\r\n    restitutionThreshold = 0;\r\n    maxLinearVelocity = 0;\r\n    contactPushoutVelocity = 0;\r\n    contactHertz = 0;\r\n    contactDampingRatio = 0;\r\n    jointHertz = 0;\r\n    jointDampingRatio = 0;\r\n    revision = 0;\r\n\r\n    // profile = new b2Profile();\r\n    preSolveFcn = null;\r\n    preSolveContext = null;\r\n    customFilterFcn = null;\r\n    customFilterContext = null;\r\n    workerCount = 0;\r\n    userTaskContext = null;\r\n    userTreeTask = null;\r\n    inv_h = 0;\r\n    worldId = new b2WorldId();\r\n    enableSleep = true;\r\n    locked = false;\r\n    enableWarmStarting = false;\r\n    enableContinuous = false;\r\n    inUse = false;\r\n}\r\n\r\nclass WorldOverlapContext\r\n{\r\n    constructor()\r\n    {\r\n        this.world = null;\r\n        this.fcn = null;\r\n        this.filter = null;\r\n        this.proxy = null;\r\n        this.transform = null;\r\n        this.userContext = null;\r\n    }\r\n}\r\n\r\nclass WorldRayCastContext\r\n{\r\n    constructor()\r\n    {\r\n        this.world = null;\r\n        this.fcn = null;\r\n        this.filter = null;\r\n        this.fraction = 0.0;\r\n        this.userContext = null;\r\n    }\r\n}\r\n\r\n// Per thread task storage\r\n// TODO: the JS conversion has reduced this to single threaded, code mostly left intact temporarily while we get things working.\r\nexport class b2TaskContext\r\n{\r\n    constructor()\r\n    {\r\n        // These bits align with the b2ConstraintGraph::contactBlocks and signal a change in contact status\r\n        this.contactStateBitSet = new b2BitSet();\r\n\r\n        // Used to track bodies with shapes that have enlarged AABBs. This avoids having a bit array\r\n        // that is very large when there are many static shapes.\r\n        this.enlargedSimBitSet = new b2BitSet();\r\n\r\n        // Used to put islands to sleep\r\n        this.awakeIslandBitSet = new b2BitSet();\r\n\r\n        // Per worker split island candidate\r\n        this.splitSleepTime = 0;\r\n        this.splitIslandId = B2_NULL_INDEX;\r\n    }\r\n}\r\n\r\nexport function b2GetWorldFromId(id)\r\n{\r\n    console.assert(1 <= id.index1 && id.index1 <= B2_MAX_WORLDS);\r\n    const world = b2_worlds[id.index1 - 1];\r\n    console.assert(id.index1 === world.worldId + 1);\r\n    console.assert(id.revision === world.revision);\r\n\r\n    return world;\r\n}\r\n\r\nexport function b2GetWorld(index)\r\n{\r\n    console.assert(0 <= index && index < B2_MAX_WORLDS);\r\n    const world = b2_worlds[index];\r\n    console.assert(world.worldId === index);\r\n\r\n    return world;\r\n}\r\n\r\nexport function b2GetWorldLocked(index)\r\n{\r\n    console.assert(0 <= index && index < B2_MAX_WORLDS);\r\n    const world = b2_worlds[index];\r\n    console.assert(world.worldId === index);\r\n\r\n    if (world.locked)\r\n    {\r\n        console.assert(false);\r\n\r\n        return null;\r\n    }\r\n\r\n    return world;\r\n}\r\n\r\n/** @global */\r\nlet b2_worlds = null;\r\n\r\n/**\r\n * @function b2CreateWorldArray\r\n * @description\r\n * Initializes a global array of Box2D world instances if it hasn't been created yet.\r\n * Creates B2_MAX_WORLDS number of world instances and marks them as not in use.\r\n * If the array already exists, the function returns without doing anything.\r\n * @returns {void}\r\n * @see b2World\r\n */\r\nexport function b2CreateWorldArray()\r\n{\r\n    // don't create a new one if it already exists\r\n    if (b2_worlds != null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    b2_worlds = [];\r\n\r\n    for (let i = 0; i < B2_MAX_WORLDS; i++)\r\n    {\r\n        b2_worlds[i] = new b2World();\r\n        b2_worlds[i].inUse = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2CreateWorld\r\n * @param {b2WorldDef} def - World definition object containing initialization parameters including:\r\n * gravity, hitEventThreshold, restitutionThreshold, maximumLinearVelocity,\r\n * contactPushoutVelocity, contactHertz, contactDampingRatio, jointHertz,\r\n * jointDampingRatio, enableSleep, enableContinuous\r\n * @returns {b2WorldId} A world identifier object containing:\r\n * - index: number (worldId + 1)\r\n * - revision: number (world revision number)\r\n * @description\r\n * Creates and initializes a new Box2D physics world with the specified parameters.\r\n * The function allocates memory for physics entities (bodies, joints, contacts),\r\n * initializes contact registers, creates necessary pools and arrays, and sets up\r\n * the world properties according to the provided definition.\r\n * @throws {Error} Returns a null world ID (0,0) if no world slots are available\r\n */\r\nexport function b2CreateWorld(def /* b2WorldDef */)\r\n{\r\n    // _Static_assert is not applicable in JS, so we'll skip it\r\n\r\n    let worldId = B2_NULL_INDEX;\r\n\r\n    for (let i = 0; i < b2_worlds.length; ++i)\r\n    {\r\n        if (b2_worlds[i].inUse === false)\r\n        {\r\n            worldId = i;\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (worldId === B2_NULL_INDEX)\r\n    {\r\n        return new b2WorldId(0, 0);\r\n    }\r\n\r\n    b2InitializeContactRegisters();\r\n\r\n    const world = b2_worlds[worldId];\r\n    const revision = world.revision;\r\n\r\n    world.worldId = worldId;\r\n    world.revision = revision;\r\n    world.inUse = true;\r\n\r\n    world.stackAllocator = b2CreateStackAllocator();\r\n    b2CreateBroadPhase(world.broadPhase);\r\n    world.constraintGraph = b2CreateGraph(world.constraintGraph, 16);\r\n\r\n    // pools\r\n    world.bodyIdPool = b2CreateIdPool(\"body\");\r\n    world.bodyArray = [];\r\n    world.solverSetArray = [];\r\n\r\n    // add empty static, active, and disabled body sets\r\n    world.solverSetIdPool = b2CreateIdPool(\"solverSet\");\r\n    let set;\r\n\r\n    // static set\r\n    set = new b2SolverSet();\r\n    set.setIndex = b2AllocId(world.solverSetIdPool);\r\n    world.solverSetArray.push(set);\r\n    console.assert(world.solverSetArray[b2SetType.b2_staticSet].setIndex === b2SetType.b2_staticSet);\r\n\r\n    // disabled set\r\n    set = new b2SolverSet();\r\n    set.setIndex = b2AllocId(world.solverSetIdPool);\r\n    world.solverSetArray.push(set);\r\n    console.assert(world.solverSetArray[b2SetType.b2_disabledSet].setIndex === b2SetType.b2_disabledSet);\r\n\r\n    // awake set\r\n    set = new b2SolverSet();\r\n    set.setIndex = b2AllocId(world.solverSetIdPool);\r\n    world.solverSetArray.push(set);\r\n    console.assert(world.solverSetArray[b2SetType.b2_awakeSet].setIndex === b2SetType.b2_awakeSet);\r\n\r\n    world.shapeIdPool = b2CreateIdPool(\"shapeId\");\r\n    world.shapeArray = [];\r\n\r\n    world.chainIdPool = b2CreateIdPool(\"chainId\");\r\n    world.chainArray = [];\r\n\r\n    world.contactIdPool = b2CreateIdPool(\"contactId\");\r\n    world.contactArray = [];\r\n\r\n    // PJB: allocate some space at the start to reduce the spike in b2CreateContact later\r\n    for (let i = 0; i < 4096; i++)\r\n    {\r\n        world.contactArray.push(new b2Contact());\r\n    }\r\n\r\n    world.jointIdPool = b2CreateIdPool(\"jointId\");\r\n    world.jointArray = [];\r\n\r\n    world.islandIdPool = b2CreateIdPool(\"islandId\");\r\n    world.islandArray = [];\r\n\r\n    world.bodyMoveEventArray = [];\r\n    world.sensorBeginEventArray = [];\r\n    world.sensorEndEventArray = [];\r\n    world.contactBeginArray = [];\r\n    world.contactEndArray = [];\r\n    world.contactHitArray = [];\r\n\r\n    world.stepIndex = 0;\r\n    world.splitIslandId = B2_NULL_INDEX;\r\n    world.gravity = def.gravity;\r\n    world.hitEventThreshold = def.hitEventThreshold;\r\n    world.restitutionThreshold = def.restitutionThreshold;\r\n    world.maxLinearVelocity = def.maximumLinearVelocity;\r\n    world.contactPushoutVelocity = def.contactPushoutVelocity;\r\n    world.contactHertz = def.contactHertz;\r\n    world.contactDampingRatio = def.contactDampingRatio;\r\n    world.jointHertz = def.jointHertz;\r\n    world.jointDampingRatio = def.jointDampingRatio;\r\n    world.enableSleep = def.enableSleep;\r\n    world.locked = false;\r\n    world.enableWarmStarting = true;\r\n    world.enableContinuous = def.enableContinuous;\r\n    world.userTreeTask = null;\r\n\r\n    world.workerCount = 1;\r\n    world.userTaskContext = null;\r\n\r\n    world.taskContextArray = [];\r\n\r\n    for (let i = 0; i < world.workerCount; ++i)\r\n    {\r\n        const context = new b2TaskContext();\r\n        context.contactStateBitSet = b2CreateBitSet(1024);\r\n        context.enlargedSimBitSet = b2CreateBitSet(256),\r\n        context.awakeIslandBitSet = b2CreateBitSet(256);\r\n        world.taskContextArray[i] = context;\r\n    }\r\n\r\n    world.debugBodySet = b2CreateBitSet(256);\r\n    world.debugJointSet = b2CreateBitSet(256);\r\n    world.debugContactSet = b2CreateBitSet(256);\r\n\r\n    // add one to worldId so that 0 represents a null b2WorldId\r\n    return new b2WorldId(worldId + 1, world.revision);\r\n}\r\n\r\n/**\r\n * @function b2DestroyWorld\r\n * @description\r\n * Destroys a Box2D world instance and all its associated resources, including debug sets,\r\n * task contexts, event arrays, chains, bodies, shapes, contacts, joints, islands,\r\n * solver sets, constraint graph, broad phase, ID pools, and stack allocator.\r\n * Creates a new empty world instance with an incremented revision number.\r\n * @param {b2WorldId} worldId - The ID of the world to destroy\r\n * @returns {void}\r\n * @throws {Error} Throws an assertion error if a null chain has non-null shape indices\r\n */\r\nexport function b2DestroyWorld(worldId)\r\n{\r\n    let world = b2GetWorldFromId(worldId);\r\n\r\n    b2DestroyBitSet(world.debugBodySet);\r\n    b2DestroyBitSet(world.debugJointSet);\r\n    b2DestroyBitSet(world.debugContactSet);\r\n\r\n    for (let i = 0; i < world.workerCount; ++i)\r\n    {\r\n        b2DestroyBitSet(world.taskContextArray[i].contactStateBitSet);\r\n        b2DestroyBitSet(world.taskContextArray[i].enlargedSimBitSet);\r\n        b2DestroyBitSet(world.taskContextArray[i].awakeIslandBitSet);\r\n    }\r\n\r\n    world.taskContextArray = null;\r\n\r\n    world.bodyMoveEventArray = null;\r\n    world.sensorBeginEventArray = null;\r\n    world.sensorEndEventArray = null;\r\n    world.contactBeginArray = null;\r\n    world.contactEndArray = null;\r\n    world.contactHitArray = null;\r\n\r\n    const chainCapacity = world.chainArray.length;\r\n\r\n    for (let i = 0; i < chainCapacity; ++i)\r\n    {\r\n        const chain = world.chainArray[i];\r\n\r\n        if (chain.id !== B2_NULL_INDEX)\r\n        {\r\n            chain.shapeIndices = null;\r\n        }\r\n        else\r\n        {\r\n            console.assert(chain.shapeIndices === null);\r\n        }\r\n    }\r\n\r\n    world.bodyArray = null;\r\n    world.shapeArray = null;\r\n    world.chainArray = null;\r\n    world.contactArray = null;\r\n    world.jointArray = null;\r\n    world.islandArray = null;\r\n\r\n    const setCapacity = world.solverSetArray.length;\r\n\r\n    for (let i = 0; i < setCapacity; ++i)\r\n    {\r\n        const set = world.solverSetArray[i];\r\n\r\n        if (set.setIndex !== B2_NULL_INDEX)\r\n        {\r\n            b2DestroySolverSet(world, i);\r\n        }\r\n    }\r\n\r\n    // b2DestroyArray(world.solverSetArray);\r\n    world.solverSetArray = null;\r\n\r\n    b2DestroyGraph(world.constraintGraph);\r\n    b2DestroyBroadPhase(world.broadPhase);\r\n\r\n    b2DestroyIdPool(world.bodyIdPool);\r\n    b2DestroyIdPool(world.shapeIdPool);\r\n    b2DestroyIdPool(world.chainIdPool);\r\n    b2DestroyIdPool(world.contactIdPool);\r\n    b2DestroyIdPool(world.jointIdPool);\r\n    b2DestroyIdPool(world.islandIdPool);\r\n    b2DestroyIdPool(world.solverSetIdPool);\r\n\r\n    b2DestroyStackAllocator(world.stackAllocator);\r\n\r\n    // Wipe world but preserve revision\r\n    const revision = world.revision;\r\n    world = new b2World();\r\n    world.worldId = B2_NULL_INDEX;\r\n    world.revision = revision + 1;\r\n}\r\n\r\nconst centerOffsetA = new b2Vec2();\r\nconst centerOffsetB = new b2Vec2();\r\n\r\nfunction b2CollideTask(startIndex, endIndex, threadIndex, context)\r\n{\r\n    // b2TracyCZoneNC(collide_task, \"Collide Task\", b2HexColor.b2_colorDodgerBlue, true);\r\n\r\n    const stepContext = context;\r\n    const world = stepContext.world;\r\n    console.assert(threadIndex < world.workerCount);\r\n    const taskContext = world.taskContextArray[threadIndex];\r\n    const contactSims = stepContext.contacts;\r\n    const shapes = world.shapeArray;\r\n    const bodies = world.bodyArray;\r\n\r\n    console.assert(startIndex < endIndex);\r\n\r\n    for (let i = startIndex; i < endIndex; ++i)\r\n    {\r\n        const contactSim = contactSims[i];\r\n\r\n        const contactId = contactSim.contactId;\r\n\r\n        const shapeA = shapes[contactSim.shapeIdA];\r\n        const shapeB = shapes[contactSim.shapeIdB];\r\n\r\n        // Do proxies still overlap?  (Without this check, polygon collision increases from 1200 to 6400 both max... not as much as I expected for 1000 object tumbler)\r\n        const overlap = b2AABB_Overlaps(shapeA.fatAABB, shapeB.fatAABB);\r\n\r\n        if (!overlap)\r\n        {\r\n            contactSim.simFlags |= b2ContactSimFlags.b2_simDisjoint;\r\n            contactSim.simFlags &= ~b2ContactSimFlags.b2_simTouchingFlag;\r\n            b2SetBit(taskContext.contactStateBitSet, contactId);\r\n        }\r\n        else\r\n        {\r\n            const wasTouching = (contactSim.simFlags & b2ContactSimFlags.b2_simTouchingFlag) !== 0;\r\n\r\n            // Update contact respecting shape/body order (A,B)\r\n            const bodyA = bodies[shapeA.bodyId];\r\n            const bodyB = bodies[shapeB.bodyId];\r\n            const bodySimA = b2GetBodySim(world, bodyA);\r\n            const bodySimB = b2GetBodySim(world, bodyB);\r\n\r\n            // avoid cache misses in b2PrepareContactsTask\r\n            contactSim.bodySimIndexA = bodyA.setIndex === b2SetType.b2_awakeSet ? bodyA.localIndex : B2_NULL_INDEX;\r\n            contactSim.invMassA = bodySimA.invMass;\r\n            contactSim.invIA = bodySimA.invInertia;\r\n\r\n            contactSim.bodySimIndexB = bodyB.setIndex === b2SetType.b2_awakeSet ? bodyB.localIndex : B2_NULL_INDEX;\r\n            contactSim.invMassB = bodySimB.invMass;\r\n            contactSim.invIB = bodySimB.invInertia;\r\n\r\n            const transformA = bodySimA.transform;\r\n            const transformB = bodySimB.transform;\r\n\r\n            // let centerOffsetA = b2RotateVector(transformA.q, bodySimA.localCenter);\r\n            centerOffsetA.x = transformA.q.c * bodySimA.localCenter.x - transformA.q.s * bodySimA.localCenter.y;\r\n            centerOffsetA.y = transformA.q.s * bodySimA.localCenter.x + transformA.q.c * bodySimA.localCenter.y;\r\n\r\n            // let centerOffsetB = b2RotateVector(transformB.q, bodySimB.localCenter);\r\n            centerOffsetB.x = transformB.q.c * bodySimB.localCenter.x - transformB.q.s * bodySimB.localCenter.y;\r\n            centerOffsetB.y = transformB.q.s * bodySimB.localCenter.x + transformB.q.c * bodySimB.localCenter.y;\r\n\r\n            // This updates solid contacts and sensors\r\n            const touching = b2UpdateContact(world, contactSim, shapeA, transformA, centerOffsetA, shapeB, transformB, centerOffsetB);\r\n\r\n            // State changes that affect island connectivity. Also contact and sensor events.\r\n            if (touching && !wasTouching)\r\n            {\r\n                contactSim.simFlags |= b2ContactSimFlags.b2_simStartedTouching;\r\n                b2SetBit(taskContext.contactStateBitSet, contactId);\r\n            }\r\n            else if (!touching && wasTouching)\r\n            {\r\n                contactSim.simFlags |= b2ContactSimFlags.b2_simStoppedTouching;\r\n                b2SetBit(taskContext.contactStateBitSet, contactId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // b2TracyCZoneEnd(collide_task);\r\n}\r\n\r\nexport function b2AddNonTouchingContact(world, contact, contactSim)\r\n{\r\n    console.assert(contact.setIndex === b2SetType.b2_awakeSet);\r\n    const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    contact.colorIndex = B2_NULL_INDEX;\r\n    contact.localIndex = set.contacts.count;\r\n    const newContactSim = b2AddContact(set.contacts);\r\n    newContactSim.set(contactSim);\r\n}\r\n\r\nexport function b2RemoveNonTouchingContact(world, setIndex, localIndex)\r\n{\r\n    // (world.solverSetArray, setIndex);\r\n    const set = world.solverSetArray[setIndex];\r\n    const movedIndex = b2RemoveContact(set.contacts, localIndex);\r\n\r\n    if (movedIndex !== B2_NULL_INDEX)\r\n    {\r\n        const movedContactSim = set.contacts.data[localIndex];\r\n\r\n        // b2CheckIndex(world.contactArray, movedContactSim.contactId);\r\n        const movedContact = world.contactArray[movedContactSim.contactId];\r\n        console.assert(movedContact.setIndex === setIndex);\r\n        console.assert(movedContact.localIndex === movedIndex);\r\n        console.assert(movedContact.colorIndex === B2_NULL_INDEX);\r\n        movedContact.localIndex = localIndex;\r\n    }\r\n}\r\n\r\n// Narrow-phase collision\r\nexport function b2Collide(context)\r\n{\r\n    const world = context.world;\r\n\r\n    console.assert(world.workerCount > 0);\r\n\r\n    // b2TracyCZoneNC(collide, \"Collide\", b2HexColor.b2_colorDarkOrchid, true);\r\n\r\n    // Rebuild the collision tree for dynamic and kinematic bodies to keep their query performance good\r\n    b2BroadPhase_RebuildTrees(world.broadPhase);\r\n\r\n    // gather contacts into a single array\r\n    let contactCount = 0;\r\n    const graphColors = world.constraintGraph.colors;\r\n\r\n    for (let i = 0; i < b2_graphColorCount; ++i)\r\n    {\r\n        contactCount += graphColors[i].contacts.count;\r\n    }\r\n\r\n    const nonTouchingCount = world.solverSetArray[b2SetType.b2_awakeSet].contacts.count;\r\n    contactCount += nonTouchingCount;\r\n\r\n    if (contactCount == 0)\r\n    {\r\n        // b2TracyCZoneEnd(collide);\r\n        return;\r\n    }\r\n\r\n    const contactSims = [];\r\n\r\n    let contactIndex = 0;\r\n\r\n    for (let i = 0; i < b2_graphColorCount; ++i)\r\n    {\r\n        const color = graphColors[i];\r\n        const count = color.contacts.count;\r\n        const base = color.contacts.data;\r\n\r\n        for (let j = 0; j < count; ++j)\r\n        {\r\n            console.assert(base[j]._bodyIdA !== B2_NULL_INDEX, `${j} ${i} ${color} ${contactIndex}`);\r\n            console.assert(base[j]._bodyIdB !== B2_NULL_INDEX, `${j} ${i} ${color} ${contactIndex}`);\r\n            contactSims.push(base[j]);\r\n            contactIndex += 1;\r\n        }\r\n    }\r\n\r\n    {\r\n        const base = world.solverSetArray[b2SetType.b2_awakeSet].contacts.data;\r\n\r\n        for (let i = 0; i < nonTouchingCount; ++i)\r\n        {\r\n            console.assert(base[i]._bodyIdA !== B2_NULL_INDEX, `${i} ${contactIndex}`);\r\n            console.assert(base[i]._bodyIdB !== B2_NULL_INDEX, `${i} ${contactIndex}`);\r\n            contactSims.push(base[i]);\r\n            console.assert(contactSims[contactIndex]._bodyIdA !== B2_NULL_INDEX, `${i} ${contactIndex}`);\r\n            console.assert(contactSims[contactIndex]._bodyIdB !== B2_NULL_INDEX, `${i} ${contactIndex}`);\r\n            contactIndex += 1;\r\n        }\r\n    }\r\n\r\n    console.assert(contactIndex == contactCount);\r\n\r\n    // b2StepContext (created per b2World_Step)\r\n    context.contacts = contactSims;\r\n\r\n    // Contact bit set on ids because contact pointers are unstable as they move between touching and not touching.\r\n    const contactIdCapacity = b2GetIdCapacity(world.contactIdPool);\r\n\r\n    for (let i = 0; i < world.workerCount; ++i)\r\n    {\r\n        world.taskContextArray[i].contactStateBitSet = b2SetBitCountAndClear(world.taskContextArray[i].contactStateBitSet, contactIdCapacity);\r\n    }\r\n\r\n    // PJB: 19/11/2024 this 'task' type function is definitely needed for collisions\r\n    b2CollideTask(0, contactCount, 0, context);\r\n\r\n    // b2FreeStackItem(world.stackAllocator, contactSims);\r\n    context.contacts = null;\r\n\r\n    // Serially update contact state\r\n\r\n    // Bitwise OR all contact bits\r\n    const bitSet = world.taskContextArray[0].contactStateBitSet;\r\n\r\n    for (let i = 1; i < world.workerCount; ++i)\r\n    {\r\n        b2InPlaceUnion(bitSet, world.taskContextArray[i].contactStateBitSet);\r\n    }\r\n\r\n    const contacts = world.contactArray;\r\n    const awakeSet = world.solverSetArray[b2SetType.b2_awakeSet];\r\n\r\n    const shapes = world.shapeArray;\r\n    const worldId = world.worldId;\r\n\r\n    // Process contact state changes. Iterate over set bits\r\n    for (let k = 0; k < bitSet.blockCount; ++k)\r\n    {\r\n        let bits = bitSet.bits[k];\r\n\r\n        while (bits != 0n)\r\n        {\r\n            const ctz = b2CTZ64(bits);\r\n            const contactId = 64 * k + ctz;\r\n\r\n            const contact = contacts[contactId];\r\n            console.assert(contact.setIndex == b2SetType.b2_awakeSet);\r\n\r\n            const colorIndex = contact.colorIndex;\r\n            const localIndex = contact.localIndex;\r\n\r\n            let contactSim;\r\n\r\n            if (colorIndex != B2_NULL_INDEX)\r\n            {\r\n                // contact lives in constraint graph\r\n                console.assert(0 <= colorIndex && colorIndex < b2_graphColorCount);\r\n                const color = graphColors[colorIndex];\r\n                console.assert(0 <= localIndex && localIndex < color.contacts.count);\r\n                contactSim = color.contacts.data[localIndex];\r\n            }\r\n            else\r\n            {\r\n                console.assert(0 <= localIndex && localIndex < awakeSet.contacts.count);\r\n                contactSim = awakeSet.contacts.data[localIndex];\r\n            }\r\n\r\n            const shapeA = shapes[contact.shapeIdA];\r\n            const shapeB = shapes[contact.shapeIdB];\r\n            const shapeIdA = new b2ShapeId(shapeA.id + 1, worldId, shapeA.revision);\r\n            const shapeIdB = new b2ShapeId(shapeB.id + 1, worldId, shapeB.revision);\r\n            const flags = contact.flags;\r\n            const simFlags = contactSim.simFlags;\r\n\r\n            if (simFlags & b2ContactSimFlags.b2_simDisjoint)\r\n            {\r\n                // Was touching?\r\n                if ((flags & b2ContactFlags.b2_contactTouchingFlag) != 0 && (flags & b2ContactFlags.b2_contactEnableContactEvents) != 0)\r\n                {\r\n                    const event = new b2ContactEndTouchEvent();\r\n                    event.shapeIdA = shapeIdA;\r\n                    event.shapeIdB = shapeIdB;\r\n                    world.contactEndArray.push(event);\r\n                }\r\n\r\n                // Bounding boxes no longer overlap\r\n                contact.flags &= ~b2ContactFlags.b2_contactTouchingFlag;\r\n                b2DestroyContact(world, contact, false);\r\n\r\n                // contact = null;\r\n                // contactSim = null;\r\n            }\r\n            else if (simFlags & b2ContactSimFlags.b2_simStartedTouching)\r\n            {\r\n                console.assert(contact.islandId == B2_NULL_INDEX);\r\n\r\n                if ((flags & b2ContactFlags.b2_contactSensorFlag) != 0)\r\n                {\r\n                    // Contact is a sensor\r\n                    if ((flags & b2ContactFlags.b2_contactEnableSensorEvents) != 0)\r\n                    {\r\n                        if (shapeA.isSensor)\r\n                        {\r\n                            const event = new b2SensorBeginTouchEvent();\r\n                            event.sensorShapeId = shapeIdA;\r\n                            event.visitorShapeId = shapeIdB;\r\n                            world.sensorBeginEventArray.push(event);\r\n                        }\r\n\r\n                        if (shapeB.isSensor)\r\n                        {\r\n                            const event = new b2SensorBeginTouchEvent();\r\n                            event.sensorShapeId = shapeIdB;\r\n                            event.visitorShapeId = shapeIdA;\r\n                            world.sensorBeginEventArray.push(event);\r\n                        }\r\n                    }\r\n\r\n                    contactSim.simFlags &= ~b2ContactSimFlags.b2_simStartedTouching;\r\n                    contact.flags |= b2ContactFlags.b2_contactSensorTouchingFlag;\r\n                }\r\n                else\r\n                {\r\n                    // Contact is solid\r\n                    if (flags & b2ContactFlags.b2_contactEnableContactEvents)\r\n                    {\r\n                        const event = new b2ContactBeginTouchEvent();\r\n                        event.shapeIdA = shapeIdA;\r\n                        event.shapeIdB = shapeIdB;\r\n                        event.manifold = contactSim.manifold;\r\n                        world.contactBeginArray.push(event);\r\n                    }\r\n\r\n                    console.assert(contactSim.manifold.pointCount > 0);\r\n                    console.assert(contact.setIndex == b2SetType.b2_awakeSet);\r\n\r\n                    // Link first because this wakes colliding bodies and ensures the body sims\r\n                    // are in the correct place.\r\n                    contact.flags |= b2ContactFlags.b2_contactTouchingFlag;\r\n                    b2LinkContact(world, contact);\r\n\r\n                    // Make sure these didn't change\r\n                    console.assert(contact.colorIndex == B2_NULL_INDEX);\r\n                    console.assert(contact.localIndex == localIndex);\r\n\r\n                    // Contact sim pointer may have become orphaned due to awake set growth,\r\n                    // so I just need to refresh it.\r\n                    console.assert(0 <= localIndex && localIndex < awakeSet.contacts.count);\r\n                    contactSim = awakeSet.contacts.data[localIndex];\r\n\r\n                    contactSim.simFlags &= ~b2ContactSimFlags.b2_simStartedTouching;\r\n\r\n                    b2AddContactToGraph(world, contactSim, contact);\r\n                    b2RemoveNonTouchingContact(world, b2SetType.b2_awakeSet, localIndex);\r\n\r\n                    // contactSim = null;\r\n                }\r\n            }\r\n            else if (simFlags & b2ContactSimFlags.b2_simStoppedTouching)\r\n            {\r\n                contactSim.simFlags &= ~b2ContactSimFlags.b2_simStoppedTouching;\r\n\r\n                if ((flags & b2ContactFlags.b2_contactSensorFlag) != 0)\r\n                {\r\n                    // Contact is a sensor\r\n                    contact.flags &= ~b2ContactFlags.b2_contactSensorTouchingFlag;\r\n\r\n                    if ((flags & b2ContactFlags.b2_contactEnableSensorEvents) != 0)\r\n                    {\r\n                        if (shapeA.isSensor)\r\n                        {\r\n                            const event = new b2SensorEndTouchEvent();\r\n                            event.sensorShapeId = shapeIdA;\r\n                            event.visitorShapeId = shapeIdB;\r\n                            world.sensorEndEventArray.push(event);\r\n                        }\r\n\r\n                        if (shapeB.isSensor)\r\n                        {\r\n                            const event = new b2SensorEndTouchEvent();\r\n                            event.sensorShapeId = shapeIdB;\r\n                            event.visitorShapeId = shapeIdA;\r\n                            world.sensorEndEventArray.push(event);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Contact is solid\r\n                    contact.flags &= ~b2ContactFlags.b2_contactTouchingFlag;\r\n\r\n                    if (contact.flags & b2ContactFlags.b2_contactEnableContactEvents)\r\n                    {\r\n                        const event = new b2ContactEndTouchEvent();\r\n                        event.shapeIdA = shapeIdA;\r\n                        event.shapeIdB = shapeIdB;\r\n                        world.contactEndArray.push(event);\r\n                    }\r\n\r\n                    console.assert(contactSim.manifold.pointCount == 0);\r\n\r\n                    b2UnlinkContact(world, contact);\r\n                    const bodyIdA = contact.edges[0].bodyId;\r\n                    const bodyIdB = contact.edges[1].bodyId;\r\n\r\n                    b2AddNonTouchingContact(world, contact, contactSim);\r\n                    b2RemoveContactFromGraph(world, bodyIdA, bodyIdB, colorIndex, localIndex);\r\n\r\n                    // contact = null;\r\n                    // contactSim = null;\r\n                }\r\n            }\r\n\r\n            // Clear the smallest set bit\r\n            bits = bits & (bits - 1n);\r\n        }\r\n    }\r\n\r\n    b2ValidateSolverSets(world);\r\n    b2ValidateContacts(world);\r\n\r\n    // b2TracyCZoneEnd(contact_state);\r\n    // b2TracyCZoneEnd(collide);\r\n}\r\n\r\nGlobalDebug.b2Vec2Count = 0;\r\nb2Vec2Where.calls = {};\r\nGlobalDebug.b2Rot2Count = 0;\r\nb2Rot2Where.calls = {};\r\nGlobalDebug.b2ManifoldCount = 0;\r\nGlobalDebug.b2ManifoldPointCount = 0;\r\nb2ManifoldPointWhere.calls = {};\r\nGlobalDebug.b2PolyCollideCount = 0;\r\nGlobalDebug.b2ContactSimCount = 0;\r\nGlobalDebug.b2TOIInputCount = 0;\r\nGlobalDebug.b2ShapeCastPairInputCount = 0;\r\nGlobalDebug.b2SweepCount = 0;\r\n\r\n/**\r\n * @function b2World_Step\r\n * @summary Advances the physics simulation by a specified time step.\r\n * @param {b2WorldId} worldId - The identifier of the physics world to step\r\n * @param {number} timeStep - The time increment to advance the simulation (in seconds)\r\n * @param {number} subStepCount - The number of sub-steps to use for the iteration\r\n * @returns {void}\r\n * @description\r\n * Performs one step of physics simulation by updating broad phase pairs,\r\n * handling collisions, and solving the physics constraints. The function\r\n * manages contact events, sensor events, and body movement events during\r\n * the simulation step. It also handles warm starting and enforces velocity\r\n * limits based on world settings.\r\n * @throws {Error} Throws an assertion error if the world's stack allocator\r\n * is not empty after the step completes.\r\n * @note The function will not execute if the world is locked or if timeStep is 0.\r\n */\r\nexport function b2World_Step(worldId, timeStep, subStepCount)\r\n{\r\n    GlobalDebug.b2FrameCount++;\r\n\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Prepare to capture events\r\n    // Ensure user does not access stale data if there is an early return\r\n    world.bodyMoveEventArray = [];\r\n    world.sensorBeginEventArray = [];\r\n    world.sensorEndEventArray = [];\r\n    world.contactBeginArray = [];\r\n    world.contactEndArray = [];\r\n    world.contactHitArray = [];\r\n\r\n    if (timeStep === 0.0)\r\n    {\r\n        // todo would be useful to still process collision while paused\r\n        return;\r\n    }\r\n\r\n    world.locked = true;\r\n    b2UpdateBroadPhasePairs(world);\r\n    \r\n    const context = new b2StepContext();\r\n    context.world = world;\r\n    context.dt = timeStep;\r\n    context.subStepCount = Math.max(1, subStepCount);\r\n\r\n    if (timeStep > 0.0)\r\n    {\r\n        context.inv_dt = 1.0 / timeStep;\r\n        context.h = timeStep / context.subStepCount;\r\n        context.inv_h = context.subStepCount * context.inv_dt;\r\n    }\r\n    else\r\n    {\r\n        context.inv_dt = 0.0;\r\n        context.h = 0.0;\r\n        context.inv_h = 0.0;\r\n    }\r\n\r\n    world.inv_h = context.inv_h;\r\n\r\n    // Hertz values get reduced for large time steps\r\n    const contactHertz = Math.min(world.contactHertz, 0.25 * context.inv_h);\r\n    const jointHertz = Math.min(world.jointHertz, 0.125 * context.inv_h);\r\n\r\n    context.contactSoftness = b2MakeSoft(contactHertz, world.contactDampingRatio, context.h);\r\n    context.staticSoftness = b2MakeSoft(2.0 * contactHertz, world.contactDampingRatio, context.h);\r\n    context.jointSoftness = b2MakeSoft(jointHertz, world.jointDampingRatio, context.h);\r\n\r\n    context.restitutionThreshold = world.restitutionThreshold;\r\n    context.maxLinearVelocity = world.maxLinearVelocity;\r\n    context.enableWarmStarting = world.enableWarmStarting;\r\n\r\n    // Update contacts\r\n    b2Collide(context);\r\n\r\n    // Integrate velocities, solve velocity constraints, and integrate positions.\r\n    if (context.dt > 0.0)\r\n    {\r\n        b2Solve(world, context);\r\n    }\r\n\r\n    world.locked = false;\r\n\r\n    console.assert(b2GetStackAllocation(world.stackAllocator) == 0, `world.stackAllocator entries not empty ${b2GetStackAllocation(world.stackAllocator)}`);\r\n}\r\n\r\nconst p1 = new b2Vec2();\r\nconst p2 = new b2Vec2();\r\nconst q = new b2Rot();\r\nconst txf = new b2Transform(p1, q);\r\n\r\nexport function b2DrawShape(draw, shape, transform, color)\r\n{\r\n    const xf = transform.clone();\r\n    \r\n    switch (shape.type)\r\n    {\r\n        case b2ShapeType.b2_capsuleShape:\r\n            {\r\n                const capsule = shape.capsule;\r\n                b2TransformPointOut(xf, capsule.center1, p1);\r\n                b2TransformPointOut(xf, capsule.center2, p2);\r\n\r\n                if (shape.image)\r\n                {\r\n                    draw.DrawImageCapsule(p1, p2, capsule.radius, shape, draw.context);\r\n                }\r\n                else if (!shape.imageNoDebug)\r\n                {\r\n                    draw.DrawSolidCapsule(p1, p2, capsule.radius, color, draw.context);\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_circleShape:\r\n            {\r\n                const circle = shape.circle;\r\n                b2TransformPointOutXf(xf, circle.center, txf);\r\n\r\n                if (shape.image)\r\n                {\r\n                    draw.DrawImageCircle(txf, circle.radius, shape, draw.context);\r\n                }\r\n                else if (!shape.imageNoDebug)\r\n                {\r\n                    draw.DrawSolidCircle(txf, circle.radius, color, draw.context);\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_polygonShape:\r\n            {\r\n                const poly = shape.polygon;\r\n\r\n                if (shape.image)\r\n                {\r\n                    draw.DrawImagePolygon(xf, shape, draw.context);\r\n                }\r\n                else if (!shape.imageNoDebug)\r\n                {\r\n                    draw.DrawSolidPolygon(xf, poly.vertices, poly.count, poly.radius, color, draw.context);\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_segmentShape:\r\n            {\r\n                const segment = shape.segment;\r\n                b2TransformPointOut(xf, segment.point1, p1);\r\n                b2TransformPointOut(xf, segment.point2, p2);\r\n\r\n                if (!shape.imageNoDebug)\r\n                {\r\n                    draw.DrawSegment(p1, p2, color, draw.context);\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case b2ShapeType.b2_chainSegmentShape:\r\n            {\r\n                const segment = shape.chainSegment.segment;\r\n                b2TransformPointOut(xf, segment.point1, p1);\r\n                b2TransformPointOut(xf, segment.point2, p2);\r\n\r\n                if (!shape.imageNoDebug)\r\n                {\r\n                    draw.DrawSegment(p1, p2, color, draw.context);\r\n                }\r\n\r\n                // draw.DrawPoint(p2, 4.0, color, draw.context);\r\n                // draw.DrawSegment(p1, b2Lerp(p1, p2, 0.1), b2HexColor.b2_colorPaleGreen, draw.context);\r\n            }\r\n\r\n            break;\r\n            \r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n// DrawContext is converted to a class in JavaScript\r\nclass DrawContext\r\n{\r\n    constructor(world, draw)\r\n    {\r\n        this.world = world;\r\n        this.draw = draw;\r\n        \r\n    }\r\n}\r\n\r\nfunction DrawQueryCallback(proxyId, shapeId, context)\r\n{\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n\r\n    const drawContext = context;\r\n    const world = drawContext.world;\r\n    const draw = drawContext.draw;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    b2SetBit(world.debugBodySet, shape.bodyId);\r\n\r\n    if (draw.drawShapes)\r\n    {\r\n        // b2CheckId(world.bodyArray, shape.bodyId);\r\n        const body = world.bodyArray[shape.bodyId];\r\n        const bodySim = b2GetBodySim(world, body);\r\n\r\n        let color;\r\n\r\n        if (body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n        {\r\n            color = b2HexColor.b2_colorGray;\r\n        }\r\n        else if (shape.customColor !== 0)\r\n        {\r\n            color = shape.customColor;\r\n        }\r\n        else if (body.type === b2BodyType.b2_dynamicBody && bodySim.mass === 0.0)\r\n        {\r\n            // Bad body\r\n            color = b2HexColor.b2_colorRed;\r\n        }\r\n        else if (body.setIndex === b2SetType.b2_disabledSet)\r\n        {\r\n            color = b2HexColor.b2_colorSlateGray;\r\n        }\r\n        else if (shape.isSensor)\r\n        {\r\n            color = b2HexColor.b2_colorWheat;\r\n        }\r\n        else if (bodySim.isBullet && body.setIndex === b2SetType.b2_awakeSet)\r\n        {\r\n            color = b2HexColor.b2_colorTurquoise;\r\n        }\r\n        else if (body.isSpeedCapped)\r\n        {\r\n            color = b2HexColor.b2_colorYellow;\r\n        }\r\n        else if (bodySim.isFast)\r\n        {\r\n            color = b2HexColor.b2_colorSalmon;\r\n        }\r\n        else if (body.type === b2BodyType.b2_staticBody)\r\n        {\r\n            color = b2HexColor.b2_colorPaleGreen;\r\n        }\r\n        else if (body.type === b2BodyType.b2_kinematicBody)\r\n        {\r\n            color = b2HexColor.b2_colorRoyalBlue;\r\n        }\r\n        else if (body.setIndex === b2SetType.b2_awakeSet)\r\n        {\r\n            color = b2HexColor.b2_colorPink;\r\n        }\r\n        else\r\n        {\r\n            color = b2HexColor.b2_colorGray;\r\n        }\r\n\r\n        b2DrawShape(draw, shape, bodySim.transform, color);\r\n    }\r\n\r\n    if (draw.drawAABBs)\r\n    {\r\n        const aabb = shape.fatAABB;\r\n\r\n        const vs = [\r\n            new b2Vec2(aabb.lowerBoundX, aabb.lowerBoundY),\r\n            new b2Vec2(aabb.upperBoundX, aabb.lowerBoundY),\r\n            new b2Vec2(aabb.upperBoundX, aabb.upperBoundY),\r\n            new b2Vec2(aabb.lowerBoundX, aabb.upperBoundY)\r\n        ];\r\n\r\n        draw.DrawPolygon(vs, 4, b2HexColor.b2_colorGold, draw.context);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction b2DrawWithBounds(world, draw)\r\n{\r\n    console.assert(b2AABB_IsValid(draw.drawingBounds));\r\n\r\n    const k_impulseScale = 1.0;\r\n    const k_axisScale = 0.3;\r\n    const speculativeColor = b2HexColor.b2_colorGray3;\r\n    const addColor = b2HexColor.b2_colorGreen;\r\n    const persistColor = b2HexColor.b2_colorBlue;\r\n    const normalColor = b2HexColor.b2_colorGray9;\r\n    const impulseColor = b2HexColor.b2_colorMagenta;\r\n    const frictionColor = b2HexColor.b2_colorYellow;\r\n\r\n    const graphColors = [ b2HexColor.b2_colorRed, b2HexColor.b2_colorOrange, b2HexColor.b2_colorYellow, b2HexColor.b2_colorGreen,\r\n        b2HexColor.b2_colorCyan, b2HexColor.b2_colorBlue, b2HexColor.b2_colorViolet, b2HexColor.b2_colorPink,\r\n        b2HexColor.b2_colorChocolate, b2HexColor.b2_colorGoldenrod, b2HexColor.b2_colorCoral, b2HexColor.b2_colorBlack ];\r\n\r\n    const bodyCapacity = b2GetIdCapacity(world.bodyIdPool);\r\n    world.debugBodySet = b2SetBitCountAndClear(world.debugBodySet, bodyCapacity);\r\n\r\n    const jointCapacity = b2GetIdCapacity(world.jointIdPool);\r\n    world.debugJointSet = b2SetBitCountAndClear(world.debugJointSet, jointCapacity);\r\n\r\n    const contactCapacity = b2GetIdCapacity(world.contactIdPool);\r\n    world.debugContactSet = b2SetBitCountAndClear(world.debugContactSet, contactCapacity);\r\n\r\n    const drawContext = new DrawContext(world, draw);\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Query(world.broadPhase.trees[i], draw.drawingBounds, B2_DEFAULT_MASK_BITS, DrawQueryCallback,\r\n            drawContext);\r\n    }\r\n\r\n    const wordCount = world.debugBodySet.blockCount;\r\n    const bits = world.debugBodySet.bits;\r\n\r\n    for (let k = 0; k < wordCount; ++k)\r\n    {\r\n        let word = bits[k];\r\n\r\n        while (word !== 0)\r\n        {\r\n            const ctz = b2CTZ64(word);\r\n            const bodyId = 64 * k + ctz;\r\n\r\n            // b2CheckId(world.bodyArray, bodyId);\r\n            const body = world.bodyArray[bodyId];\r\n\r\n            if (draw.drawMass && body.type === b2BodyType.b2_dynamicBody)\r\n            {\r\n                const offset = new b2Vec2(0.1, 0.1);\r\n                const bodySim = b2GetBodySim(world, body);\r\n\r\n                const transform = new b2Transform(bodySim.center, bodySim.transform.q);\r\n                draw.DrawTransform(transform, draw.context);\r\n\r\n                const p = b2TransformPoint(transform, offset);\r\n\r\n                const buffer = `  ${bodySim.mass.toFixed(2)}`;\r\n                draw.DrawString(p, buffer, draw.context);\r\n            }\r\n\r\n            if (draw.drawJoints)\r\n            {\r\n                let jointKey = body.headJointKey;\r\n\r\n                while (jointKey !== B2_NULL_INDEX)\r\n                {\r\n                    const jointId = jointKey >> 1;\r\n                    const edgeIndex = jointKey & 1;\r\n                    const joint = world.jointArray[jointId];\r\n\r\n                    // avoid double draw\r\n                    if (b2GetBit(world.debugJointSet, jointId) === false)\r\n                    {\r\n                        b2DrawJoint(draw, world, joint);\r\n                        b2SetBit(world.debugJointSet, jointId);\r\n                    }\r\n\r\n                    jointKey = joint.edges[edgeIndex].nextKey;\r\n                }\r\n            }\r\n\r\n            const linearSlop = b2_linearSlop;\r\n\r\n            if (draw.drawContacts && body.type === b2BodyType.b2_dynamicBody && body.setIndex === b2SetType.b2_awakeSet)\r\n            {\r\n                let contactKey = body.headContactKey;\r\n\r\n                while (contactKey !== B2_NULL_INDEX)\r\n                {\r\n                    const contactId = contactKey >> 1;\r\n                    const edgeIndex = contactKey & 1;\r\n                    const contact = world.contactArray[contactId];\r\n                    contactKey = contact.edges[edgeIndex].nextKey;\r\n\r\n                    if (contact.setIndex !== b2SetType.b2_awakeSet || contact.colorIndex === B2_NULL_INDEX)\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    // avoid double draw\r\n                    if (b2GetBit(world.debugContactSet, contactId) === false)\r\n                    {\r\n                        console.assert(0 <= contact.colorIndex && contact.colorIndex < b2_graphColorCount);\r\n\r\n                        const gc = world.constraintGraph.colors[contact.colorIndex];\r\n                        console.assert(0 <= contact.localIndex && contact.localIndex < gc.contacts.count);\r\n\r\n                        const contactSim = gc.contacts.data[contact.localIndex];\r\n                        const pointCount = contactSim.manifold.pointCount;\r\n                        const normal = new b2Vec2(contactSim.manifold.normalX, contactSim.manifold.normalY);\r\n\r\n                        for (let j = 0; j < pointCount; ++j)\r\n                        {\r\n                            const point = contactSim.manifold.points[j];\r\n\r\n                            if (draw.drawGraphColors)\r\n                            {\r\n                                // graph color\r\n                                const pointSize = contact.colorIndex === b2_overflowIndex ? 7.5 : 5.0;\r\n                                draw.DrawPoint(point.pointX, point.pointY, pointSize, graphColors[contact.colorIndex], draw.context);\r\n                            }\r\n                            else if (point.separation > linearSlop)\r\n                            {\r\n                                // Speculative\r\n                                draw.DrawPoint(point.pointX, point.pointY, 5.0, speculativeColor, draw.context);\r\n                            }\r\n                            else if (point.persisted === false)\r\n                            {\r\n                                // Add\r\n                                draw.DrawPoint(point.pointX, point.pointY, 10.0, addColor, draw.context);\r\n                            }\r\n                            else if (point.persisted === true)\r\n                            {\r\n                                // Persist\r\n                                draw.DrawPoint(point.pointX, point.pointY, 5.0, persistColor, draw.context);\r\n                            }\r\n\r\n                            if (draw.drawContactNormals)\r\n                            {\r\n                                const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                                const p2 = b2MulAdd(p1, k_axisScale, normal);\r\n                                draw.DrawSegment(p1, p2, normalColor, draw.context);\r\n                            }\r\n                            else if (draw.drawContactImpulses)\r\n                            {\r\n                                const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                                const p2 = b2MulAdd(p1, k_impulseScale * point.normalImpulse, normal);\r\n                                draw.DrawSegment(p1, p2, impulseColor, draw.context);\r\n                                const buffer = `${(1000.0 * point.normalImpulse).toFixed(1)}`;\r\n                                draw.DrawString(p1, buffer, draw.context);\r\n                            }\r\n\r\n                            if (draw.drawFrictionImpulses)\r\n                            {\r\n                                const tangent = b2RightPerp(normal);\r\n                                const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                                const p2 = b2MulAdd(p1, k_impulseScale * point.tangentImpulse, tangent);\r\n                                draw.DrawSegment(p1, p2, frictionColor, draw.context);\r\n                                const buffer = `${(1000.0 * point.tangentImpulse).toFixed(1)}`;\r\n                                draw.DrawString(p1, buffer, draw.context);\r\n                            }\r\n                        }\r\n\r\n                        b2SetBit(world.debugContactSet, contactId);\r\n                    }\r\n\r\n                    contactKey = contact.edges[edgeIndex].nextKey;\r\n                }\r\n            }\r\n\r\n            // Clear the smallest set bit\r\n            word = word & (word - 1);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_Draw\r\n * @description\r\n * Renders debug visualization of a Box2D world, including shapes, joints, AABBs,\r\n * mass centers, and contact points based on the debug draw flags.\r\n * @param {b2WorldId} worldId - ID of the Box2D world to render\r\n * @param {b2DebugDraw} draw - Debug drawing context with rendering flags and methods\r\n * @returns {void}\r\n * @throws {Error} Throws assertion error if world is locked or body transform is null\r\n * @note\r\n * Drawing is controlled by flags in the draw parameter:\r\n * - drawShapes: Renders physics bodies/shapes with color coding\r\n * - drawJoints: Renders all active joints\r\n * - drawAABBs: Renders axis-aligned bounding boxes\r\n * - drawMass: Renders center of mass and mass values\r\n * - drawContacts: Renders contact points and impulses\r\n * - useDrawingBounds: Uses bounded drawing region\r\n */\r\nexport function b2World_Draw(worldId, draw)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (draw.useDrawingBounds)\r\n    {\r\n        b2DrawWithBounds(world, draw);\r\n\r\n        return;\r\n    }\r\n\r\n    if (draw.drawShapes)\r\n    {\r\n        const setCount = world.solverSetArray.length;\r\n\r\n        for (let setIndex = 0; setIndex < setCount; ++setIndex)\r\n        {\r\n            const set = world.solverSetArray[setIndex];\r\n            const bodyCount = set.sims.count;\r\n\r\n            for (let bodyIndex = 0; bodyIndex < bodyCount; ++bodyIndex)\r\n            {\r\n                const bodySim = set.sims.data[bodyIndex];\r\n                console.assert(bodySim.transform != null, \"transform is null for body \" + bodySim.bodyId + \" \" + setIndex + \" \" + bodyIndex);\r\n\r\n                // b2CheckIndex(world.bodyArray, bodySim.bodyId);\r\n                const body = world.bodyArray[bodySim.bodyId];\r\n\r\n                // 0 = static, 1 = disabled, 2 = awake, 3 = sleeping\r\n                console.assert(body.setIndex === setIndex, `body.setIndex is wrong: ${body.setIndex} != ${setIndex}`);\r\n\r\n                const xf = bodySim.transform;\r\n                let shapeId = body.headShapeId;\r\n\r\n                while (shapeId !== B2_NULL_INDEX)\r\n                {\r\n                    const shape = world.shapeArray[shapeId];\r\n                    let color;\r\n\r\n                    if (body.setIndex >= b2SetType.b2_firstSleepingSet)\r\n                    {\r\n                        color = b2HexColor.b2_colorGray;\r\n                    }\r\n                    else if (shape.customColor !== 0)\r\n                    {\r\n                        color = shape.customColor;\r\n                    }\r\n                    else if (body.type === b2BodyType.b2_dynamicBody && bodySim.mass === 0.0)\r\n                    {\r\n                        // Bad body\r\n                        color = b2HexColor.b2_colorRed;\r\n                    }\r\n                    else if (body.setIndex === b2SetType.b2_disabledSet)\r\n                    {\r\n                        color = b2HexColor.b2_colorSlateGray;\r\n                    }\r\n                    else if (shape.isSensor)\r\n                    {\r\n                        color = b2HexColor.b2_colorWheat;\r\n                    }\r\n                    else if (bodySim.isBullet && body.setIndex === b2SetType.b2_awakeSet)\r\n                    {\r\n                        color = b2HexColor.b2_colorTurquoise;\r\n                    }\r\n                    else if (body.isSpeedCapped)\r\n                    {\r\n                        color = b2HexColor.b2_colorYellow;\r\n                    }\r\n                    else if (bodySim.isFast)\r\n                    {\r\n                        color = b2HexColor.b2_colorSalmon;\r\n                    }\r\n                    else if (body.type === b2BodyType.b2_staticBody)\r\n                    {\r\n                        color = b2HexColor.b2_colorPaleGreen;\r\n                    }\r\n                    else if (body.type === b2BodyType.b2_kinematicBody)\r\n                    {\r\n                        color = b2HexColor.b2_colorRoyalBlue;\r\n                    }\r\n                    else if (body.setIndex === b2SetType.b2_awakeSet)\r\n                    {\r\n                        color = b2HexColor.b2_colorPink;\r\n                    }\r\n                    else\r\n                    {\r\n                        color = b2HexColor.b2_colorGray;\r\n                    }\r\n\r\n                    b2DrawShape(draw, shape, xf, color);\r\n                    shapeId = shape.nextShapeId;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (draw.drawJoints)\r\n    {\r\n        const count = world.jointArray.length;\r\n\r\n        for (let i = 0; i < count; ++i)\r\n        {\r\n            const joint = world.jointArray[i];\r\n\r\n            if (joint.setIndex === B2_NULL_INDEX)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            b2DrawJoint(draw, world, joint);\r\n        }\r\n    }\r\n\r\n    if (draw.drawAABBs)\r\n    {\r\n        const color = b2HexColor.b2_colorGray;\r\n        const setIndex = b2SetType.b2_awakeSet;\r\n\r\n        {\r\n            const set = world.solverSetArray[setIndex];\r\n            const bodyCount = set.sims.count;\r\n\r\n            for (let bodyIndex = 0; bodyIndex < bodyCount; ++bodyIndex)\r\n            {\r\n                const bodySim = set.sims.data[bodyIndex];\r\n                const xf = b2Transform.identity();\r\n\r\n                // const buffer = `${bodySim.bodyId}`;\r\n                // draw.DrawString(bodySim.center, buffer, draw.context);\r\n\r\n                // b2CheckIndex(world.bodyArray, bodySim.bodyId);\r\n                const body = world.bodyArray[bodySim.bodyId];\r\n                console.assert(body.setIndex === setIndex);\r\n\r\n                let shapeId = body.headShapeId;\r\n\r\n                while (shapeId !== B2_NULL_INDEX)\r\n                {\r\n                    const shape = world.shapeArray[shapeId];\r\n                    const aabb = shape.fatAABB;\r\n                    const vs = [\r\n                        new b2Vec2(aabb.lowerBoundX, aabb.lowerBoundY),\r\n                        new b2Vec2(aabb.upperBoundX, aabb.lowerBoundY),\r\n                        new b2Vec2(aabb.upperBoundX, aabb.upperBoundY),\r\n                        new b2Vec2(aabb.lowerBoundX, aabb.upperBoundY)\r\n                    ];\r\n\r\n                    draw.DrawPolygon(xf, vs, 4, color, draw.context);\r\n\r\n                    shapeId = shape.nextShapeId;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (draw.drawMass)\r\n    {\r\n        const offset = new b2Vec2(0.1, 0.1);\r\n        const setCount = world.solverSetArray.length;\r\n\r\n        for (let setIndex = 0; setIndex < setCount; ++setIndex)\r\n        {\r\n            const set = world.solverSetArray[setIndex];\r\n            const bodyCount = set.sims.count;\r\n\r\n            for (let bodyIndex = 0; bodyIndex < bodyCount; ++bodyIndex)\r\n            {\r\n                const bodySim = set.sims.data[bodyIndex];\r\n\r\n                const transform = new b2Transform(bodySim.center, bodySim.transform.q);\r\n                draw.DrawTransform(transform, draw.context);\r\n\r\n                const p = b2TransformPoint(transform, offset);\r\n\r\n                const buffer = `  ${bodySim.mass.toFixed(2)}`;\r\n                draw.DrawString(p, buffer, draw.context);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (draw.drawContacts)\r\n    {\r\n        const k_impulseScale = 1.0;\r\n        const k_axisScale = 0.3;\r\n        const linearSlop = b2_linearSlop;\r\n\r\n        const speculativeColor = b2HexColor.b2_colorGray3;\r\n        const addColor = b2HexColor.b2_colorGreen;\r\n        const persistColor = b2HexColor.b2_colorBlue;\r\n        const normalColor = b2HexColor.b2_colorGray9;\r\n        const impulseColor = b2HexColor.b2_colorMagenta;\r\n        const frictionColor = b2HexColor.b2_colorYellow;\r\n\r\n        const colors = [ b2HexColor.b2_colorRed, b2HexColor.b2_colorOrange, b2HexColor.b2_colorYellow, b2HexColor.b2_colorGreen,\r\n            b2HexColor.b2_colorCyan, b2HexColor.b2_colorBlue, b2HexColor.b2_colorViolet, b2HexColor.b2_colorPink,\r\n            b2HexColor.b2_colorChocolate, b2HexColor.b2_colorGoldenrod, b2HexColor.b2_colorCoral, b2HexColor.b2_colorBlack ];\r\n\r\n        for (let colorIndex = 0; colorIndex < b2_graphColorCount; ++colorIndex)\r\n        {\r\n            const graphColor = world.constraintGraph.colors[colorIndex];\r\n\r\n            const contactCount = graphColor.contacts.count;\r\n\r\n            for (let contactIndex = 0; contactIndex < contactCount; ++contactIndex)\r\n            {\r\n                const contact = graphColor.contacts.data[contactIndex];\r\n                const pointCount = contact.manifold.pointCount;\r\n                const normal = new b2Vec2(contact.manifold.normalX, contact.manifold.normalY);\r\n\r\n                for (let j = 0; j < pointCount; ++j)\r\n                {\r\n                    const point = contact.manifold.points[j];\r\n\r\n                    if (draw.drawGraphColors && 0 <= colorIndex && colorIndex <= b2_graphColorCount)\r\n                    {\r\n                        // graph color\r\n                        const pointSize = colorIndex === b2_overflowIndex ? 7.5 : 5.0;\r\n                        draw.DrawPoint(point.pointX, point.pointY, pointSize, colors[colorIndex], draw.context);\r\n\r\n                        // draw.DrawString(point.position, `${point.color}`);\r\n                    }\r\n                    else if (point.separation > linearSlop)\r\n                    {\r\n                        // Speculative\r\n                        draw.DrawPoint(point.pointX, point.pointY, 5.0, speculativeColor, draw.context);\r\n                    }\r\n                    else if (point.persisted === false)\r\n                    {\r\n                        // Add\r\n                        draw.DrawPoint(point.pointX, point.pointY, 10.0, addColor, draw.context);\r\n                    }\r\n                    else if (point.persisted === true)\r\n                    {\r\n                        // Persist\r\n                        draw.DrawPoint(point.pointX, point.pointY, 5.0, persistColor, draw.context);\r\n                    }\r\n\r\n                    if (draw.drawContactNormals)\r\n                    {\r\n                        const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                        const p2 = b2MulAdd(p1, k_axisScale, normal);\r\n                        draw.DrawSegment(p1, p2, normalColor, draw.context);\r\n                    }\r\n                    else if (draw.drawContactImpulses)\r\n                    {\r\n                        const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                        const p2 = b2MulAdd(p1, k_impulseScale * point.normalImpulse, normal);\r\n                        draw.DrawSegment(p1, p2, impulseColor, draw.context);\r\n                        const buffer = `${(1000.0 * point.normalImpulse).toFixed(2)}`;\r\n                        draw.DrawString(p1, buffer, draw.context);\r\n                    }\r\n\r\n                    if (draw.drawFrictionImpulses)\r\n                    {\r\n                        const tangent = b2RightPerp(normal);\r\n                        const p1 = new b2Vec2(point.pointX, point.pointY);\r\n                        const p2 = b2MulAdd(p1, k_impulseScale * point.tangentImpulse, tangent);\r\n                        draw.DrawSegment(p1, p2, frictionColor, draw.context);\r\n                        const buffer = `${point.normalImpulse.toFixed(2)}`;\r\n                        draw.DrawString(p1, buffer, draw.context);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_GetBodyEvents\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance\r\n * @returns {b2BodyEvents} An object containing an array of body move events and their count\r\n * @description\r\n * Retrieves the body movement events from a Box2D world. Returns an empty events object\r\n * if the world is locked. The function copies the world's body move event array and count\r\n * into a new b2BodyEvents object.\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n */\r\nexport function b2World_GetBodyEvents(worldId)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2BodyEvents();\r\n    }\r\n\r\n    const count = world.bodyMoveEventArray.length;\r\n    const events = new b2BodyEvents();\r\n    events.moveEvents = world.bodyMoveEventArray;\r\n    events.moveCount = count;\r\n\r\n    return events;\r\n}\r\n\r\n/**\r\n * @function b2World_GetSensorEvents\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @returns {b2SensorEvents} An object containing arrays of sensor begin and end events\r\n * @description\r\n * Retrieves the sensor events from a Box2D world. The function returns both begin and end\r\n * sensor events that occurred during the simulation step. If the world is locked, it returns\r\n * an empty events object.\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n */\r\nexport function b2World_GetSensorEvents(worldId)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2SensorEvents();\r\n    }\r\n\r\n    const beginCount = world.sensorBeginEventArray.length;\r\n    const endCount = world.sensorEndEventArray.length;\r\n\r\n    const events = new b2SensorEvents();\r\n    events.beginEvents = world.sensorBeginEventArray;\r\n    events.endEvents = world.sensorEndEventArray;\r\n    events.beginCount = beginCount;\r\n    events.endCount = endCount;\r\n\r\n    return events;\r\n}\r\n\r\n/**\r\n * @function b2World_GetContactEvents\r\n * @summary Retrieves the contact events from a Box2D world.\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world.\r\n * @returns {b2ContactEvents} An object containing arrays of begin, end, and hit contact events,\r\n * along with their respective counts.\r\n * @throws {Error} Throws an assertion error if the world is locked.\r\n * @description\r\n * Returns a b2ContactEvents object containing three arrays: contactBeginArray,\r\n * contactEndArray, and contactHitArray, representing different types of contact\r\n * events that occurred in the physics simulation. The object also includes\r\n * count values for each type of event.\r\n */\r\nexport function b2World_GetContactEvents(worldId)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return new b2ContactEvents();\r\n    }\r\n\r\n    const beginCount = world.contactBeginArray.length;\r\n    const endCount = world.contactEndArray.length;\r\n    const hitCount = world.contactHitArray.length;\r\n\r\n    const events = new b2ContactEvents();\r\n    events.beginEvents = world.contactBeginArray;\r\n    events.endEvents = world.contactEndArray;\r\n    events.hitEvents = world.contactHitArray;\r\n    events.beginCount = beginCount;\r\n    events.endCount = endCount;\r\n    events.hitCount = hitCount;\r\n\r\n    return events;\r\n}\r\n\r\n/**\r\n * Validates a Box2D world identifier.\r\n * @function b2World_IsValid\r\n * @param {b2WorldId} id - The world identifier to validate, containing index1 and revision properties\r\n * @returns {boolean} True if the world ID is valid and matches the stored world revision, false otherwise\r\n * @description\r\n * Checks if a world ID is valid by verifying:\r\n * 1. The ID is not undefined\r\n * 2. The index is within valid bounds (1 to B2_MAX_WORLDS)\r\n * 3. The world exists at the specified index\r\n * 4. The revision number matches the world's current revision\r\n */\r\nexport function b2World_IsValid(id)\r\n{\r\n    if (id === undefined)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    if (id.index1 < 1 || B2_MAX_WORLDS < id.index1)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const world = b2_worlds[id.index1 - 1];\r\n\r\n    if (world.worldId !== id.index1 - 1)\r\n    {\r\n        // world is not allocated\r\n        return false;\r\n    }\r\n\r\n    return id.revision === world.revision;\r\n}\r\n\r\n/**\r\n * @function b2Body_IsValid\r\n * @summary Validates a body ID to ensure it references a valid body in the physics world.\r\n * @param {b2BodyId} id - The body ID to validate\r\n * @returns {boolean} True if the ID is valid and references an existing body, false otherwise\r\n * @description\r\n * Performs validation checks on a body ID including:\r\n * - Verifies the ID is defined and is a b2BodyId instance\r\n * - Checks the world index is within valid bounds\r\n * - Confirms the world exists and matches the ID\r\n * - Validates the body index exists in the world\r\n * - Ensures the body is active and the revision number matches\r\n */\r\nexport function b2Body_IsValid(id)\r\n{\r\n    if (id === undefined)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    if (!(id instanceof b2BodyId))\r\n    {\r\n        console.error(`Invalid ID:\\n${new Error().stack}`);\r\n\r\n        return false;\r\n    }\r\n\r\n    if (id.world0 < 0 || B2_MAX_WORLDS <= id.world0)\r\n    {\r\n        // invalid world\r\n        return false;\r\n    }\r\n\r\n    const world = b2_worlds[id.world0];\r\n\r\n    if (world.worldId !== id.world0)\r\n    {\r\n        // world is free\r\n        return false;\r\n    }\r\n\r\n    if (id.index1 < 1 || world.bodyArray.length < id.index1)\r\n    {\r\n        // invalid index\r\n        return false;\r\n    }\r\n\r\n    const body = world.bodyArray[id.index1 - 1];\r\n\r\n    if (body.setIndex === B2_NULL_INDEX)\r\n    {\r\n        // this was freed\r\n        return false;\r\n    }\r\n\r\n    console.assert(body.localIndex != B2_NULL_INDEX);\r\n\r\n    if (body.revision !== id.revision)\r\n    {\r\n        // this id is orphaned\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Validates a shape ID to ensure it references a valid shape in a valid world.\r\n * @function b2Shape_IsValid\r\n * @param {b2ShapeId} id - The shape ID to validate, containing world0, index1, and revision properties\r\n * @returns {boolean} True if the shape ID is valid and references an existing shape, false otherwise\r\n * @description\r\n * Checks if a shape ID is valid by verifying:\r\n * - The ID exists and is not undefined\r\n * - The world index is within bounds\r\n * - The referenced world exists and matches the world ID\r\n * - The shape index is within bounds of the world's shape array\r\n * - The shape exists and is not marked as null\r\n * - The shape revision matches the ID's revision\r\n */\r\nexport function b2Shape_IsValid(id)\r\n{\r\n    if (id === undefined)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    if (B2_MAX_WORLDS <= id.world0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const world = b2_worlds[id.world0];\r\n\r\n    if (world.worldId !== id.world0)\r\n    {\r\n        // world is free\r\n        return false;\r\n    }\r\n\r\n    const shapeId = id.index1 - 1;\r\n\r\n    if (shapeId < 0 || world.shapeArray.length <= shapeId)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    if (shape.id === B2_NULL_INDEX)\r\n    {\r\n        // shape is free\r\n        return false;\r\n    }\r\n\r\n    console.assert(shape.id == shapeId);\r\n\r\n    return id.revision === shape.revision;\r\n}\r\n\r\n/**\r\n * Validates a b2ChainId to ensure it references a valid chain in the Box2D world system.\r\n * @function b2Chain_IsValid\r\n * @param {b2ChainId} id - The chain identifier containing world0 (world index),\r\n * index1 (chain index), and revision properties\r\n * @returns {boolean} Returns true if the chain ID is valid and matches the current revision,\r\n * false otherwise\r\n * @description\r\n * Checks if a chain ID is valid by verifying:\r\n * - The ID exists\r\n * - The world index is within valid bounds\r\n * - The world exists and matches the ID\r\n * - The chain index is within valid bounds\r\n * - The chain exists and is not null\r\n * - The revision number matches\r\n */\r\nexport function b2Chain_IsValid(id)\r\n{\r\n    if (id === undefined)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    if (id.world0 < 0 || B2_MAX_WORLDS <= id.world0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const world = b2_worlds[id.world0];\r\n\r\n    if (world.worldId !== id.world0)\r\n    {\r\n        // world is free\r\n        return false;\r\n    }\r\n\r\n    const chainId = id.index1 - 1;\r\n\r\n    if (chainId < 0 || world.chainArray.length <= chainId)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const chain = world.chainArray[chainId];\r\n\r\n    if (chain.id === B2_NULL_INDEX)\r\n    {\r\n        // chain is free\r\n        return false;\r\n    }\r\n\r\n    console.assert(chain.id == chainId);\r\n\r\n    return id.revision === chain.revision;\r\n}\r\n\r\n/**\r\n * Validates a joint ID to ensure it references a valid joint in the Box2D world.\r\n * @function b2Joint_IsValid\r\n * @param {b2JointId} id - The joint ID to validate, containing world0 (world index),\r\n * index1 (joint index), and revision properties\r\n * @returns {boolean} True if the joint ID is valid and references an existing joint,\r\n * false otherwise\r\n * @description\r\n * Checks if a joint ID is valid by verifying:\r\n * - The world index is within bounds\r\n * - The referenced world exists and matches the ID\r\n * - The joint index is within bounds\r\n * - The joint exists and is not null\r\n * - The revision number matches the joint's revision\r\n */\r\nexport function b2Joint_IsValid(id)\r\n{\r\n    if (id === undefined)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    if (id.world0 < 0 || B2_MAX_WORLDS <= id.world0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const world = b2_worlds[id.world0];\r\n\r\n    if (world.worldId !== id.world0)\r\n    {\r\n        // world is free\r\n        return false;\r\n    }\r\n\r\n    const jointId = id.index1 - 1;\r\n\r\n    if (jointId < 0 || world.jointArray.length <= jointId)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const joint = world.jointArray[jointId];\r\n\r\n    if (joint.jointId === B2_NULL_INDEX)\r\n    {\r\n        // joint is free\r\n        return false;\r\n    }\r\n\r\n    console.assert(joint.jointId == jointId);\r\n\r\n    return id.revision === joint.revision;\r\n}\r\n\r\n/**\r\n * @function b2World_EnableSleeping\r\n * @summary Controls the sleep state management of bodies in a Box2D world.\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world.\r\n * @param {boolean} flag - When true, enables sleep management. When false, wakes all sleeping bodies.\r\n * @returns {void}\r\n * @description\r\n * Enables or disables the sleep management system for the specified Box2D world.\r\n * When sleep is disabled, all sleeping bodies are awakened. The function has no effect\r\n * if the world is locked or if the requested sleep state matches the current state.\r\n * @throws {Error} Throws an assertion error if the world is locked.\r\n */\r\nexport function b2World_EnableSleeping(worldId, flag)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (flag === world.enableSleep)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.enableSleep = flag;\r\n\r\n    if (flag === false)\r\n    {\r\n        const setCount = world.solverSetArray.length;\r\n\r\n        for (let i = b2SetType.b2_firstSleepingSet; i < setCount; ++i)\r\n        {\r\n            const set = world.solverSetArray[i];\r\n\r\n            if (set.sims.length > 0)\r\n            {\r\n                b2WakeSolverSet(world, i);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_EnableWarmStarting\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance\r\n * @param {boolean} flag - Boolean value to enable or disable warm starting\r\n * @returns {void}\r\n * @description\r\n * Enables or disables warm starting for the specified Box2D world. Warm starting\r\n * cannot be modified while the world is locked. If the world is locked when this\r\n * function is called, the function will return without making any changes.\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n */\r\nexport function b2World_EnableWarmStarting(worldId, flag)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.enableWarmStarting = flag;\r\n}\r\n\r\n/**\r\n * @function b2World_EnableContinuous\r\n * @summary Enables or disables continuous collision detection for a Box2D world.\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world.\r\n * @param {boolean} flag - True to enable continuous collision detection, false to disable it.\r\n * @returns {void}\r\n * @description\r\n * Sets the continuous collision detection state for the specified Box2D world.\r\n * The function will not execute if the world is currently locked.\r\n * @throws {Error} Throws an assertion error if the world is locked when this function is called.\r\n */\r\nexport function b2World_EnableContinuous(worldId, flag)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.enableContinuous = flag;\r\n}\r\n\r\n/**\r\n * @function b2World_SetRestitutionThreshold\r\n * @summary Sets the restitution threshold for a Box2D world.\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world.\r\n * @param {number} value - The restitution threshold value to set.\r\n * @returns {void}\r\n * @description\r\n * Sets the restitution threshold for collision response in the specified Box2D world.\r\n * The value is clamped between 0 and Number.MAX_VALUE. The function will not execute\r\n * if the world is locked.\r\n * @throws {Error} Throws an assertion error if attempting to modify a locked world.\r\n */\r\nexport function b2World_SetRestitutionThreshold(worldId, value)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.restitutionThreshold = Math.max(0, Math.min(value, Number.MAX_VALUE));\r\n}\r\n\r\n/**\r\n * @function b2World_SetHitEventThreshold\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance\r\n * @param {number} value - The new hit event threshold value to set\r\n * @returns {void}\r\n * @description\r\n * Sets the hit event threshold for a Box2D world. The value is clamped between 0 and Number.MAX_VALUE.\r\n * The function will not execute if the world is locked.\r\n * @throws {Error} Throws an assertion error if the world is locked\r\n */\r\nexport function b2World_SetHitEventThreshold(worldId, value)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.hitEventThreshold = Math.max(0, Math.min(value, Number.MAX_VALUE));\r\n}\r\n\r\n/**\r\n * Sets the contact tuning parameters for a Box2D world.\r\n * @function b2World_SetContactTuning\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world.\r\n * @param {number} hertz - The frequency for contact constraint solving.\r\n * @param {number} dampingRatio - The damping ratio for contact constraint solving.\r\n * @param {number} pushOut - The velocity used for contact separation.\r\n * @returns {void}\r\n * @description\r\n * Sets three contact-related parameters for physics simulation: the constraint frequency (hertz),\r\n * damping ratio, and push-out velocity. All input parameters are clamped between 0 and MAX_VALUE.\r\n * The function will not execute if the world is locked.\r\n * @throws {Error} Throws an assertion error if attempting to modify a locked world.\r\n */\r\nexport function b2World_SetContactTuning(worldId, hertz, dampingRatio, pushOut)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    world.contactHertz = b2ClampFloat(hertz, 0.0, Number.MAX_VALUE);\r\n    world.contactDampingRatio = b2ClampFloat(dampingRatio, 0.0, Number.MAX_VALUE);\r\n    world.contactPushoutVelocity = b2ClampFloat(pushOut, 0.0, Number.MAX_VALUE);\r\n}\r\n\r\nexport function b2World_SetJointTuning(worldId, hertz, dampingRatio)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n    world.jointHertz = b2ClampFloat(hertz, 0.0, Number.MAX_VALUE);\r\n    world.jointDampingRatio = b2ClampFloat(dampingRatio, 0.0, Number.MAX_VALUE);\r\n}\r\n\r\n/**\r\n * @summary Dumps memory statistics for a Box2D world (Not supported in Phaser Box2D JS)\r\n * @function b2World_DumpMemoryStats\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @returns {void}\r\n * @description\r\n * This function is a stub that displays a warning message indicating that memory statistics\r\n * dumping is not supported in the Phaser Box2D JavaScript implementation.\r\n */\r\nexport function b2World_DumpMemoryStats(worldId)\r\n{\r\n    // This function writes to a file, which is not directly applicable in JS.\r\n    // You might want to modify this to return a string or object with the memory stats instead.\r\n    console.error(\"Memory stats not implemented\");\r\n}\r\n\r\nfunction TreeQueryCallback(proxyId, shapeId, context)\r\n{\r\n    const worldContext = context;\r\n    const world = worldContext.world;\r\n\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    const shapeFilter = shape.filter;\r\n    const queryFilter = worldContext.filter;\r\n\r\n    if ((shapeFilter.categoryBits & queryFilter.maskBits) === 0 || (shapeFilter.maskBits & queryFilter.categoryBits) === 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const id = new b2ShapeId(shapeId + 1, world.worldId, shape.revision);\r\n    const result = worldContext.fcn(id, worldContext.userContext);\r\n\r\n    return result;\r\n}\r\n\r\nclass WorldQueryContext\r\n{\r\n    constructor(world = null, fcn = null, filter = null, userContext = null)\r\n    {\r\n        this.world = world;\r\n        this.fcn = fcn;\r\n        this.filter = filter;\r\n        this.userContext = userContext;\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_OverlapAABB\r\n * @summary Queries an AABB region in the physics world for overlapping fixtures\r\n * @param {b2WorldId} worldId - The ID of the physics world to query\r\n * @param {b2AABB} aabb - The axis-aligned bounding box defining the query region\r\n * @param {b2QueryFilter} filter - Filter settings to control which fixtures are included\r\n * @param {b2OverlapResultFcn} fcn - Callback function that receives each overlapping fixture\r\n * @param {*} context - User context data passed to the callback function\r\n * @description\r\n * Performs a broadphase query using the world's dynamic tree to find all fixtures\r\n * that overlap with the given AABB. For each overlapping fixture that passes the\r\n * filter, the callback function is invoked.\r\n * @throws {Error} Throws an assertion error if the world is locked or if the AABB is invalid\r\n */\r\nexport function b2World_OverlapAABB(worldId, aabb, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2AABB_IsValid(aabb));\r\n\r\n    const worldContext = new WorldQueryContext(world, fcn, filter, context);\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Query(world.broadPhase.trees[i], aabb, filter.maskBits, TreeQueryCallback, worldContext);\r\n    }\r\n    \r\n}\r\n\r\nfunction TreeOverlapCallback(proxyId, shapeId, context)\r\n{\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n\r\n    const worldContext = context;\r\n    const world = worldContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    const shapeFilter = shape.filter;\r\n    const queryFilter = worldContext.filter;\r\n\r\n    if ((shapeFilter.categoryBits & queryFilter.maskBits) === 0 || (shapeFilter.maskBits & queryFilter.categoryBits) === 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = worldContext.proxy;\r\n    input.proxyB = b2MakeShapeDistanceProxy(shape);\r\n    input.transformA = worldContext.transform;\r\n    input.transformB = transform;\r\n    input.useRadii = true;\r\n\r\n    const cache = new b2DistanceCache();\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    if (output.distance > 0.0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const id = new b2ShapeId(shape.id + 1, world.worldId, shape.revision);\r\n    const result = worldContext.fcn(id, worldContext.userContext);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @function b2World_OverlapCircle\r\n * @summary Tests for overlaps between a circle shape and all shapes in the world.\r\n * @param {b2WorldId} worldId - The ID of the physics world\r\n * @param {b2Circle} circle - The circle shape to test for overlaps\r\n * @param {b2Transform} transform - The position and rotation transform of the circle\r\n * @param {b2QueryFilter} filter - Filtering options for the overlap test\r\n * @param {function} fcn - Callback function that handles overlap results\r\n * @param {*} context - User context data passed to the callback function\r\n * @description\r\n * Performs broad-phase AABB queries to find potential overlaps between the given circle\r\n * and all shapes in the world that match the filter criteria. For each potential overlap,\r\n * the callback function is invoked with the overlap details.\r\n * @throws {Error} Throws an assertion error if the world is locked or if the transform\r\n * contains invalid values.\r\n */\r\nexport function b2World_OverlapCircle(worldId, circle, transform, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(transform.p));\r\n    console.assert(b2Rot_IsValid(transform.q));\r\n\r\n    const aabb = b2ComputeCircleAABB(circle, transform);\r\n    const worldContext = new WorldOverlapContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.proxy = b2MakeProxy(circle.center, 1, circle.radius);\r\n    worldContext.transform = transform;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Query(world.broadPhase.trees[i], aabb, filter.maskBits, TreeOverlapCallback, worldContext);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_OverlapCapsule\r\n * @summary Performs overlap queries for a capsule shape against all shapes in the world.\r\n * @param {b2WorldId} worldId - The ID of the physics world\r\n * @param {b2Capsule} capsule - The capsule shape to test for overlaps\r\n * @param {b2Transform} transform - The position and rotation of the capsule\r\n * @param {b2QueryFilter} filter - Filtering options for the query\r\n * @param {b2OverlapResultFcn} fcn - Callback function that handles overlap results\r\n * @param {*} context - User context data passed to the callback function\r\n * @description\r\n * Tests a capsule shape against all shapes in the world that pass the filter criteria.\r\n * For each potential overlap, calls the provided callback function.\r\n * Uses a broad phase tree structure to efficiently find potential overlaps.\r\n * @throws {Error} Throws an assertion error if the world is locked or if the transform\r\n * contains invalid position/rotation values.\r\n */\r\nexport function b2World_OverlapCapsule(worldId, capsule, transform, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(transform.p));\r\n    console.assert(b2Rot_IsValid(transform.q));\r\n\r\n    const aabb = b2ComputeCapsuleAABB(capsule, transform);\r\n    const worldContext = new WorldOverlapContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.proxy = b2MakeProxy(capsule.center1, 2, capsule.radius);\r\n    worldContext.transform = transform;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Query(world.broadPhase.trees[i], aabb, filter.maskBits, TreeOverlapCallback, worldContext);\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_OverlapPolygon\r\n * @description\r\n * Performs overlap queries for a polygon shape against all shapes in the physics world\r\n * that match the provided filter criteria.\r\n * @param {b2WorldId} worldId - The identifier for the physics world\r\n * @param {b2Polygon} polygon - The polygon shape to test for overlaps\r\n * @param {b2Transform} transform - The position and rotation of the polygon\r\n * @param {b2QueryFilter} filter - Filtering criteria for the overlap test\r\n * @param {b2OverlapResultFcn} fcn - Callback function to handle overlap results\r\n * @param {void} context - User data passed to the callback function\r\n * @throws {Error} Throws an assertion error if the world is locked or if the transform\r\n * components are invalid\r\n */\r\nexport function b2World_OverlapPolygon(worldId, polygon, transform, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(transform.p));\r\n    console.assert(b2Rot_IsValid(transform.q));\r\n\r\n    const aabb = b2ComputePolygonAABB(polygon, transform);\r\n    const worldContext = new WorldOverlapContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.proxy = b2MakeProxy(polygon.vertices, polygon.count, polygon.radius),\r\n    worldContext.transform = transform;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_Query(world.broadPhase.trees[i], aabb, filter.maskBits, TreeOverlapCallback, worldContext);\r\n    }\r\n}\r\n\r\nfunction RayCastCallback(input, proxyId, shapeId, context)\r\n{\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n\r\n    const worldContext = context;\r\n    const world = worldContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n    const shapeFilter = shape.filter;\r\n    const queryFilter = worldContext.filter;\r\n\r\n    if ((shapeFilter.categoryBits & queryFilter.maskBits) === 0 || (shapeFilter.maskBits & queryFilter.categoryBits) === 0)\r\n    {\r\n        return input.maxFraction;\r\n    }\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n    const output = b2RayCastShape(input, shape, transform);\r\n\r\n    if (output.hit)\r\n    {\r\n        const id = new b2ShapeId(shapeId + 1, world.worldId, shape.revision);\r\n        const fraction = worldContext.fcn(id, output.point, output.normal, output.fraction, worldContext.userContext);\r\n\r\n        // The user may return -1 to skip this shape\r\n        if (fraction >= 0.0 && fraction <= 1.0)\r\n        {\r\n            worldContext.fraction = fraction;\r\n        }\r\n\r\n        return fraction;\r\n    }\r\n\r\n    return input.maxFraction;\r\n}\r\n\r\n/**\r\n * @function b2World_CastRay\r\n * @description\r\n * Performs a ray cast operation in the physics world to detect intersections between\r\n * a ray and physics bodies.\r\n * @param {b2WorldId} worldId - The ID of the physics world\r\n * @param {b2Vec2} origin - The starting point of the ray\r\n * @param {b2Vec2} translation - The direction and length of the ray\r\n * @param {b2QueryFilter} filter - Filtering options for the ray cast\r\n * @param {b2CastResultFcn} fcn - Callback function to handle ray cast results\r\n * @param {void} context - User context data passed to the callback\r\n * @returns {b2TreeStats}\r\n * @throws {Error} Throws assertion error if world is locked\r\n * @throws {Error} Throws assertion error if origin or translation vectors are invalid\r\n */\r\nexport function b2World_CastRay(worldId, origin, translation, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(origin));\r\n    console.assert(b2Vec2_IsValid(translation));\r\n\r\n    const input = new b2RayCastInput();\r\n    input.origin = origin;\r\n    input.translation = translation;\r\n    input.maxFraction = 1.0;\r\n\r\n    const worldContext = new WorldRayCastContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.fraction = 1.0;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_RayCast(world.broadPhase.trees[i], input, filter.maskBits, RayCastCallback, worldContext);\r\n\r\n        if (worldContext.fraction === 0.0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        input.maxFraction = worldContext.fraction;\r\n    }\r\n}\r\n\r\n// This callback finds the closest hit. This is the most common callback used in games.\r\nfunction b2RayCastClosestFcn(shapeId, point, normal, fraction, context)\r\n{\r\n    const rayResult = context;\r\n    rayResult.shapeId = shapeId;\r\n    rayResult.point = point;\r\n    rayResult.normal = normal;\r\n    rayResult.fraction = fraction;\r\n    rayResult.hit = true;\r\n\r\n    return fraction;\r\n}\r\n\r\n/**\r\n * Performs a ray cast operation to find the closest intersection in the physics world.\r\n * @function b2World_CastRayClosest\r\n * @param {b2WorldId} worldId - The identifier for the physics world\r\n * @param {b2Vec2} origin - The starting point of the ray\r\n * @param {b2Vec2} translation - The direction and length of the ray\r\n * @param {b2QueryFilter} filter - Filter settings for the ray cast\r\n * @returns {b2RayResult} Information about the closest intersection found\r\n * @description\r\n * Casts a ray through the physics world and returns information about the closest\r\n * intersection. The ray is defined by an origin point and a translation vector.\r\n * The operation checks all body types in the broad phase using a dynamic tree\r\n * structure.\r\n * @throws {Error} Throws an assertion error if the world is locked or if the\r\n * origin/translation vectors are invalid\r\n */\r\nexport function b2World_CastRayClosest(worldId, origin, translation, filter)\r\n{\r\n    const result = new b2RayResult();\r\n\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(origin));\r\n    console.assert(b2Vec2_IsValid(translation));\r\n\r\n    const input = new b2RayCastInput();\r\n    input.origin = origin;\r\n    input.translation = translation;\r\n    input.maxFraction = 1.0;\r\n    const worldContext = new WorldRayCastContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = b2RayCastClosestFcn;\r\n    worldContext.fraction = 1.0;\r\n    worldContext.userContext = result;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_RayCast(world.broadPhase.trees[i], input, filter.maskBits, RayCastCallback, worldContext);\r\n\r\n        if (worldContext.fraction == 0.0)\r\n        {\r\n            return result;\r\n        }\r\n\r\n        input.maxFraction = worldContext.fraction;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction ShapeCastCallback(input, proxyId, shapeId, context)\r\n{\r\n    const worldContext = context;\r\n    const world = worldContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n    const shapeFilter = shape.filter;\r\n    const queryFilter = worldContext.filter;\r\n\r\n    if ((shapeFilter.categoryBits & queryFilter.maskBits) == 0 || (shapeFilter.maskBits & queryFilter.categoryBits) == 0)\r\n    {\r\n        return input.maxFraction;\r\n    }\r\n\r\n    const body = b2GetBody(world, shape.bodyId);\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n    const output = b2ShapeCastShape(input, shape, transform);\r\n\r\n    if (output.hit)\r\n    {\r\n        const id = new b2ShapeId(shapeId + 1, world.worldId, shape.revision);\r\n        const fraction = worldContext.fcn(id, output.point, output.normal, output.fraction, worldContext.userContext);\r\n        worldContext.fraction = fraction;\r\n\r\n        return fraction;\r\n    }\r\n\r\n    return input.maxFraction;\r\n}\r\n\r\n/**\r\n * @function b2World_CastCircle\r\n * @summary Performs a shape cast of a circle through the physics world.\r\n * @param {b2WorldId} worldId - The identifier for the physics world\r\n * @param {b2Circle} circle - The circle shape to cast\r\n * @param {b2Transform} originTransform - The initial transform of the circle\r\n * @param {b2Vec2} translation - The displacement vector for the cast\r\n * @param {b2QueryFilter} filter - Filtering options for the cast\r\n * @param {b2CastResultFcn} fcn - Callback function to handle cast results\r\n * @param {void} context - User data passed to the callback function\r\n * @description\r\n * Casts a circle shape through the physics world from its initial position\r\n * along a translation vector, detecting collisions with other shapes. The cast\r\n * is performed against all body types in the broad phase, stopping if a collision\r\n * occurs at fraction 0.\r\n * @throws {Error} Throws an assertion error if the world is locked or if the\r\n * transform position, rotation, or translation vectors are invalid.\r\n */\r\nexport function b2World_CastCircle(worldId, circle, originTransform, translation, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(originTransform.p));\r\n    console.assert(b2Rot_IsValid(originTransform.q));\r\n    console.assert(b2Vec2_IsValid(translation));\r\n\r\n    const input = new b2ShapeCastInput();\r\n    input.points = [ b2TransformPoint(originTransform, circle.center) ];\r\n    input.count = 1;\r\n    input.radius = circle.radius;\r\n    input.translation = translation;\r\n    input.maxFraction = 1.0;\r\n\r\n    const worldContext = new WorldRayCastContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.fraction = 1.0;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_ShapeCast(world.broadPhase.trees[i], input, filter.maskBits, ShapeCastCallback, worldContext);\r\n\r\n        if (worldContext.fraction == 0.0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        input.maxFraction = worldContext.fraction;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_CastCapsule\r\n * @description\r\n * Performs a shape cast of a capsule through the physics world, detecting collisions\r\n * along the specified translation path.\r\n * @param {b2WorldId} worldId - The identifier for the physics world\r\n * @param {b2Capsule} capsule - The capsule shape to cast\r\n * @param {b2Transform} originTransform - The initial transform of the capsule, containing position (p) and rotation (q)\r\n * @param {b2Vec2} translation - The translation vector defining the cast path\r\n * @param {b2QueryFilter} filter - Filter settings for the cast operation\r\n * @param {b2CastResultFcn} fcn - Callback function to handle cast results\r\n * @param {void} context - User context data passed to the callback function\r\n * @throws {Error} Throws assertion error if world is locked or if transform/translation vectors are invalid\r\n */\r\nexport function b2World_CastCapsule(worldId, capsule, originTransform, translation, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(originTransform.p));\r\n    console.assert(b2Rot_IsValid(originTransform.q));\r\n    console.assert(b2Vec2_IsValid(translation));\r\n\r\n    const input = new b2ShapeCastInput();\r\n    input.points = [ b2TransformPoint(originTransform, capsule.center1), b2TransformPoint(originTransform, capsule.center2) ];\r\n    input.count = 2;\r\n    input.radius = capsule.radius;\r\n    input.translation = translation;\r\n    input.maxFraction = 1.0;\r\n\r\n    const worldContext = new WorldRayCastContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.fraction = 1.0;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_ShapeCast(world.broadPhase.trees[i], input, filter.maskBits, ShapeCastCallback, worldContext);\r\n\r\n        if (worldContext.fraction == 0.0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        input.maxFraction = worldContext.fraction;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_CastPolygon\r\n * @description\r\n * Performs a shape cast of a polygon through the physics world, detecting collisions along the way.\r\n * @param {b2WorldId} worldId - ID of the physics world\r\n * @param {b2Polygon} polygon - The polygon shape to cast\r\n * @param {b2Transform} originTransform - Initial transform of the polygon, containing position and rotation\r\n * @param {b2Vec2} translation - The displacement vector to cast the polygon along\r\n * @param {b2QueryFilter} filter - Filter to determine which fixtures to check against\r\n * @param {b2CastResultFcn} fcn - Callback function to handle cast results\r\n * @param {*} context - User context data passed to the callback function\r\n * @throws {Error} Throws assertion error if world is locked or if transform/translation vectors are invalid\r\n */\r\nexport function b2World_CastPolygon(worldId, polygon, originTransform, translation, filter, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked == false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    console.assert(b2Vec2_IsValid(originTransform.p));\r\n    console.assert(b2Rot_IsValid(originTransform.q));\r\n    console.assert(b2Vec2_IsValid(translation));\r\n\r\n    const input = new b2ShapeCastInput();\r\n    input.points = polygon.vertices.map(vertex => b2TransformPoint(originTransform, vertex));\r\n    input.count = polygon.count;\r\n    input.radius = polygon.radius;\r\n    input.translation = translation;\r\n    input.maxFraction = 1.0;\r\n\r\n    const worldContext = new WorldRayCastContext();\r\n    worldContext.world = world;\r\n    worldContext.fcn = fcn;\r\n    worldContext.filter = filter;\r\n    worldContext.fraction = 1.0;\r\n    worldContext.userContext = context;\r\n\r\n    for (let i = 0; i < b2BodyType.b2_bodyTypeCount; ++i)\r\n    {\r\n        b2DynamicTree_ShapeCast(world.broadPhase.trees[i], input, filter.maskBits, ShapeCastCallback, worldContext);\r\n\r\n        if (worldContext.fraction == 0.0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        input.maxFraction = worldContext.fraction;\r\n    }\r\n}\r\n\r\n/**\r\n * @function b2World_SetPreSolveCallback\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance\r\n * @param {b2PreSolveFcn} fcn - The pre-solve callback function to be executed\r\n * @param {void} context - User data pointer passed to the callback function\r\n * @returns {void}\r\n * @description\r\n * Sets a callback function that is invoked before the physics solver runs.\r\n * The callback receives the provided context pointer when executed.\r\n */\r\nexport function b2World_SetPreSolveCallback(worldId, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    world.preSolveFcn = fcn;\r\n    world.preSolveContext = context;\r\n}\r\n\r\n/**\r\n * @summary Sets a custom filter callback for a Box2D world.\r\n * @function b2World_SetCustomFilterCallback\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance.\r\n * @param {b2CustomFilterFcn} fcn - The custom filter callback function.\r\n * @param {void} context - A pointer to user-defined context data.\r\n * @returns {void}\r\n * @description\r\n * Sets a custom filter callback function for a Box2D world instance. The callback\r\n * can be used to implement custom collision filtering logic. The context parameter\r\n * allows passing additional data to the callback function.\r\n */\r\nexport function b2World_SetCustomFilterCallback(worldId, fcn, context)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    world.customFilterFcn = fcn;\r\n    world.customFilterContext = context;\r\n}\r\n\r\n/**\r\n * @summary Sets the gravity vector for a Box2D world.\r\n * @function b2World_SetGravity\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance.\r\n * @param {b2Vec2} gravity - The gravity vector to apply to the world. Defaults to (0,0).\r\n * @returns {void}\r\n * @description\r\n * Updates the gravity vector of the specified Box2D world. The gravity vector\r\n * defines the global acceleration applied to all dynamic bodies in the world.\r\n */\r\nexport function b2World_SetGravity(worldId, gravity)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    world.gravity = gravity;\r\n}\r\n\r\n/**\r\n * @summary Gets the gravity vector from a Box2D world instance.\r\n * @function b2World_GetGravity\r\n * @param {b2WorldId} worldId - The identifier for the Box2D world instance.\r\n * @returns {b2Vec2} The gravity vector of the world. A 2D vector with x and y components.\r\n * @description\r\n * Retrieves the current gravity vector from the specified Box2D world instance.\r\n * The gravity vector represents the global gravity force applied to all dynamic bodies in the world.\r\n */\r\nexport function b2World_GetGravity(worldId)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n\r\n    return world.gravity;\r\n}\r\n\r\nclass ExplosionContext\r\n{\r\n    constructor(world, position, radius, magnitude)\r\n    {\r\n        this.world = world;\r\n        this.position = position;\r\n        this.radius = radius;\r\n        this.magnitude = magnitude;\r\n    }\r\n}\r\n\r\nfunction ExplosionCallback(proxyId, shapeId, context)\r\n{\r\n    // B2_MAYBE_UNUSED(proxyId);\r\n    const explosionContext = context;\r\n    const world = explosionContext.world;\r\n\r\n    // b2CheckId(world.shapeArray, shapeId);\r\n    const shape = world.shapeArray[shapeId];\r\n\r\n    // b2CheckId(world.bodyArray, shape.bodyId);\r\n    const body = world.bodyArray[shape.bodyId];\r\n\r\n    if (body.type === b2BodyType.b2_kinematicBody)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    b2WakeBody(world, body);\r\n\r\n    if (body.setIndex !== b2SetType.b2_awakeSet)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const transform = b2GetBodyTransformQuick(world, body);\r\n    const input = new b2DistanceInput();\r\n    input.proxyA = b2MakeShapeDistanceProxy(shape);\r\n    input.proxyB = b2MakeProxy([ explosionContext.position ], 1, 0.0);\r\n    input.transformA = transform;\r\n    input.transformB = new b2Transform(new b2Vec2(0, 0), new b2Rot(1, 0));\r\n    input.useRadii = true;\r\n\r\n    const cache = new b2DistanceCache();\r\n    const output = b2ShapeDistance(cache, input, null, 0);\r\n\r\n    if (output.distance > explosionContext.radius)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    let closestPoint = output.pointA;\r\n\r\n    if (output.distance === 0.0)\r\n    {\r\n        const localCentroid = b2GetShapeCentroid(shape);\r\n        closestPoint = b2TransformPoint(transform, localCentroid);\r\n    }\r\n\r\n    const falloff = 0.4;\r\n    const perimeter = b2GetShapePerimeter(shape);\r\n    const magnitude = explosionContext.magnitude * perimeter * (1.0 - falloff * output.distance / explosionContext.radius);\r\n    const direction = b2Normalize(b2Sub(closestPoint, explosionContext.position));\r\n    const impulse = b2MulSV(magnitude, direction);\r\n\r\n    const localIndex = body.localIndex;\r\n    const set = world.solverSetArray[b2SetType.b2_awakeSet];\r\n    console.assert(0 <= localIndex && localIndex < set.states.count);\r\n    const state = set.states.data[localIndex];\r\n    const bodySim = set.sims.data[localIndex];\r\n\r\n    state.linearVelocity = b2MulAdd(state.linearVelocity, bodySim.invMass, impulse);\r\n    state.angularVelocity += bodySim.invInertia * b2Cross(b2Sub(closestPoint, bodySim.center), impulse);\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @function b2World_Explode\r\n * @summary Creates an explosion effect that applies forces to nearby dynamic bodies\r\n * @param {b2WorldId} worldId - The ID of the Box2D world\r\n * @param {b2Vec2} position - The center point of the explosion\r\n * @param {number} radius - The radius of the explosion effect\r\n * @param {number} magnitude - The force magnitude of the explosion\r\n * @returns {void}\r\n * @description\r\n * Creates a circular explosion centered at the given position that applies radial forces\r\n * to dynamic bodies within the explosion radius. The explosion force decreases with\r\n * distance from the center point.\r\n * @throws {Error} Throws assertion errors if:\r\n * - position is invalid\r\n * - radius is invalid or <= 0\r\n * - magnitude is invalid\r\n * - world is locked\r\n */\r\nexport function b2World_Explode(worldId, position, radius, magnitude)\r\n{\r\n    console.assert(b2Vec2_IsValid(position));\r\n    console.assert(b2IsValid(radius) && radius > 0.0);\r\n    console.assert(b2IsValid(magnitude));\r\n    const world = b2GetWorldFromId(worldId);\r\n    console.assert(world.locked === false);\r\n\r\n    if (world.locked)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const explosionContext = new ExplosionContext(world, position, radius, magnitude);\r\n    const aabb = new b2AABB(position.x - radius, position.y - radius, position.x + radius, position.y + radius);\r\n\r\n    b2DynamicTree_Query(\r\n        world.broadPhase.trees[b2BodyType.b2_dynamicBody],\r\n        aabb,\r\n        B2_DEFAULT_MASK_BITS,\r\n        ExplosionCallback,\r\n        explosionContext\r\n    );\r\n}\r\n\r\nfunction b2GetRootIslandId(world, islandId)\r\n{\r\n    if (islandId === B2_NULL_INDEX)\r\n    {\r\n        return B2_NULL_INDEX;\r\n    }\r\n\r\n    let rootId = islandId;\r\n    let rootIsland = world.islandArray[islandId];\r\n\r\n    while (rootIsland.parentIsland !== B2_NULL_INDEX)\r\n    {\r\n        const parent = world.islandArray[rootIsland.parentIsland];\r\n        rootId = rootIsland.parentIsland;\r\n        rootIsland = parent;\r\n    }\r\n\r\n    return rootId;\r\n}\r\n\r\nexport function b2CheckId(a, id)\r\n{\r\n    console.assert( 0 <= id && id < a.length && a[id].id == id );\r\n}\r\n\r\nexport function b2CheckIndex(a, i)\r\n{\r\n    if (Array.isArray(a))\r\n    { console.assert(0 <= i && i < a.length); }\r\n    else\r\n    { console.assert(0 <= i && i < a.count); }\r\n}\r\n\r\nexport function b2ValidateConnectivity(world)\r\n{\r\n    if (!b2Validation) { return; }\r\n\r\n    const bodyCapacity = world.bodyArray.length;\r\n\r\n    for (let bodyIndex = 0; bodyIndex < bodyCapacity; ++bodyIndex)\r\n    {\r\n        const body = world.bodyArray[bodyIndex];\r\n\r\n        if (body.id === B2_NULL_INDEX)\r\n        {\r\n            // b2ValidateFreeId(world.bodyIdPool, bodyIndex);\r\n            continue;\r\n        }\r\n\r\n        console.assert(bodyIndex === body.id);\r\n\r\n        const bodyIslandId = b2GetRootIslandId(world, body.islandId);\r\n        const bodySetIndex = body.setIndex;\r\n\r\n        let contactKey = body.headContactKey;\r\n\r\n        while (contactKey !== B2_NULL_INDEX)\r\n        {\r\n            const contactId = contactKey >> 1;\r\n            const edgeIndex = contactKey & 1;\r\n\r\n            const contact = world.contactArray[contactId];\r\n\r\n            const touching = (contact.flags & b2ContactFlags.b2_contactTouchingFlag) !== 0;\r\n\r\n            if (touching && (contact.flags & b2ContactFlags.b2_contactSensorFlag) === 0)\r\n            {\r\n                if (bodySetIndex !== b2SetType.b2_staticSet)\r\n                {\r\n                    const contactIslandId = b2GetRootIslandId(world, contact.islandId);\r\n                    console.assert(contactIslandId === bodyIslandId);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                console.assert(contact.islandId === B2_NULL_INDEX);\r\n            }\r\n\r\n            contactKey = contact.edges[edgeIndex].nextKey;\r\n        }\r\n\r\n        let jointKey = body.headJointKey;\r\n\r\n        while (jointKey !== B2_NULL_INDEX)\r\n        {\r\n            const jointId = jointKey >> 1;\r\n            const edgeIndex = jointKey & 1;\r\n\r\n            const joint = world.jointArray[jointId];\r\n\r\n            const otherEdgeIndex = edgeIndex ^ 1;\r\n\r\n            const otherBody = world.bodyArray[joint.edges[otherEdgeIndex].bodyId];\r\n\r\n            if (bodySetIndex === b2SetType.b2_disabledSet || otherBody.setIndex === b2SetType.b2_disabledSet)\r\n            {\r\n                console.assert(joint.islandId === B2_NULL_INDEX);\r\n            }\r\n            else if (bodySetIndex === b2SetType.b2_staticSet)\r\n            {\r\n                if (otherBody.setIndex === b2SetType.b2_staticSet)\r\n                {\r\n                    console.assert(joint.islandId === B2_NULL_INDEX);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                const jointIslandId = b2GetRootIslandId(world, joint.islandId);\r\n                console.assert(jointIslandId === bodyIslandId);\r\n            }\r\n\r\n            jointKey = joint.edges[edgeIndex].nextKey;\r\n        }\r\n    }\r\n}\r\n\r\nexport function b2ValidateSolverSets(world)\r\n{\r\n    if (!b2Validation) { return; }\r\n\r\n    let activeSetCount = 0;\r\n    let totalBodyCount = 0;\r\n    let totalJointCount = 0;\r\n    let totalContactCount = 0;\r\n    let totalIslandCount = 0;\r\n\r\n    // Validate all solver sets\r\n    const setCount = world.solverSetArray.length;\r\n\r\n    for (let setIndex = 0; setIndex < setCount; ++setIndex)\r\n    {\r\n        const set = world.solverSetArray[setIndex];\r\n\r\n        if (set.setIndex !== B2_NULL_INDEX)\r\n        {\r\n            activeSetCount += 1;\r\n\r\n            if (setIndex === b2SetType.b2_staticSet)\r\n            {\r\n                console.assert(set.contacts.count === 0);\r\n                console.assert(set.islands.count === 0);\r\n                console.assert(set.states.count === 0);\r\n            }\r\n            else if (setIndex === b2SetType.b2_awakeSet)\r\n            {\r\n                console.assert(set.sims.count === set.states.count);\r\n                console.assert(set.joints.count === 0);\r\n            }\r\n            else if (setIndex === b2SetType.b2_disabledSet)\r\n            {\r\n                console.assert(set.islands.count === 0);\r\n                console.assert(set.states.count === 0);\r\n            }\r\n            else\r\n            {\r\n                console.assert(set.states.count === 0);\r\n            }\r\n\r\n            // Validate bodies\r\n            {\r\n                const bodies = world.bodyArray;\r\n                console.assert(set.sims.count >= 0);\r\n                totalBodyCount += set.sims.count;\r\n\r\n                for (let i = 0; i < set.sims.count; ++i)\r\n                {\r\n                    const bodySim = set.sims.data[i];\r\n\r\n                    const bodyId = bodySim.bodyId;\r\n                    b2CheckIndex(bodies, bodyId);\r\n                    const body = bodies[bodyId];\r\n                    console.assert(body.setIndex === setIndex);\r\n                    console.assert(body.localIndex === i);\r\n\r\n                    // console.assert(body.revision === body.revision);\r\n\r\n                    if (setIndex === b2SetType.b2_disabledSet)\r\n                    {\r\n                        console.assert(body.headContactKey === B2_NULL_INDEX);\r\n                    }\r\n\r\n                    // Validate body shapes\r\n                    let prevShapeId = B2_NULL_INDEX;\r\n                    let shapeId = body.headShapeId;\r\n\r\n                    while (shapeId !== B2_NULL_INDEX)\r\n                    {\r\n                        b2CheckId(world.shapeArray, shapeId);\r\n                        const shape = world.shapeArray[shapeId];\r\n                        console.assert(shape.prevShapeId === prevShapeId);\r\n\r\n                        if (setIndex === b2SetType.b2_disabledSet)\r\n                        {\r\n                            console.assert(shape.proxyKey === B2_NULL_INDEX);\r\n                        }\r\n                        else if (setIndex === b2SetType.b2_staticSet)\r\n                        {\r\n                            console.assert(B2_PROXY_TYPE(shape.proxyKey) === b2BodyType.b2_staticBody);\r\n                        }\r\n                        else\r\n                        {\r\n                            const proxyType = B2_PROXY_TYPE(shape.proxyKey);\r\n                            console.assert(proxyType === b2BodyType.b2_kinematicBody || proxyType === b2BodyType.b2_dynamicBody);\r\n                        }\r\n\r\n                        prevShapeId = shapeId;\r\n                        shapeId = shape.nextShapeId;\r\n                    }\r\n\r\n                    // Validate body contacts\r\n                    let contactKey = body.headContactKey;\r\n\r\n                    while (contactKey !== B2_NULL_INDEX)\r\n                    {\r\n                        const contactId = contactKey >> 1;\r\n                        const edgeIndex = contactKey & 1;\r\n\r\n                        b2CheckIndex(world.contactArray, contactId);\r\n                        const contact = world.contactArray[contactId];\r\n                        console.assert(contact.setIndex !== b2SetType.b2_staticSet);\r\n                        console.assert(contact.edges[0].bodyId === bodyId || contact.edges[1].bodyId === bodyId);\r\n                        contactKey = contact.edges[edgeIndex].nextKey;\r\n                    }\r\n\r\n                    // Validate body joints\r\n                    let jointKey = body.headJointKey;\r\n\r\n                    while (jointKey !== B2_NULL_INDEX)\r\n                    {\r\n                        const jointId = jointKey >> 1;\r\n\r\n                        // console.warn(\"jointKey \" + jointKey);\r\n                        const edgeIndex = jointKey & 1;\r\n\r\n                        b2CheckIndex(world.jointArray, jointId);\r\n                        const joint = world.jointArray[jointId];\r\n\r\n                        // PJB: not sure about this...\r\n                        console.assert(joint.jointId == jointId);\r\n\r\n                        const otherEdgeIndex = edgeIndex ^ 1;\r\n\r\n                        b2CheckIndex(world.bodyArray, joint.edges[otherEdgeIndex].bodyId);\r\n                        const otherBody = world.bodyArray[joint.edges[otherEdgeIndex].bodyId];\r\n\r\n                        if (setIndex === b2SetType.b2_disabledSet || otherBody.setIndex === b2SetType.b2_disabledSet)\r\n                        {\r\n                            console.assert(joint.setIndex === b2SetType.b2_disabledSet);\r\n                        }\r\n                        else if (setIndex === b2SetType.b2_staticSet && otherBody.setIndex === b2SetType.b2_staticSet)\r\n                        {\r\n                            console.assert(joint.setIndex === b2SetType.b2_staticSet);\r\n                        }\r\n                        else if (setIndex === b2SetType.b2_awakeSet)\r\n                        {\r\n                            console.assert(joint.setIndex === b2SetType.b2_awakeSet);\r\n                        }\r\n                        else if (setIndex >= b2SetType.b2_firstSleepingSet)\r\n                        {\r\n                            console.assert(joint.setIndex === setIndex);\r\n                        }\r\n\r\n                        const jointSim = b2GetJointSim(world, joint);\r\n                        console.assert(jointSim.jointId === jointId);\r\n                        console.assert(jointSim.bodyIdA === joint.edges[0].bodyId);\r\n                        console.assert(jointSim.bodyIdB === joint.edges[1].bodyId);\r\n\r\n                        jointKey = joint.edges[edgeIndex].nextKey;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Validate contacts\r\n            {\r\n                const contacts = world.contactArray;\r\n                console.assert(set.contacts.count >= 0);\r\n                totalContactCount += set.contacts.count;\r\n\r\n                for (let i = 0; i < set.contacts.count; ++i)\r\n                {\r\n                    const contactSim = set.contacts.data[i];\r\n                    console.assert(0 <= contactSim.contactId && contactSim.contactId < contacts.length);\r\n                    const contact = contacts[contactSim.contactId];\r\n\r\n                    if (setIndex === b2SetType.b2_awakeSet)\r\n                    {\r\n                        console.assert(contactSim.manifold.pointCount === 0 ||\r\n                            (contactSim.simFlags & b2ContactSimFlags.b2_simStartedTouching) !== 0);\r\n                    }\r\n                    console.assert(contact.setIndex === setIndex);\r\n                    console.assert(contact.colorIndex === B2_NULL_INDEX);\r\n                    console.assert(contact.localIndex === i);\r\n                }\r\n            }\r\n\r\n            // Validate joints\r\n            {\r\n                const joints = world.jointArray;\r\n                console.assert(set.joints.count >= 0);\r\n                totalJointCount += set.joints.count;\r\n\r\n                for (let i = 0; i < set.joints.count; ++i)\r\n                {\r\n                    const jointSim = set.joints.data[i];\r\n                    console.assert(0 <= jointSim.jointId && jointSim.jointId < joints.length);\r\n                    const joint = joints[jointSim.jointId];\r\n                    console.assert(joint.setIndex === setIndex);\r\n                    console.assert(joint.colorIndex === B2_NULL_INDEX);\r\n                    console.assert(joint.localIndex === i);\r\n                }\r\n            }\r\n\r\n            // Validate islands\r\n            {\r\n                const islands = world.islandArray;\r\n                console.assert(set.islands.count >= 0);\r\n                totalIslandCount += set.islands.count;\r\n\r\n                for (let i = 0; i < set.islands.count; ++i)\r\n                {\r\n                    const islandSim = set.islands.data[i];\r\n                    console.assert(0 <= islandSim.islandId && islandSim.islandId < islands.length);\r\n                    const island = islands[islandSim.islandId];\r\n                    console.assert(island.setIndex === setIndex);\r\n                    console.assert(island.localIndex === i);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.assert(set.sims.count === 0);\r\n            console.assert(set.contacts.count === 0);\r\n            console.assert(set.joints.count === 0);\r\n            console.assert(set.islands.count === 0);\r\n            console.assert(set.states.count === 0);\r\n        }\r\n    }\r\n\r\n    const setIdCount = b2GetIdCount(world.solverSetIdPool);\r\n    console.assert(activeSetCount === setIdCount);\r\n\r\n    const bodyIdCount = b2GetIdCount(world.bodyIdPool);\r\n    console.assert(totalBodyCount === bodyIdCount);\r\n\r\n    const islandIdCount = b2GetIdCount(world.islandIdPool);\r\n    console.assert(totalIslandCount === islandIdCount);\r\n\r\n    // Validate constraint graph\r\n    for (let colorIndex = 0; colorIndex < b2_graphColorCount; ++colorIndex)\r\n    {\r\n        const color = world.constraintGraph.colors[colorIndex];\r\n\r\n        {\r\n            const contacts = world.contactArray;\r\n            console.assert(color.contacts.count >= 0);\r\n            totalContactCount += color.contacts.count;\r\n\r\n            for (let i = 0; i < color.contacts.count; ++i)\r\n            {\r\n                const contactSim = color.contacts.data[i];\r\n                b2CheckIndex(contacts, contactSim.contactId);\r\n                const contact = contacts[contactSim.contactId];\r\n                console.assert(contactSim.manifold.pointCount > 0 ||\r\n                    (contactSim.simFlags & (b2ContactSimFlags.b2_simStoppedTouching | b2ContactSimFlags.b2_simDisjoint)) !== 0);\r\n                console.assert(contact.setIndex === b2SetType.b2_awakeSet);\r\n                console.assert(contact.colorIndex === colorIndex);\r\n                console.assert(contact.localIndex === i);\r\n\r\n                const bodyIdA = contact.edges[0].bodyId;\r\n                const bodyIdB = contact.edges[1].bodyId;\r\n                b2CheckIndex(world.bodyArray, bodyIdA);\r\n                b2CheckIndex(world.bodyArray, bodyIdB);\r\n\r\n                if (colorIndex < b2_overflowIndex)\r\n                {\r\n                    const bodyA = world.bodyArray[bodyIdA];\r\n                    const bodyB = world.bodyArray[bodyIdB];\r\n                    console.assert(b2GetBit(color.bodySet, bodyIdA) === (bodyA.type !== b2BodyType.b2_staticBody));\r\n                    console.assert(b2GetBit(color.bodySet, bodyIdB) === (bodyB.type !== b2BodyType.b2_staticBody));\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            const joints = world.jointArray;\r\n            console.assert(color.joints.count >= 0);\r\n            totalJointCount += color.joints.count;\r\n\r\n            for (let i = 0; i < color.joints.count; ++i)\r\n            {\r\n                const jointSim = color.joints.data[i];\r\n                b2CheckIndex(joints, jointSim.jointId);\r\n                const joint = joints[jointSim.jointId];\r\n                console.assert(joint.setIndex === b2SetType.b2_awakeSet);\r\n                console.assert(joint.colorIndex === colorIndex);\r\n                console.assert(joint.localIndex === i);\r\n\r\n                const bodyIdA = joint.edges[0].bodyId;\r\n                const bodyIdB = joint.edges[1].bodyId;\r\n                b2CheckIndex(world.bodyArray, bodyIdA);\r\n                b2CheckIndex(world.bodyArray, bodyIdB);\r\n\r\n                if (colorIndex < b2_overflowIndex)\r\n                {\r\n                    const bodyA = world.bodyArray[bodyIdA];\r\n                    const bodyB = world.bodyArray[bodyIdB];\r\n                    console.assert(b2GetBit(color.bodySet, bodyIdA) === (bodyA.type !== b2BodyType.b2_staticBody));\r\n                    console.assert(b2GetBit(color.bodySet, bodyIdB) === (bodyB.type !== b2BodyType.b2_staticBody));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const contactIdCount = b2GetIdCount(world.contactIdPool);\r\n    console.assert(totalContactCount === contactIdCount);\r\n    console.assert(totalContactCount === world.broadPhase.pairSet.size, `totalContactCount ${totalContactCount} != pairSet.size ${world.broadPhase.pairSet.size}`);\r\n\r\n    const jointIdCount = b2GetIdCount(world.jointIdPool);\r\n    console.assert(totalJointCount === jointIdCount);\r\n}\r\n\r\nfunction b2GetBit(bitSet, bitIndex)\r\n{\r\n    const blockIndex = Math.floor(bitIndex / 64);\r\n\r\n    if (blockIndex >= bitSet.blockCount)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return (bitSet.bits[blockIndex] & (BigInt(1) << BigInt(bitIndex % 64))) !== BigInt(0);\r\n}\r\n\r\nexport function b2ValidateContacts(world)\r\n{\r\n    if (!b2Validation) { return; }\r\n    \r\n    const contactCount = world.contactArray.length;\r\n    console.assert(contactCount >= b2GetIdCapacity(world.contactIdPool));\r\n    let allocatedContactCount = 0;\r\n\r\n    for (let contactIndex = 0; contactIndex < contactCount; ++contactIndex)\r\n    {\r\n        const contact = world.contactArray[contactIndex];\r\n\r\n        if (contact.contactId === B2_NULL_INDEX)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        console.assert(contact.contactId === contactIndex);\r\n\r\n        allocatedContactCount += 1;\r\n\r\n        const touching = (contact.flags & b2ContactFlags.b2_contactTouchingFlag) !== 0;\r\n        const sensorTouching = (contact.flags & b2ContactFlags.b2_contactSensorTouchingFlag) !== 0;\r\n        const isSensor = (contact.flags & b2ContactFlags.b2_contactSensorFlag) !== 0;\r\n\r\n        console.assert(touching === false || sensorTouching === false);\r\n        console.assert(touching === false || isSensor === false);\r\n\r\n        const setId = contact.setIndex;\r\n\r\n        if (setId === b2SetType.b2_awakeSet)\r\n        {\r\n            if (touching && isSensor === false)\r\n            {\r\n                console.assert(0 <= contact.colorIndex && contact.colorIndex < b2_graphColorCount);\r\n            }\r\n            else\r\n            {\r\n                console.assert(contact.colorIndex === B2_NULL_INDEX);\r\n            }\r\n        }\r\n        else if (setId >= b2SetType.b2_firstSleepingSet)\r\n        {\r\n            console.assert(touching === true && isSensor === false);\r\n        }\r\n        else\r\n        {\r\n            console.assert(touching === false && setId === b2SetType.b2_disabledSet);\r\n        }\r\n\r\n        const contactSim = b2GetContactSim(world, contact);\r\n        console.assert(contactSim.contactId === contactIndex);\r\n        console.assert(contactSim._bodyIdA === contact.edges[0].bodyId, contact);\r\n        console.assert(contactSim._bodyIdB === contact.edges[1].bodyId);\r\n\r\n        const simTouching = (contactSim.simFlags & b2ContactSimFlags.b2_simTouchingFlag) !== 0;\r\n\r\n        console.assert(touching == simTouching || sensorTouching == simTouching, `failed: ${touching} or ${sensorTouching} == ${simTouching}`);\r\n        console.assert(0 <= contactSim.manifold.pointCount && contactSim.manifold.pointCount <= 2);\r\n    }\r\n\r\n    const contactIdCount = b2GetIdCount(world.contactIdPool);\r\n    console.assert(allocatedContactCount === contactIdCount);\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\n/**\r\n * @import {b2WorldId} from './id_h.js'\r\n */\r\n\r\nexport const b2_maxWorkers = 1;\r\n\r\nexport {\r\n    b2SetType, b2World,\r\n    b2CreateWorldArray,\r\n    b2GetWorldFromId, b2GetWorld, b2GetWorldLocked,\r\n    b2CreateWorld, b2World_Step, b2DestroyWorld,\r\n    b2World_Draw,\r\n    b2World_OverlapAABB, b2World_OverlapCapsule, b2World_OverlapCircle, b2World_OverlapPolygon,\r\n    b2World_Explode,\r\n    b2World_CastCapsule, b2World_CastCircle, b2World_CastPolygon, b2World_CastRay, b2World_CastRayClosest,\r\n    b2World_GetBodyEvents, b2World_GetContactEvents, b2World_GetGravity, b2World_GetSensorEvents,\r\n    b2World_SetContactTuning, b2World_SetJointTuning, b2World_SetPreSolveCallback, b2World_SetCustomFilterCallback,\r\n    b2World_SetGravity, b2World_SetHitEventThreshold, b2World_SetRestitutionThreshold,\r\n    b2World_IsValid, b2Joint_IsValid,\r\n    b2World_EnableSleeping, b2World_EnableContinuous, b2World_EnableWarmStarting,\r\n    b2ValidateConnectivity, b2ValidateSolverSets, b2ValidateContacts,\r\n    b2CheckIndex, b2Body_IsValid, b2Chain_IsValid, b2Shape_IsValid,\r\n} from '../world_c.js';\r\n\r\n/**\r\n * @summary Gets the performance profile data for a Box2D world.\r\n * @function b2World_GetProfile\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world.\r\n * @returns {void} A profile object containing performance metrics.\r\n * @description\r\n * This function returns performance profiling data for a Box2D world.\r\n * Not supported in Phaser Box2D JS implementation.\r\n */\r\nexport function b2World_GetProfile(worldId)\r\n{\r\n    console.warn(\"b2World_GetProfile not supported\");\r\n}\r\n\r\n/**\r\n * Gets the current counters from a Box2D world instance.\r\n * @function b2World_GetCounters\r\n * @param {b2WorldId} worldId - The ID of the Box2D world instance.\r\n * @returns {void} An object containing various Box2D performance counters.\r\n * @description\r\n * This function is not supported in the Phaser Box2D JS implementation and will\r\n * generate a console warning when called.\r\n */\r\nexport function b2World_GetCounters(worldId)\r\n{\r\n    console.warn(\"b2World_GetCounters not supported\");\r\n}\r\n\r\n/**\r\n * @summary Dumps memory statistics for a Box2D world (Not supported in Phaser Box2D JS)\r\n * @function b2World_DumpMemoryStats\r\n * @param {b2WorldId} worldId - The identifier of the Box2D world\r\n * @returns {void}\r\n * @description\r\n * This function is a stub that displays a warning message indicating that memory statistics\r\n * dumping is not supported in the Phaser Box2D JavaScript implementation.\r\n */\r\nexport function b2World_DumpMemoryStats(worldId)\r\n{\r\n    console.warn(\"b2World_DumpMemoryStats not supported\");\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { B2_MAX_POLYGON_VERTICES, b2Capsule, b2Circle } from './include/collision_h.js';\r\nimport { b2Add, b2Distance, b2RelativeAngle, b2Rot, b2MakeRot, b2Transform, b2Vec2 } from './include/math_functions_h.js';\r\nimport\r\n{\r\n    b2BodyType,\r\n    b2DefaultBodyDef,\r\n    b2DefaultShapeDef,\r\n    b2DefaultWorldDef,\r\n    b2DistanceJointDef,\r\n    b2HexColor,\r\n    b2MotorJointDef,\r\n    b2MouseJointDef,\r\n    b2PrismaticJointDef,\r\n    b2RevoluteJointDef,\r\n    b2WeldJointDef,\r\n    b2WheelJointDef\r\n} from './include/types_h.js';\r\nimport { b2Body_GetRotation, b2Body_GetTransform, b2Body_SetTransform, b2Body_SetUserData, b2CreateBody, b2DestroyBody, b2GetBodyTransform } from './include/body_h.js';\r\nimport { b2CreateCapsuleShape, b2CreateCircleShape, b2CreatePolygonShape } from './include/shape_h.js';\r\nimport { b2CreateDistanceJoint, b2CreateMotorJoint, b2CreateMouseJoint, b2CreatePrismaticJoint, b2CreateRevoluteJoint, b2CreateWeldJoint, b2CreateWheelJoint } from './include/joint_h.js';\r\nimport { b2CreateWorld, b2CreateWorldArray, b2World_Step } from './include/world_h.js';\r\nimport { b2MakeBox, b2MakeOffsetBox, b2MakeOffsetPolygon, b2MakePolygon } from './include/geometry_h.js';\r\n\r\nimport { DYNAMIC } from './main.js';\r\nimport { b2ComputeHull } from './include/hull_h.js';\r\n\r\n/**\r\n * @namespace Physics\r\n */\r\n\r\n/**\r\n * @import {b2WorldDef, b2ShapeDef, b2BodyDef} from './include/types_h.js'\r\n * @import {b2ShapeId, b2WorldId, b2BodyId, b2JointId} from './include/id_h.js'\r\n * @import {b2Polygon} from './include/collision_h.js'\r\n * @import {b2Body} from './include/body_h.js'\r\n */\r\n\r\n// local \r\n\r\nfunction setIfDef (obj, prop, value)\r\n{\r\n    if (value !== undefined)\r\n    {\r\n        obj[ prop ] = value;\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport const WorldSprites = new Map();\r\n\r\nlet SCALE = 30.0;\r\n\r\n/**\r\n * Set the scale of the Box2D World when converting from pixels to meters.\r\n *\r\n * @export\r\n * @param {number} scale\r\n */\r\nexport function SetWorldScale (scale)\r\n{\r\n    SCALE = scale;\r\n}\r\n\r\n/**\r\n * Get the current scale of the Box2D World, as used when converting from pixels to meters.\r\n *\r\n * @export\r\n * @returns {number}\r\n */\r\nexport function GetWorldScale ()\r\n{\r\n    return SCALE;\r\n}\r\n\r\n/**\r\n * Converts a single numerical value from meters to pixels.\r\n *\r\n * @export\r\n * @param {number} meters\r\n * @returns {number}\r\n */\r\nexport function mpx (meters)\r\n{\r\n    return meters * SCALE;\r\n}\r\n\r\n/**\r\n * Converts a single numerical value from pixels to meters.\r\n *\r\n * @export\r\n * @param {number} pixels\r\n * @returns {number}\r\n */\r\nexport function pxm (pixels)\r\n{\r\n    return pixels / SCALE;\r\n}\r\n\r\n/**\r\n * Converts the given x and y values from pixels to meters, stored in a new b2Vec2.\r\n *\r\n * @export\r\n * @param {number} x\r\n * @param {number} y\r\n * @returns {b2Vec2}\r\n */\r\nexport function pxmVec2 (x, y)\r\n{\r\n    return new b2Vec2(x / SCALE, y / SCALE);\r\n}\r\n\r\n/**\r\n * Convets the given value in radians to a b2Rot object, used for Box2D rotations.\r\n *\r\n * @export\r\n * @param {number} radians\r\n * @returns {b2Rot}\r\n */\r\nexport function RotFromRad (radians)\r\n{\r\n    return new b2Rot(Math.cos(-radians), Math.sin(-radians));\r\n}\r\n\r\n/**\r\n * Adds a Sprite Game Object to the given World, attaching it to the given Body.\r\n *\r\n * @export\r\n * @param {number} worldId\r\n * @param {Sprite} sprite\r\n * @param {b2Body} body\r\n */\r\nexport function AddSpriteToWorld (worldId, sprite, body)\r\n{\r\n    if (!WorldSprites.has(worldId))\r\n    {\r\n        WorldSprites.set(worldId, new Map());\r\n    }\r\n\r\n    WorldSprites.get(worldId).set(sprite, body);\r\n}\r\n\r\n/**\r\n * Removes a Sprite Game Object from the given World, optionally destroying the Body it was attached to.\r\n *\r\n * @export\r\n * @param {number} worldId\r\n * @param {Sprite} sprite\r\n * @param {boolean} [destroyBody=false]\r\n */\r\nexport function RemoveSpriteFromWorld (worldId, sprite, destroyBody = false)\r\n{\r\n    if (WorldSprites.has(worldId))\r\n    {\r\n        const worldMap = WorldSprites.get(worldId);\r\n        const body = worldMap.get(sprite);\r\n\r\n        if (body && destroyBody)\r\n        {\r\n            const bodyId = body.bodyId;\r\n            b2DestroyBody(bodyId);\r\n        }\r\n\r\n        worldMap.delete(sprite);\r\n    }\r\n}\r\n\r\n/**\r\n * Clears all Sprite to Body pairs.\r\n * Neither the Sprites nor the Bodies are destroyed.\r\n * The bodies remain in the world.\r\n *\r\n * @export\r\n * @param {number} worldId\r\n */\r\nexport function ClearWorldSprites (worldId)\r\n{\r\n    if (WorldSprites.has(worldId))\r\n    {\r\n        WorldSprites.get(worldId).clear();\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the Body attached to the given Sprite in the given World.\r\n * Or `null` if no such pair exists.\r\n *\r\n * @export\r\n * @param {number} worldId\r\n * @param {Sprite} sprite\r\n * @returns {Sprite|null} Either the sprite, or `null`.\r\n */\r\nexport function GetBodyFromSprite (worldId, sprite)\r\n{\r\n    if (WorldSprites.has(worldId))\r\n    {\r\n        return WorldSprites.get(worldId).get(sprite);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Runs through all World-Sprite pairs and updates the Sprite positions and rotations to match the Body.\r\n * \r\n * @param {number} worldId \r\n */\r\nexport function UpdateWorldSprites (worldId)\r\n{\r\n    if (WorldSprites.has(worldId))\r\n    {\r\n        WorldSprites.get(worldId).forEach((body, sprite) =>\r\n        {\r\n            BodyToSprite(body, sprite);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Converts a Box2D Body's position and rotation to a Sprite's position and rotation.\r\n * \r\n * This is called automatically by `UpdateWorldSprites`.\r\n * @export\r\n * @param {{ bodyId: { world0: number; }; }} body\r\n * @param {Sprite} sprite\r\n */\r\nexport function BodyToSprite (body, sprite)\r\n{\r\n    const t = b2Body_GetTransform(body.bodyId);\r\n\r\n    sprite.x = t.p.x * SCALE;\r\n    sprite.y = -(t.p.y * SCALE);\r\n    sprite.rotation = -Math.atan2(t.q.s, t.q.c);\r\n}\r\n\r\n/**\r\n * @typedef {Object} Sprite\r\n * @property {number} x - The x position of the sprite.\r\n * @property {number} y - The y position of the sprite.\r\n * @property {number} width - The width of the sprite.\r\n * @property {number} height - The height of the sprite.\r\n * @property {number} rotation - The rotation of the sprite in radians.\r\n * @property {number} [scaleX] - Optional horizontal scale of the sprite.\r\n * @property {number} [scaleY] - Optional vertical scale of the sprite.\r\n * @property {b2Vec2} [scale] - Optional scale vector of the sprite.\r\n */\r\n\r\n/**\r\n * Creates a box-shaped polygon and attaches it to a body based on the dimensions, position\r\n * and rotation of the given Sprite.\r\n * \r\n * @param {number} worldId - The World ID.\r\n * @param {Sprite} sprite - The Sprite object to read the data from.\r\n * @param {BoxPolygonConfig} data - Additional configuration for the box polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created box's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function SpriteToBox (worldId, sprite, data)\r\n{\r\n    const scaleX = sprite?.scaleX || sprite?.scale?.x || 1;\r\n    const scaleY = sprite?.scaleY || sprite?.scale?.y || 1;\r\n\r\n    const props = {\r\n        worldId,\r\n        type: DYNAMIC,\r\n        size: pxmVec2((sprite.width * scaleX) / 2, (sprite.height * scaleY) / 2)\r\n    };\r\n\r\n    const body = CreateBoxPolygon({ ...props, ...data });\r\n\r\n    b2Body_SetTransform(\r\n        body.bodyId,\r\n        pxmVec2(sprite.x, -sprite.y),\r\n        RotFromRad(sprite.rotation)\r\n    );\r\n\r\n    return body;\r\n}\r\n\r\n/**\r\n * Creates a circle-shaped polygon and attaches it to a body based on the dimensions, position\r\n * and rotation of the given Sprite.\r\n * \r\n * @param {number} worldId - The World ID.\r\n * @param {Sprite} sprite - The Sprite object to read the data from.\r\n * @param {CircleConfig} data - Additional configuration for the circle.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Circle}} The created box's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function SpriteToCircle (worldId, sprite, data)\r\n{\r\n    const scaleX = sprite?.scaleX || sprite?.scale?.x || 1;\r\n    const scaleY = sprite?.scaleY || sprite?.scale?.y || 1;\r\n\r\n    const props = {\r\n        worldId,\r\n        type: DYNAMIC,\r\n        size: pxmVec2((sprite.width * scaleX) / 2, (sprite.height * scaleY) / 2)\r\n    };\r\n\r\n    const body = CreateCircle({ ...props, ...data });\r\n\r\n    b2Body_SetTransform(\r\n        body.bodyId,\r\n        pxmVec2(sprite.x, -sprite.y),\r\n        RotFromRad(sprite.rotation)\r\n    );\r\n\r\n    return body;\r\n}\r\n\r\n/**\r\n * @typedef {Object} WorldConfig\r\n * @property {b2WorldDef} [worldDef] - World definition\r\n */\r\n\r\n/**\r\n * Creates a world and returns the ID.\r\n * @param {WorldConfig} data - Configuration for the world.\r\n * @returns {{worldId: b2WorldId}} The created world's ID.\r\n * @memberof Physics\r\n */\r\nexport function CreateWorld (data)\r\n{\r\n    let worldDef = data.worldDef;\r\n\r\n    if (!worldDef)\r\n    {\r\n        worldDef = b2DefaultWorldDef();\r\n    }\r\n\r\n    // make sure the world array has been created\r\n    b2CreateWorldArray();\r\n    const worldId = b2CreateWorld(worldDef);\r\n\r\n    return { worldId: worldId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} WorldStepConfig\r\n * @property {b2WorldId} worldId - The world ID value\r\n * @property {number} deltaTime - How long has it been since the last call (e.g. the value passed to a RAF update)\r\n * @property {number} [fixedTimeStep = 1/60] - Duration of the fixed timestep for the Physics simulation\r\n * @property {number} [subStepCount = 4] - Number of sub-steps performed per world step\r\n */\r\n\r\nlet _accumulator = 0;\r\n\r\n/**\r\n * Steps a physics world to match fixedTimeStep.\r\n * Returns the average time spent in the step function.\r\n * \r\n * @param {WorldStepConfig} data - Configuration for the world.\r\n * @returns {number} totalTime - Time spent processing the step function, in seconds.\r\n */\r\nexport function WorldStep (data)\r\n{\r\n    let fixedTimeStep = data.fixedTimeStep;\r\n\r\n    if (!fixedTimeStep)\r\n    { fixedTimeStep = 1 / 60; }\r\n    let subStepCount = data.subStepCount;\r\n\r\n    if (!subStepCount)\r\n    { subStepCount = 4; }\r\n\r\n    const borrowedTime = fixedTimeStep * 2.0;\r\n    _accumulator = Math.min(_accumulator + data.deltaTime, fixedTimeStep + borrowedTime);\r\n\r\n    // try to catch-up if we've skipped some frames\r\n    const catchUpMax = 2;\r\n    let c = catchUpMax;\r\n\r\n    // if we've been running below the fixedTimeStep, don't attempt to catch-up\r\n    if (data.deltaTime > fixedTimeStep)\r\n    {\r\n        c = 0;\r\n    }\r\n\r\n    let totalTime = 0;\r\n\r\n    // while we owe time, have some catch-up count remaining, and haven't used the entire fixedTimeStep yet...\r\n    while (_accumulator >= fixedTimeStep && c-- >= 0 && totalTime < fixedTimeStep)\r\n    {\r\n        const start = performance.now();\r\n        b2World_Step(data.worldId, fixedTimeStep, subStepCount);\r\n        const end = performance.now();\r\n        totalTime = (end - start) / 1000;\r\n        _accumulator -= fixedTimeStep;\r\n    }\r\n\r\n    return totalTime;\r\n}\r\n\r\n/**\r\n * @typedef {Object} ChainConfig\r\n * @property {b2WorldId} worldId - ID for the world.\r\n * @property {b2BodyId} groundId - ID for the static ground to attach the chain ends to.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} firstLinkPosition - Position of the first link.\r\n * @property {b2Vec2} lastLinkPosition - Position of the last link.\r\n * @property {number} chainLinks - Number of links in the chain.\r\n * @property {number} linkLength - Length of each link\r\n * @property {number} [density] - Density of the links.\r\n * @property {number} [friction] - Friction of the links.\r\n * @property {any} [color] - Custom color for the links.\r\n * @property {number} [radius] - Radius for the circle 'caps' on each capsule link.\r\n * @property {boolean} fixEnds - Should the ends of the chain be fixed to the groundId object?\r\n */\r\n\r\n/**\r\n * @typedef {Object} BodyCapsule\r\n * @property {b2BodyId} bodyId - ID for the body to attach the capsule to.\r\n * @property {b2ShapeId} shapeId - ID for the shape to attach the capsule to.\r\n * @property {b2Capsule} object - The capsule object to attach.\r\n */\r\n\r\n/**\r\n * Creates a chain of capsules with each one linked to the previous and next one.\r\n * @param {ChainConfig} data - Configuration for the chain.\r\n * @returns {BodyCapsule[]} A list of each link's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreateChain (data)\r\n{\r\n    const chainSpacing = b2Distance(data.firstLinkPosition, data.lastLinkPosition) / data.chainLinks;\r\n    const type = data.type !== undefined ? data.type : b2BodyType.b2_dynamicBody;\r\n    const density = data.density !== undefined ? data.density : 1.0;\r\n    const friction = data.friction !== undefined ? data.friction : 0.5;\r\n    const color = data.color !== undefined ? data.color : b2HexColor.b2_colorGold;\r\n    const radius = data.radius !== undefined ? data.radius : 0.5;\r\n\r\n    var lastLink = null;\r\n    var position = b2Add(data.firstLinkPosition, new b2Vec2(data.linkLength, 0));\r\n\r\n    const listLinks = [];\r\n\r\n    for (let i = 0; i < data.chainLinks; i++)\r\n    {\r\n        // const link = CreateBoxPolygon({ worldId:world.worldId, type:b2BodyType.b2_dynamicBody, position:position, size:new b2Vec2(linkLength / 2,0.5), density:1.0, friction:0.2, groupIndex:-1, color:b2HexColor.b2_colorGold });\r\n        const link = CreateCapsule({ worldId: data.worldId, type: type, position: position, center1: new b2Vec2(-data.linkLength / 2 + data.radius, 0), center2: new b2Vec2(data.linkLength / 2 - data.radius, 0), radius: radius, density: density, friction: friction, groupIndex: -1, color: color });\r\n        listLinks.push(link);\r\n\r\n        if (i == 0) // connect first link to solid\r\n        {\r\n            if (data.fixEnds)\r\n            {\r\n                CreateRevoluteJoint({\r\n                    worldId: data.worldId,\r\n                    bodyIdA: data.groundId,\r\n                    bodyIdB: link.bodyId,\r\n                    anchorA: data.firstLinkPosition,\r\n                    anchorB: new b2Vec2(-data.linkLength / 2, 0),\r\n                });\r\n            }\r\n        }\r\n        else    // connect each link to the last one\r\n        {\r\n            CreateRevoluteJoint({\r\n                worldId: data.worldId,\r\n                bodyIdA: lastLink.bodyId,\r\n                bodyIdB: link.bodyId,\r\n                anchorA: new b2Vec2(data.linkLength / 2, 0),\r\n                anchorB: new b2Vec2(-data.linkLength / 2, 0),\r\n            });\r\n        }\r\n        lastLink = link;\r\n\r\n        // Lay out all the pieces in a straight line overlapping each other if necessary\r\n        position = b2Add(position, new b2Vec2(chainSpacing, 0));\r\n    }\r\n\r\n    if (data.fixEnds)\r\n    {\r\n        // connect the last link to solid\r\n        CreateRevoluteJoint({\r\n            worldId: data.worldId,\r\n            bodyIdA: data.groundId,\r\n            bodyIdB: lastLink.bodyId,\r\n            anchorA: data.lastLinkPosition,\r\n            anchorB: new b2Vec2(data.linkLength / 2, 0),\r\n        });\r\n    }\r\n\r\n    return listLinks;\r\n}\r\n\r\n/**\r\n * @typedef {Object} CircleConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the circle.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the circle.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the circle's center.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the circle.\r\n * @property {number} [groupIndex] - Collision filtering, group index for the circle.\r\n * @property {number} [categoryBits] - Collision filtering, what 'category' is this cirle in?\r\n * @property {number} [maskBits] - Collision filtering, what 'categories' will this circle collide with?\r\n * @property {number} [density] - Density of the circle.\r\n * @property {number} [friction] - Friction of the circle.\r\n * @property {number} [restitution=0.1] - Restitution of the circle.\r\n * @property {any} [color] - Custom color for the circle.\r\n * @property {number} [radius] - Radius of the circle.\r\n * @property {boolean} [preSolve] - Enable presolve callback for the circle.\r\n * @property {boolean} [isSensor] - A sensor shape generates overlap events but never generates a collision response\r\n * @property {b2Vec2} [offset] - Offset of the circle's center when adding as a fixture.\r\n */\r\n\r\n/**\r\n * Creates a circle shape and attaches it to a body.\r\n * @param {CircleConfig} data - Configuration for the circle.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Circle}} The created circle's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreateCircle (data)\r\n{\r\n    let bodyDef = data.bodyDef;\r\n\r\n    if (!bodyDef)\r\n    {\r\n        bodyDef = b2DefaultBodyDef();\r\n    }\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n\r\n    // if bodyId is in the data, this box is a fixture for the body specified\r\n    let bodyId = data.bodyId;\r\n\r\n    if (!bodyId)\r\n    {\r\n        bodyId = b2CreateBody(data.worldId, bodyDef);\r\n    }\r\n\r\n    let shapeDef = data.shapeDef;\r\n\r\n    if (!shapeDef)\r\n    {\r\n        shapeDef = b2DefaultShapeDef();\r\n    }\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef.filter, \"categoryBits\", data.categoryBits);\r\n    setIfDef(shapeDef.filter, \"maskBits\", data.maskBits);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n    setIfDef(shapeDef, \"enablePreSolveEvents\", data.preSolve);\r\n    setIfDef(shapeDef, \"isSensor\", data.isSensor);\r\n    setIfDef(shapeDef, \"restitution\", data.restitution);\r\n\r\n    const ball = new b2Circle();\r\n    setIfDef(ball, \"radius\", data.radius);\r\n\r\n    if (data.bodyId)\r\n    {\r\n        setIfDef(ball, \"center\", data.offset);\r\n    }\r\n\r\n    const shapeId = b2CreateCircleShape(bodyId, shapeDef, ball);\r\n\r\n    return { bodyId: bodyId, shapeId: shapeId, object: ball };\r\n}\r\n\r\n/**\r\n * @typedef {Object} CapsuleConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the capsule.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the capsule.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the capsule's center.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the capsule.\r\n * @property {number} [density] - Density of the capsule.\r\n * @property {number} [friction] - Friction of the capsule.\r\n * @property {number} [groupIndex] - Collision group index for the capsule.\r\n * @property {number} [categoryBits] - Collision filtering, what 'category' is this in?\r\n * @property {number} [maskBits] - Collision filtering, what 'categories' will this collide with?\r\n * @property {any} [color] - Custom color for the capsule.\r\n * @property {b2Vec2} [center1] - Center of the first circle of the capsule. Optional if 'height' is set.\r\n * @property {b2Vec2} [center2] - Center of the second circle of the capsule. Optional if 'height' is set.\r\n * @property {number} [radius] - Radius of the capsule's circles. Optional if 'width' is set.\r\n * @property {boolean} [fixedRotation] - Prevent rotation if set to true.\r\n * @property {number} [linearDamping] - Linear damping of velocity.\r\n * @property {number} [width] - The overall width of the capsule. If set replaces radius.\r\n * @property {number} [height] - The overall height of the capsule, including the start and end caps. If set replaces center1 and center2.\r\n */\r\n\r\n/**\r\n * Creates a capsule shape and attaches it to a body.\r\n * @param {CapsuleConfig} data - Configuration for the capsule.\r\n * @returns {BodyCapsule} The created capsule's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreateCapsule (data)\r\n{\r\n    let bodyDef = data.bodyDef;\r\n\r\n    if (!bodyDef)\r\n    {\r\n        bodyDef = b2DefaultBodyDef();\r\n    }\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n    setIfDef(bodyDef, \"fixedRotation\", data.fixedRotation);\r\n    setIfDef(bodyDef, \"linearDamping\", data.linearDamping);\r\n\r\n    // if bodyId is in the data, this box is a fixture for the body specified\r\n    let bodyId = data.bodyId;\r\n\r\n    if (!bodyId)\r\n    {\r\n        bodyId = b2CreateBody(data.worldId, bodyDef);\r\n    }\r\n\r\n    let shapeDef = data.shapeDef;\r\n\r\n    if (!shapeDef)\r\n    {\r\n        shapeDef = b2DefaultShapeDef();\r\n    }\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef.filter, \"categoryBits\", data.categoryBits);\r\n    setIfDef(shapeDef.filter, \"maskBits\", data.maskBits);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n\r\n    const capsule = new b2Capsule();\r\n\r\n    if (data.width)\r\n    {\r\n        data.radius = data.width / 2;\r\n    }\r\n\r\n    if (data.height)\r\n    {\r\n        data.radius = Math.min(data.radius, data.height / 2);\r\n        data.center1 = new b2Vec2(0, -(data.height / 2));\r\n        data.center2 = new b2Vec2(0, data.height / 2);\r\n    }\r\n\r\n    setIfDef(capsule, \"center1\", data.center1);\r\n    setIfDef(capsule, \"center2\", data.center2);\r\n    setIfDef(capsule, \"radius\", data.radius);\r\n    const shapeId = b2CreateCapsuleShape(bodyId, shapeDef, capsule);\r\n\r\n    return { bodyId: bodyId, shapeId: shapeId, object: capsule };\r\n}\r\n\r\n/**\r\n * @typedef {Object} BoxPolygonConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the box.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the box.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the box's center.\r\n * @property {boolean} [fixedRotation] - Prevent box from rotating?\r\n * @property {number} [linearDamping] - Damping for linear velocity.\r\n * @property {number} [angularDamping] - Damping for angular velocity.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the box.\r\n * @property {any} [userData] - The user data to associate with the body.\r\n * @property {number} [groupIndex] - Collision group index for the box.\r\n * @property {number} [categoryBits] - Collision filtering, what 'category' is this in?\r\n * @property {number} [maskBits] - Collision filtering, what 'categories' will this collide with?\r\n * @property {number} [density=1.0] - Density of the box.\r\n * @property {number} [friction=0.6] - Friction of the box.\r\n * @property {number} [restitution=0.1] - Restitution of the box.\r\n * @property {any} [color] - Custom color for the box.\r\n * @property {boolean} [preSolve] - Enable presolve callback for the circle.\r\n * @property {b2Vec2|number} size - Size of the box (either a b2Vec2 or a single number for square).\r\n */\r\n\r\n/**\r\n * Creates a box-shaped polygon and attaches it to a body.\r\n * @param {BoxPolygonConfig} data - Configuration for the box polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created box's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreateBoxPolygon (data)\r\n{\r\n    let bodyDef = data.bodyDef;\r\n\r\n    if (!bodyDef)\r\n    {\r\n        bodyDef = b2DefaultBodyDef();\r\n    }\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n    setIfDef(bodyDef, \"fixedRotation\", data.fixedRotation);\r\n    setIfDef(bodyDef, \"linearDamping\", data.linearDamping);\r\n    setIfDef(bodyDef, \"angularDamping\", data.angularDamping);\r\n\r\n    // if bodyId is in the data, this box is a fixture for the body specified\r\n    let bodyId = data.bodyId;\r\n\r\n    if (!bodyId)\r\n    {\r\n        bodyId = b2CreateBody(data.worldId, bodyDef);\r\n    }\r\n\r\n    let shapeDef = data.shapeDef;\r\n\r\n    if (!shapeDef)\r\n    {\r\n        shapeDef = b2DefaultShapeDef();\r\n    }\r\n\r\n    const userData = data.userData;\r\n\r\n    if (userData)\r\n    {\r\n        b2Body_SetUserData(bodyId, data.userData);\r\n    }\r\n\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef, \"restitution\", data.restitution);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef.filter, \"categoryBits\", data.categoryBits);\r\n    setIfDef(shapeDef.filter, \"maskBits\", data.maskBits);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n    setIfDef(shapeDef, \"enablePreSolveEvents\", data.preSolve);\r\n\r\n    // data.size can be a b2Vec2 or a number\r\n    let box;\r\n\r\n    if (data.size instanceof b2Vec2)\r\n    {\r\n        if (data.bodyId)\r\n        {\r\n            box = b2MakeOffsetBox(data.size.x, data.size.y, data.position, b2MakeRot(0));\r\n        }\r\n        else\r\n        {\r\n            box = b2MakeBox(data.size.x, data.size.y);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        box = b2MakeBox(data.size, data.size);\r\n    }\r\n\r\n    const shapeId = b2CreatePolygonShape(bodyId, shapeDef, box);\r\n\r\n    return { bodyId: bodyId, shapeId: shapeId, object: box };\r\n}\r\n\r\n/**\r\n * @typedef {Object} NGonPolygonConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the n-gon.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the n-gon.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the n-gon's center.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the n-gon.\r\n * @property {number} [groupIndex] - Collision group index for the n-gon.\r\n * @property {number} [density] - Density of the n-gon.\r\n * @property {number} [friction] - Friction of the n-gon.\r\n * @property {any} [color] - Custom color for the n-gon.\r\n * @property {number} radius - Radius of the n-gon.\r\n * @property {number} sides - Number of sides for the n-gon.\r\n */\r\n\r\n/**\r\n * Creates a regular n-gon polygon and attaches it to a body.\r\n * @param {NGonPolygonConfig} data - Configuration for the n-gon polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created n-gon's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreateNGonPolygon (data)\r\n{\r\n    if (data.sides < 3 || data.sides > B2_MAX_POLYGON_VERTICES)\r\n    {\r\n        console.warn(`WARNING: invalid number of sides for a polygon (${data.sides}).`);\r\n\r\n        return null;\r\n    }\r\n\r\n    const bodyDef = data.bodyDef || b2DefaultBodyDef();\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n\r\n    let bodyId = data.bodyId;\r\n\r\n    if (!bodyId)\r\n    {\r\n        bodyId = b2CreateBody(data.worldId, bodyDef);\r\n    }\r\n\r\n    const shapeDef = data.shapeDef || b2DefaultShapeDef();\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n\r\n    const vertices = [];\r\n    const angleStep = (2 * Math.PI) / data.sides;\r\n\r\n    for (let i = 0; i < data.sides; i++)\r\n    {\r\n        const angle = i * angleStep;\r\n        const x = data.radius * Math.cos(angle);\r\n        const y = data.radius * Math.sin(angle);\r\n        vertices.push(new b2Vec2(x, y));\r\n    }\r\n\r\n    let nGon;\r\n    const hull = b2ComputeHull(vertices, data.sides);\r\n\r\n    if (data.bodyId != null)\r\n    {\r\n        const oldxf = b2GetBodyTransform(data.worldId, data.bodyId);\r\n        const xf = new b2Transform(data.position, oldxf.q);\r\n        nGon = b2MakeOffsetPolygon(hull, 0, xf);\r\n    }\r\n    else\r\n    {\r\n        nGon = b2MakePolygon(hull, 0);\r\n    }\r\n\r\n    const shapeId = b2CreatePolygonShape(bodyId, shapeDef, nGon);\r\n\r\n    return { bodyId: bodyId, shapeId: shapeId, object: nGon };\r\n}\r\n\r\n\r\n/**\r\n * @typedef {Object} PolygonConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the polygon.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the polygon.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the polygon's center.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the polygon.\r\n * @property {number} [groupIndex] - Collision group index for the polygon.\r\n * @property {number} [density] - Density of the polygon.\r\n * @property {number} [friction] - Friction of the polygon.\r\n * @property {any} [color] - Custom color for the polygon.\r\n * @property {b2Vec2[]} vertices - List of vertices for the polygon.\r\n */\r\n\r\n/**\r\n * Creates a polygon and attaches it to a body.\r\n * @param {PolygonConfig} data - Configuration for the polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created polygon's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreatePolygon (data)\r\n{\r\n    if (data.vertices.length < 3 || data.vertices.length > B2_MAX_POLYGON_VERTICES)\r\n    {\r\n        console.warn(`WARNING: invalid number of sides for a polygon (${data.vertices.length}).`);\r\n\r\n        return null;\r\n    }\r\n\r\n    const bodyDef = data.bodyDef || b2DefaultBodyDef();\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n\r\n    let bodyId = data.bodyId;\r\n\r\n    if (!bodyId)\r\n    {\r\n        bodyId = b2CreateBody(data.worldId, bodyDef);\r\n    }\r\n\r\n    const shapeDef = data.shapeDef || b2DefaultShapeDef();\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n\r\n    let nGon;\r\n    const hull = b2ComputeHull(data.vertices, data.vertices.length);\r\n\r\n    if (data.bodyId != null)\r\n    {\r\n        const oldxf = b2GetBodyTransform(data.worldId, data.bodyId);\r\n        const xf = new b2Transform(data.position, oldxf.q);\r\n        nGon = b2MakeOffsetPolygon(hull, 0, xf);\r\n    }\r\n    else\r\n    {\r\n        nGon = b2MakePolygon(hull, 0);\r\n    }\r\n\r\n    const shapeId = b2CreatePolygonShape(bodyId, shapeDef, nGon);\r\n\r\n    return { bodyId: bodyId, shapeId: shapeId, object: nGon };\r\n}\r\n\r\n\r\n/**\r\n * @typedef {Object} PolygonVertexConfig\r\n * @property {b2WorldId} worldId - ID for the world in which to create the polygon.\r\n * @property {b2BodyDef} [bodyDef] - Body definition for the polygon.\r\n * @property {number} [type] - Type of the body (static, dynamic, kinematic).\r\n * @property {b2Vec2} [position] - Position of the polygon's center.\r\n * @property {b2BodyId} [bodyId] - Existing body ID if adding as a fixture.\r\n * @property {b2ShapeDef} [shapeDef] - Shape definition for the polygon.\r\n * @property {number} [groupIndex] - Collision group index for the polygon.\r\n * @property {number} [density] - Density of the polygon.\r\n * @property {number} [friction] - Friction of the polygon.\r\n * @property {number} [restitution=0.1] - Restitution of the polygon.\r\n * @property {any} [color] - Custom color for the polygon.\r\n * @property {number[][]} indices - List of indices to the vertices for the polygon.\r\n * @property {number[]} vertices - List of vertices for the polygon in number pairs [x0,y0, x1,y1, ... xN,yN].\r\n * @property {b2Vec2} vertexOffset - Offset to recenter the vertices if they are not zero based.\r\n * @property {b2Vec2} vertexScale - Scale for the vertices, defaults to 1, 1.\r\n * @property {string} [url] - URL location of the XML data file, if we're using one.\r\n * @property {string} [key] - Name 'key' to find the correct data in the XML.\r\n */\r\n\r\n/**\r\n * Creates a polygon from Earcut CDT data and attaches it to a body.\r\n * @param {PolygonVertexConfig} data - Configuration for the polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created polygon's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreatePolygonFromEarcut (data)\r\n{\r\n    if (data.vertices.length < 3)\r\n    {\r\n        console.warn(`WARNING: invalid number of sides for a polygon (${data.vertices.length}).`);\r\n\r\n        return null;\r\n    }\r\n\r\n    const bodyDef = data.bodyDef || b2DefaultBodyDef();\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n\r\n    const shapeDef = data.shapeDef || b2DefaultShapeDef();\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef, \"restitution\", data.restitution);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n\r\n    const parts = [];\r\n\r\n    let scale = data.vertexScale;\r\n\r\n    if (!scale) { scale = new b2Vec2(1, 1); }\r\n    let offset = data.vertexOffset;\r\n\r\n    if (!offset) { offset = new b2Vec2(0, 0); }\r\n\r\n    // convert earcut triangle data into point lists suitable for box2D\r\n    for (let i = 0, l = data.indices[ 0 ].length; i < l; i += 3)\r\n    {\r\n        const part = [];\r\n\r\n        for (let j = 0; j < 3; j++)\r\n        {\r\n            const index = data.indices[ 0 ][ i + j ] * 2;\r\n            part.push(new b2Vec2((data.vertices[ index ] + offset.x) * scale.x, (data.vertices[ index + 1 ] + offset.y) * scale.y));\r\n        }\r\n        parts.push(part);\r\n    }\r\n\r\n    // create a Shape for each point list\r\n    let body = null;\r\n    parts.forEach(part =>\r\n    {\r\n        if (!body)\r\n        {\r\n            // create a Body for the entire object using the first point list\r\n            body = CreatePolygon({\r\n                worldId: data.worldId,\r\n                type: b2BodyType.b2_dynamicBody,\r\n                bodyDef: bodyDef,\r\n\r\n                // position: position,\r\n                vertices: part,\r\n                density: 1.0,\r\n                friction: 0.3,\r\n                color: b2HexColor.b2_colorSkyBlue\r\n            });\r\n        }\r\n        else\r\n        {\r\n            // create a Shape attached to that body for all remaining point lists\r\n            const hull = b2ComputeHull(part, part.length);\r\n            const nGon = b2MakePolygon(hull, 0);\r\n            b2CreatePolygonShape(body.bodyId, shapeDef, nGon);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a polygon from Vertex and Index data and attaches it to a body.\r\n * @param {PolygonVertexConfig} data - Configuration for the polygon.\r\n * @returns {{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}} The created polygon's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreatePolygonFromVertices (data)\r\n{\r\n    if (data.vertices.length < 3)\r\n    {\r\n        console.warn(`WARNING: invalid number of sides for a polygon (${data.vertices.length}).`);\r\n\r\n        return null;\r\n    }\r\n\r\n    const bodyDef = data.bodyDef || b2DefaultBodyDef();\r\n    setIfDef(bodyDef, \"type\", data.type);\r\n    setIfDef(bodyDef, \"position\", data.position);\r\n\r\n    const shapeDef = data.shapeDef || b2DefaultShapeDef();\r\n    setIfDef(shapeDef, \"density\", data.density);\r\n    setIfDef(shapeDef, \"friction\", data.friction);\r\n    setIfDef(shapeDef, \"restitution\", data.restitution);\r\n    setIfDef(shapeDef.filter, \"groupIndex\", data.groupIndex);\r\n    setIfDef(shapeDef, \"customColor\", data.color);\r\n\r\n    let scale = data.vertexScale;\r\n\r\n    if (!scale) { scale = new b2Vec2(1, 1); }\r\n    let offset = data.vertexOffset;\r\n\r\n    if (!offset) { offset = new b2Vec2(0, 0); }\r\n\r\n    // convert indexed vertex data into point lists suitable for box2D\r\n    const parts = [];\r\n\r\n    for (let i = 0, l = data.indices.length; i < l; i++)\r\n    {\r\n        const part = [];\r\n        const indices = data.indices[ i ];\r\n\r\n        for (let p = 0, pl = indices.length; p < pl; p++)\r\n        {\r\n            const index = indices[ p ] * 2;\r\n            part.push(new b2Vec2((data.vertices[ index ] + offset.x) * scale.x, (data.vertices[ index + 1 ] + offset.y) * scale.y));\r\n        }\r\n        parts.push(part);\r\n    }\r\n\r\n    // create a Shape for each point list\r\n    let body = null;\r\n    parts.forEach(part =>\r\n    {\r\n        if (!body)\r\n        {\r\n            // create a Body for the entire object using the first point list\r\n            body = CreatePolygon({\r\n                worldId: data.worldId,\r\n                type: b2BodyType.b2_dynamicBody,\r\n                bodyDef: bodyDef,\r\n\r\n                // position: position,\r\n                vertices: part,\r\n                density: 1.0,\r\n                friction: 0.3,\r\n                color: b2HexColor.b2_colorSkyBlue\r\n            });\r\n        }\r\n        else\r\n        {\r\n            // create a Shape attached to that body for all remaining point lists\r\n            const hull = b2ComputeHull(part, part.length);\r\n            const nGon = b2MakePolygon(hull, 0);\r\n            b2CreatePolygonShape(body.bodyId, shapeDef, nGon);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a polygon from PhysicsEditor XML data and attaches it to a body.\r\n * It is recommended to prepare data with this _before_ the game loop starts; It is async and quite slow.\r\n * @param {PolygonVertexConfig} data - Configuration for the polygon.\r\n * @returns {Promise<{bodyId: b2BodyId, shapeId: b2ShapeId, object: b2Polygon}>} The created polygon's body ID, shape ID, and object.\r\n * @memberof Physics\r\n */\r\nexport function CreatePhysicsEditorShape (data)\r\n{\r\n    const key = data.key;\r\n    const url = data.url;\r\n\r\n    async function loadXMLFromFile (url)\r\n    {\r\n        try\r\n        {\r\n            const response = await fetch(url);\r\n            const xmlText = await response.text();\r\n            const parser = new DOMParser();\r\n            const xmlDoc = parser.parseFromString(xmlText, \"text/xml\");\r\n\r\n            return xmlDoc;\r\n        }\r\n        catch (error)\r\n        {\r\n            console.error(\"Error loading XML:\", error);\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    function extractPolygons (key, xmlDoc)\r\n    {\r\n        const polygonElements = xmlDoc.querySelectorAll(`body[name=${key}] fixtures polygon`);\r\n\r\n        const uniqueVertices = [];\r\n        const polygonIndices = [];\r\n\r\n        // find or add vertex\r\n        function getVertexIndex (x, y)\r\n        {\r\n            // exists? (with tiny epsilon)\r\n            const epsilon = 0.000001;\r\n            const last = uniqueVertices.length;\r\n\r\n            for (let i = 0; i < last; i += 2)\r\n            {\r\n                if (Math.abs(uniqueVertices[ i ] - x) < epsilon &&\r\n                    Math.abs(uniqueVertices[ i + 1 ] - y) < epsilon)\r\n                {\r\n                    return i / 2;\r\n                }\r\n            }\r\n\r\n            // add new vertex if not\r\n            uniqueVertices.push(x, y);\r\n\r\n            return last / 2;\r\n        }\r\n\r\n        // for each polygon from the XML\r\n        Array.from(polygonElements).forEach(polygon =>\r\n        {\r\n            const numbers = polygon.textContent\r\n                .trim()\r\n                .split(/[,\\s]+/)    // commas or whitespace\r\n                .map(Number);\r\n\r\n            // create indices\r\n            const polygonIndexList = [];\r\n\r\n            for (let i = 0; i < numbers.length; i += 2)\r\n            {\r\n                const vertexIndex = getVertexIndex(numbers[ i ], numbers[ i + 1 ]);\r\n                polygonIndexList.push(vertexIndex);\r\n            }\r\n            polygonIndices.push(polygonIndexList);\r\n        });\r\n\r\n        return {\r\n            vertices: uniqueVertices,  // a flat array of x,y coordinates\r\n            indices: polygonIndices    // an array of index arrays, one per polygon\r\n        };\r\n    }\r\n\r\n    function createPolygons (polygons)\r\n    {\r\n        // create a polygon body from the vertex list and index list-of-lists\r\n        // merge the provided data object defining the body with the data we've extracted from XML\r\n        return CreatePolygonFromVertices({\r\n            ...data,\r\n            indices: polygons.indices,\r\n            vertices: polygons.vertices\r\n        });\r\n    }\r\n\r\n    return new Promise(async (resolve, reject) =>\r\n    {\r\n        try\r\n        {\r\n            const xmlDoc = await loadXMLFromFile(url);\r\n            const polygons = extractPolygons(key, xmlDoc);\r\n            const result = createPolygons(polygons);\r\n            resolve(result);\r\n        }\r\n        catch (error)\r\n        {\r\n            console.error(\"Error:\", error);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @typedef {Object} RevoluteJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2RevoluteJointDef} [jointDef] - A pre-existing b2RevoluteJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to connect with this joint.\r\n * @property {b2Vec2} [anchorA] - Local position of the anchor point on the first body.\r\n * @property {b2Vec2} [anchorB] - Local position of the anchor point on the second body.\r\n * @property {number} [lowerAngle] - Lower limit of the joint's angle.\r\n * @property {number} [upperAngle] - Upper limit of the joint's angle.\r\n * @property {boolean} [enableLimit] - Whether to enable angle limits.\r\n * @property {boolean} [enableMotor] - Whether to enable the joint's motor.\r\n * @property {number} [motorSpeed] - The desired motor speed.\r\n * @property {number} [maxMotorTorque] - The maximum torque the motor can apply.\r\n * @property {boolean} [enableSpring] - Whether to enable the joint's spring.\r\n * @property {number} [hertz] - The frequency of the joint's spring.\r\n * @property {number} [dampingRatio] - The damping ratio of the joint's spring.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n * @property {number} [drawSize] - The size to use when drawing the joint.\r\n */\r\n\r\n/**\r\n * Creates a revolute joint between two bodies.\r\n * @param {RevoluteJointConfig} data - Configuration for the revolute joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created revolute joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateRevoluteJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2RevoluteJointDef();\r\n    }\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n    setIfDef(jointDef, \"localAnchorA\", data.anchorA);\r\n    setIfDef(jointDef, \"localAnchorB\", data.anchorB);\r\n\r\n    setIfDef(jointDef, \"lowerAngle\", data.lowerAngle);\r\n    setIfDef(jointDef, \"upperAngle\", data.upperAngle);\r\n    setIfDef(jointDef, \"enableLimit\", data.enableLimit);\r\n\r\n    setIfDef(jointDef, \"enableMotor\", data.enableMotor);\r\n    setIfDef(jointDef, \"motorSpeed\", data.motorSpeed);\r\n    setIfDef(jointDef, \"maxMotorTorque\", data.maxMotorTorque);\r\n\r\n    setIfDef(jointDef, \"enableSpring\", data.enableSpring);\r\n    setIfDef(jointDef, \"hertz\", data.hertz);\r\n    setIfDef(jointDef, \"dampingRatio\", data.dampingRatio);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n    setIfDef(jointDef, \"drawSize\", data.drawSize);\r\n\r\n    const jointId = b2CreateRevoluteJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} WeldJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2WeldJointDef} [jointDef] - A pre-existing b2WeldJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to weld with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to weld with this joint.\r\n * @property {b2Vec2} [anchorA] - Local position of the anchor point on the first body.\r\n * @property {b2Vec2} [anchorB] - Local position of the anchor point on the second body.\r\n * @property {number} [hertz] - The frequency at which the weld joint is enforced.\r\n * @property {number} [dampingRatio] - The angular damping ratio when the weld joint is springing back into alignment.\r\n * @property {number} [referenceAngle] - Reference angle for the weld joint at rest.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n */\r\n\r\n/**\r\n * Creates a weld joint between two bodies.\r\n * @param {WeldJointConfig} data - Configuration for the weld joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created weld joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateWeldJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2WeldJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n    setIfDef(jointDef, \"localAnchorA\", data.anchorA);\r\n    setIfDef(jointDef, \"localAnchorB\", data.anchorB);\r\n\r\n    const rotA = b2Body_GetRotation(data.bodyIdA);\r\n    const rotB = b2Body_GetRotation(data.bodyIdB);\r\n    jointDef.referenceAngle = b2RelativeAngle(rotB, rotA);\r\n    setIfDef(jointDef, \"referenceAngle\", data.referenceAngle);\r\n\r\n    setIfDef(jointDef, \"angularHertz\", data.hertz);\r\n    setIfDef(jointDef, \"angularDampingRatio\", data.dampingRatio);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreateWeldJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} DistanceJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2DistanceJointDef} [jointDef] - A pre-existing b2DistanceJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to connect with this joint.\r\n * @property {b2Vec2} [anchorA] - Local position of the anchor point on the first body.\r\n * @property {b2Vec2} [anchorB] - Local position of the anchor point on the second body.\r\n * @property {number} [length] - The natural length of the joint.\r\n * @property {number} [minLength] - The minimum allowed length of the joint.\r\n * @property {number} [maxLength] - The maximum allowed length of the joint.\r\n * @property {boolean} [enableSpring] - Whether to enable the joint's spring.\r\n * @property {number} [hertz] - The frequency of the joint's spring.\r\n * @property {number} [dampingRatio] - The damping ratio of the joint's spring.\r\n * @property {boolean} [enableLimit] - Whether to enable length limits.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n */\r\n\r\n/**\r\n * Creates a distance joint between two bodies.\r\n * @param {DistanceJointConfig} data - Configuration for the distance joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created distance joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateDistanceJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2DistanceJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n    setIfDef(jointDef, \"localAnchorA\", data.anchorA);\r\n    setIfDef(jointDef, \"localAnchorB\", data.anchorB);\r\n\r\n    setIfDef(jointDef, \"length\", data.length);\r\n    setIfDef(jointDef, \"minLength\", data.minLength);\r\n    setIfDef(jointDef, \"maxLength\", data.maxLength);\r\n\r\n    setIfDef(jointDef, \"enableSpring\", data.enableSpring);\r\n    setIfDef(jointDef, \"hertz\", data.hertz);\r\n    setIfDef(jointDef, \"dampingRatio\", data.dampingRatio);\r\n    setIfDef(jointDef, \"enableLimit\", data.enableLimit);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreateDistanceJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} WheelJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2WheelJointDef} [jointDef] - A pre-existing b2WheelJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to connect with this joint.\r\n * @property {b2Vec2} [anchorA] - Local position of the anchor point on the first body.\r\n * @property {b2Vec2} [anchorB] - Local position of the anchor point on the second body.\r\n * @property {boolean} [enableSpring] - Whether to enable the joint's spring.\r\n * @property {b2Vec2} [axis] - The local axis for the joint movement on body A.\r\n * @property {number} [hertz] - The frequency of the joint's spring.\r\n * @property {number} [dampingRatio] - The damping ratio of the joint's spring.\r\n * @property {boolean} [enableLimit] - Whether to enable translation limits.\r\n * @property {number} [lowerTranslation] - The lower translation limit.\r\n * @property {number} [upperTranslation] - The upper translation limit.\r\n * @property {boolean} [enableMotor] - Whether to enable the joint's motor.\r\n * @property {number} [maxMotorTorque] - The maximum torque the motor can apply.\r\n * @property {number} [motorSpeed] - The desired motor speed.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n */\r\n\r\n/**\r\n * Creates a wheel joint between two bodies.\r\n * @param {WheelJointConfig} data - Configuration for the wheel joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created wheel joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateWheelJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2WheelJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n    setIfDef(jointDef, \"localAnchorA\", data.anchorA);\r\n    setIfDef(jointDef, \"localAnchorB\", data.anchorB);\r\n\r\n    setIfDef(jointDef, \"enableSpring\", data.enableSpring);\r\n    setIfDef(jointDef, \"localAxisA\", data.axis);\r\n    setIfDef(jointDef, \"hertz\", data.hertz);\r\n    setIfDef(jointDef, \"dampingRatio\", data.dampingRatio);\r\n\r\n    setIfDef(jointDef, \"enableLimit\", data.enableLimit);\r\n    setIfDef(jointDef, \"lowerTranslation\", data.lowerTranslation);\r\n    setIfDef(jointDef, \"upperTranslation\", data.upperTranslation);\r\n\r\n    setIfDef(jointDef, \"enableMotor\", data.enableMotor);\r\n    setIfDef(jointDef, \"maxMotorTorque\", data.maxMotorTorque);\r\n    setIfDef(jointDef, \"motorSpeed\", data.motorSpeed);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreateWheelJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} PrismaticJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2PrismaticJointDef} [jointDef] - A pre-existing b2PrismaticJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to connect with this joint.\r\n * @property {b2Vec2} [anchorA] - Local position of the anchor point on the first body.\r\n * @property {b2Vec2} [anchorB] - Local position of the anchor point on the second body.\r\n * @property {b2Vec2} [axis] - The local axis for the joint movement on body A.\r\n * @property {number} [referenceAngle] - The reference angle between the bodies.\r\n * @property {boolean} [enableSpring] - Whether to enable the joint's spring.\r\n * @property {number} [hertz] - The frequency of the joint's spring.\r\n * @property {number} [dampingRatio] - The damping ratio of the joint's spring.\r\n * @property {boolean} [enableLimit] - Whether to enable translation limits.\r\n * @property {number} [lowerTranslation] - The lower translation limit.\r\n * @property {number} [upperTranslation] - The upper translation limit.\r\n * @property {boolean} [enableMotor] - Whether to enable the joint's motor.\r\n * @property {number} [maxMotorForce] - The maximum force the motor can apply.\r\n * @property {number} [motorSpeed] - The desired motor speed.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n */\r\n\r\n/**\r\n * Creates a prismatic joint between two bodies.\r\n * @param {PrismaticJointConfig} data - Configuration for the prismatic joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created prismatic joint.\r\n * @memberof Physics\r\n */\r\nexport function CreatePrismaticJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2PrismaticJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n    setIfDef(jointDef, \"localAnchorA\", data.anchorA);\r\n    setIfDef(jointDef, \"localAnchorB\", data.anchorB);\r\n    setIfDef(jointDef, \"localAxisA\", data.axis);\r\n\r\n    setIfDef(jointDef, \"referenceAngle\", data.referenceAngle);\r\n\r\n    setIfDef(jointDef, \"enableSpring\", data.enableSpring);\r\n    setIfDef(jointDef, \"hertz\", data.hertz);\r\n    setIfDef(jointDef, \"dampingRatio\", data.dampingRatio);\r\n\r\n    setIfDef(jointDef, \"enableLimit\", data.enableLimit);\r\n    setIfDef(jointDef, \"lowerTranslation\", data.lowerTranslation);\r\n    setIfDef(jointDef, \"upperTranslation\", data.upperTranslation);\r\n\r\n    setIfDef(jointDef, \"enableMotor\", data.enableMotor);\r\n    setIfDef(jointDef, \"maxMotorForce\", data.maxMotorForce);\r\n    setIfDef(jointDef, \"motorSpeed\", data.motorSpeed);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreatePrismaticJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n\r\n/**\r\n * @typedef {Object} MotorJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2MotorJointDef} [jointDef] - A pre-existing b2MotorJointDef.\r\n * @property {b2BodyId} bodyIdA - The first body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second body to connect with this joint.\r\n * @property {b2Vec2} [linearOffset] - The desired linear offset in frame A.\r\n * @property {number} [maxForce] - The maximum force that can be applied to reach the target offsets.\r\n * @property {number} [angularOffset] - The desired angular offset.\r\n * @property {number} [maxTorque] - The maximum torque that can be applied to reach the target angular offset.\r\n * @property {number} [correctionFactor] - Position correction factor in the range [0,1].\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n */\r\n\r\n// NOTES about Motor Joints\r\n// when 'correctionFactor' == 0.0 the body will not move\r\n// if linking to the ground, 'bodyA' should be the ground body or the motion will be wrong\r\n// 'linearOffset' is the world destination, not an offset from the starting position\r\n\r\n/**\r\n * Creates a motor joint between two bodies.\r\n * @param {MotorJointConfig} data - Configuration for the motor joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created motor joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateMotorJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2MotorJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n\r\n    setIfDef(jointDef, \"linearOffset\", data.linearOffset);\r\n    setIfDef(jointDef, \"maxForce\", data.maxForce);\r\n    setIfDef(jointDef, \"angularOffset\", data.angularOffset);\r\n    setIfDef(jointDef, \"maxTorque\", data.maxTorque);\r\n    setIfDef(jointDef, \"correctionFactor\", data.correctionFactor);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreateMotorJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n\r\n/**\r\n * @typedef {Object} MouseJointConfig\r\n * @property {b2WorldId} worldId - ID for the world in which the bodies and joint exist.\r\n * @property {b2MouseJointDef} [jointDef] - A pre-existing b2MouseJointDef.\r\n * @property {b2BodyId} bodyIdA - The first (usually static) body to connect with this joint.\r\n * @property {b2BodyId} bodyIdB - The second (usually dynamic) body to connect with this joint.\r\n * @property {b2Vec2} [target] - The initial world target point.\r\n * @property {number} [hertz] - The response frequency.\r\n * @property {number} [dampingRatio] - The damping ratio.\r\n * @property {number} [maxForce] - The maximum force that can be exerted to reach the target point.\r\n * @property {boolean} [collideConnected] - Whether the connected bodies should collide.\r\n * e.g. worldId:worldId, bodyIdA:mouseCircle.bodyId, bodyIdB:mouseBox.bodyId, target:new b2Vec2(0, 0), hertz:30.0, dampingRatio:0.999, maxForce:35000\r\n */\r\n\r\n/**\r\n * Creates a mouse joint between two bodies.\r\n * @param {MouseJointConfig} data - Configuration for the mouse joint.\r\n * @returns {{jointId: b2JointId}} The ID of the created mouse joint.\r\n * @memberof Physics\r\n */\r\nexport function CreateMouseJoint (data)\r\n{\r\n    console.assert(data.worldId != undefined);\r\n    console.assert(data.bodyIdA != undefined && data.bodyIdB != undefined);\r\n\r\n    let jointDef = data.jointDef;\r\n\r\n    if (!jointDef)\r\n    {\r\n        jointDef = new b2MouseJointDef();\r\n    }\r\n\r\n    jointDef.bodyIdA = data.bodyIdA;\r\n    jointDef.bodyIdB = data.bodyIdB;\r\n\r\n    setIfDef(jointDef, \"target\", data.target);      // transferred to b2MouseJoint.targetA\r\n    setIfDef(jointDef, \"hertz\", data.hertz);\r\n    setIfDef(jointDef, \"dampingRatio\", data.dampingRatio);\r\n    setIfDef(jointDef, \"maxForce\", data.maxForce);\r\n\r\n    setIfDef(jointDef, \"collideConnected\", data.collideConnected);\r\n\r\n    const jointId = b2CreateMouseJoint(data.worldId, jointDef);\r\n\r\n    return { jointId: jointId };\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2AABB, b2Add, b2Sub, b2TransformPointOut, b2Vec2 } from './include/math_functions_h.js';\r\nimport { b2BodyId, b2WorldId } from './main.js';\r\n\r\nimport { b2Body_GetShapes } from './body_c.js';\r\nimport { b2ComputeShapeAABB } from './shape_c.js';\r\nimport { b2DebugDraw } from './include/types_h.js';\r\nimport { b2GetWorldFromId } from './world_c.js';\r\n\r\n/**\r\n * @namespace DebugDraw\r\n */\r\n\r\nconst p0 = new b2Vec2();\r\nconst disableDrawing = false;\r\n\r\n/**\r\n * @function CreateDebugDraw\r\n * @description Creates a debug drawing interface for Box2D that renders shapes to a canvas context.  \r\n * The canvas is automatically sized to 1280x720 or 720x1280 based on window orientation.  \r\n * All coordinates are transformed from Box2D world space to screen space.  \r\n * This feature isn't meant for production. It is purely for debugging and testing. The code\r\n * is not optimized, stable or extensible. Implement your own drawing code for production.\r\n * @param {HTMLCanvasElement} canvas - The canvas element to draw on\r\n * @param {CanvasRenderingContext2D} ctx - The 2D rendering context for the canvas\r\n * @param {number} [scale=20] - The scale factor to convert Box2D coordinates to pixels\r\n * @returns {b2DebugDraw} A debug draw instance with methods for rendering Box2D shapes\r\n * The debug draw instance includes methods for drawing:\r\n * - Polygons (outlined and filled)\r\n * - Circles (outlined and filled)\r\n * - Capsules (outlined and filled)\r\n * - Images mapped to shapes\r\n * - Line segments\r\n * - Points\r\n * - Transforms\r\n */\r\nexport function CreateDebugDraw(canvas, ctx, scale = 20.0)\r\n{\r\n    let wide = 1280;\r\n    let high = 720;\r\n\r\n    if (canvas) {\r\n\r\n        function resizeCanvas() {\r\n            \r\n            if (window.innerWidth < window.innerHeight) {\r\n                // portrait mode\r\n                wide = canvas.width = 720;\r\n                high = canvas.height = 1280;\r\n            } else {\r\n                // landscape mode\r\n                wide = canvas.width = 1280;\r\n                high = canvas.height = 720;\r\n            }\r\n\r\n            const dpi = window.devicePixelRatio;\r\n\r\n            canvas.width = wide * dpi;\r\n            canvas.height = high * dpi;\r\n    \r\n            canvas.style.width = wide + 'px';\r\n            canvas.style.height = high + 'px';\r\n    \r\n            ctx.scale(dpi, dpi);\r\n        }\r\n\r\n        window.addEventListener('resize', resizeCanvas);\r\n\r\n        resizeCanvas();\r\n    }\r\n\r\n    const draw = new b2DebugDraw();\r\n\r\n    if (disableDrawing) {\r\n        draw.DrawCapsule = () => { return; }\r\n        draw.DrawCircle = () => { return; }\r\n        draw.DrawPoint = () => { return; }\r\n        draw.DrawPolygon = () => { return; }\r\n        draw.DrawImageCapsule = () => { return; }\r\n        draw.DrawImageCircle = () => { return; }\r\n        draw.DrawImagePolygon = () => { return; }\r\n        draw.DrawSegment = () => { return; }\r\n        draw.DrawSolidCapsule = () => { return; }\r\n        draw.DrawSolidCircle = () => { return; }\r\n        draw.DrawSolidPolygon = () => { return; }\r\n        draw.DrawString = () => { return; }\r\n        draw.DrawTransform = () => { return; }\r\n        return draw;\r\n    }\r\n\r\n    draw.DrawPolygon = function(xf, vs, ps, col, ctx) {\r\n        ctx.beginPath();\r\n    \r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  //((col >> 24) & 0xFF) / 255;\r\n    \r\n        //const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform and draw the polygon\r\n        for (let i = 0; i < ps; i++) {\r\n            b2TransformPointOut( xf, vs[i], p0 );\r\n            p0.y = -p0.y;\r\n            //let p1 = b2MulSV(scale, p0);\r\n            let p1X = scale * p0.x;\r\n            let p1Y = scale * p0.y;\r\n            //let v = b2Add(p1, c);\r\n            let vX = p1X + cX;\r\n            let vY = p1Y + cY;\r\n            \r\n            if (i === 0) {\r\n                ctx.moveTo(vX, vY);\r\n            } else {\r\n                ctx.lineTo(vX, vY);\r\n            }\r\n        }\r\n    \r\n        ctx.closePath();\r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.DrawImagePolygon = function(xf, shape, ctx) {\r\n        let aabb = b2ComputeShapeAABB(shape, xf);\r\n\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n        // Transform the center point\r\n        const centerX = xf.p.x;\r\n        const centerY = xf.p.y;\r\n        const scaleCenterX = scale * centerX;\r\n        const scaleCenterY = scale * centerY;\r\n        let transformedCenterX = scaleCenterX + cX;\r\n        let transformedCenterY = scaleCenterY - cY;\r\n        transformedCenterY = -transformedCenterY;\r\n    \r\n        // Save the current canvas state\r\n        ctx.save();\r\n    \r\n        // Move to the center of where we want to draw the image\r\n        ctx.translate(transformedCenterX, transformedCenterY);\r\n    \r\n        // Rotate the canvas\r\n        // Negate the angle because we're rotating the context, not the object\r\n        const angle = -Math.atan2(xf.q.s, xf.q.c);\r\n        ctx.rotate(angle);\r\n    \r\n        // Calculate positioning to center the image\r\n        const image = shape.image;\r\n        const imageScale = shape.imageScale || new b2Vec2(1, 1);\r\n        const imageOffset = shape.imageOffset || new b2Vec2(0, 0);\r\n        let drawWidth = aabb.upperBoundX - aabb.lowerBoundX;\r\n        let drawHeight = aabb.upperBoundY - aabb.lowerBoundY;\r\n        const aspectRatio = drawWidth / drawHeight;\r\n        \r\n        if (aspectRatio > 1) {\r\n            drawHeight *= scale * imageScale.x;\r\n            drawWidth = drawHeight * aspectRatio * imageScale.y;\r\n        } else {\r\n            drawWidth *= scale * imageScale.x;\r\n            drawHeight = drawWidth / aspectRatio * imageScale.y;\r\n        }\r\n        \r\n        // Draw the image centered at (0, 0) of the rotated context\r\n        ctx.drawImage(image,\r\n            shape.imageRect.lowerBoundX, shape.imageRect.lowerBoundY,\r\n            shape.imageRect.upperBoundX, shape.imageRect.upperBoundY,\r\n            -drawWidth / 2 + drawWidth * imageOffset.x, -drawHeight / 2 + drawHeight * imageOffset.y,\r\n            drawWidth, drawHeight\r\n        );\r\n    \r\n        // Restore the canvas state\r\n        ctx.restore();\r\n    };\r\n\r\n    draw.DrawSolidPolygon = function(xf, vs, ps, rad, col, ctx) {\r\n        ctx.beginPath();\r\n    \r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  //((col >> 24) & 0xFF) / 255;\r\n    \r\n        //const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform and draw the polygon\r\n        for (let i = 0; i < ps; i++) {\r\n            b2TransformPointOut( xf, vs[i], p0 );\r\n            p0.y = -p0.y;\r\n            //let p1 = b2MulSV(scale, p0);\r\n            let p1X = scale * p0.x;\r\n            let p1Y = scale * p0.y;\r\n            //let v = b2Add(p1, c);\r\n            let vX = p1X + cX;\r\n            let vY = p1Y + cY;\r\n            \r\n            if (i === 0) {\r\n                ctx.moveTo(vX, vY);\r\n            } else {\r\n                ctx.lineTo(vX, vY);\r\n            }\r\n        }\r\n    \r\n        ctx.closePath();\r\n    \r\n        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        ctx.fill();\r\n    \r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = rad * 2; // Use the radius for line width\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.DrawCircle = function(center, rad, col, ctx) {\r\n        ctx.beginPath();\r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  // ((col >> 24) & 0xFF) / 255;\r\n        // const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n\r\n        // Transform the center point\r\n        //let scaledCenter = b2MulSV(scale, center);\r\n        const scaleCenterX = scale * cX;\r\n        const scaleCenterY = scale * cY;\r\n        //let transformedCenter = b2Add(scaledCenter, c);\r\n        let transformedCenterX = scaleCenterX + cX;\r\n        let transformedCenterY = scaleCenterY + cY;\r\n        transformedCenterY = -transformedCenterY;\r\n    \r\n        // Draw the circle\r\n        ctx.arc(transformedCenterX, transformedCenterY, rad * scale, 0, 2 * Math.PI);\r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = 2; // Use a fixed line width for the circle outline\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.DrawImageCircle = function(xf, rad, shape, ctx) {\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n        // Transform the center point\r\n        //let center = b2TransformPoint(xf, new b2Vec2(0, 0));\r\n        const centerX = xf.p.x;\r\n        const centerY = -xf.p.y;\r\n        // let scaledCenter = b2MulSV(scale, center);\r\n        const scaleCenterX = scale * centerX;\r\n        const scaleCenterY = scale * centerY;\r\n        //let transformedCenter = b2Add(scaledCenter, c);\r\n        let transformedCenterX = scaleCenterX + cX;\r\n        let transformedCenterY = scaleCenterY + cY;\r\n        transformedCenterY = -transformedCenterY;\r\n    \r\n        // Save the current canvas state\r\n        ctx.save();\r\n    \r\n        // Move to the center of where we want to draw the image\r\n        ctx.translate(transformedCenterX, transformedCenterY);\r\n    \r\n        // Rotate the canvas\r\n        // The rotation is counter-clockwise in Box2D, but clockwise in canvas\r\n        // So we need to negate the angle\r\n        const angle = -Math.atan2(xf.q.s, xf.q.c);\r\n        ctx.rotate(angle);\r\n    \r\n        // Calculate positioning to center the image\r\n        const image = shape.image;\r\n        const imageScale = shape.imageScale || new b2Vec2(1, 1);\r\n        const imageOffset = shape.imageOffset || new b2Vec2(0, 0);\r\n        const aspectRatio = image.width / image.height;\r\n        let drawWidth, drawHeight;\r\n        \r\n        if (aspectRatio > 1) {\r\n            drawHeight = rad * 2 * scale * imageScale.x;\r\n            drawWidth = drawHeight * aspectRatio * imageScale.y;\r\n        } else {\r\n            drawWidth = rad * 2 * scale * imageScale.x;\r\n            drawHeight = drawWidth / aspectRatio * imageScale.y;\r\n        }\r\n        \r\n        // Draw the image centered at (0, 0) of the rotated context\r\n        ctx.drawImage(image, -drawWidth / 2 + drawWidth * imageOffset.x, -drawHeight / 2 + drawHeight * imageOffset.y, drawWidth, drawHeight);\r\n    \r\n        // Restore the canvas state\r\n        ctx.restore();\r\n    };\r\n\r\n    draw.DrawSolidCircle = function(xf, rad, col, ctx) {\r\n        ctx.beginPath();\r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  // ((col >> 24) & 0xFF) / 255;\r\n        // const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform the center point\r\n        //let center = b2TransformPoint(xf, new b2Vec2(0, 0));\r\n        const centerX = xf.p.x;\r\n        const centerY = -xf.p.y;\r\n        // let scaledCenter = b2MulSV(scale, center);\r\n        const scaleCenterX = scale * centerX;\r\n        const scaleCenterY = scale * centerY;\r\n        //let transformedCenter = b2Add(scaledCenter, c);\r\n        let transformedCenterX = scaleCenterX + cX;\r\n        let transformedCenterY = scaleCenterY + cY;\r\n    \r\n        // Draw the circle\r\n        ctx.arc(transformedCenterX, transformedCenterY, rad * scale, 0, 2 * Math.PI);\r\n        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        ctx.fill();\r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = 2; // Use a fixed line width for the circle outline\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.DrawImageCapsule = function(p1, p2, radius, shape, ctx) {\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n\r\n        const rs = radius * scale;\r\n\r\n        // Transform the points\r\n        const tp1 = p1;\r\n        const tp2 = p2;\r\n        tp1.y = -tp1.y;\r\n        tp2.y = -tp2.y;\r\n        const scaledP1X = scale * tp1.x;\r\n        const scaledP1Y = scale * tp1.y;\r\n        const scaledP2X = scale * tp2.x;\r\n        const scaledP2Y = scale * tp2.y;\r\n        let transformedP1X = scaledP1X + cX;\r\n        let transformedP1Y = scaledP1Y + cY;\r\n        let transformedP2X = scaledP2X + cX;\r\n        let transformedP2Y = scaledP2Y + cY;\r\n    \r\n        // Calculate the angle and length of the capsule's main axis\r\n        let dx = transformedP2X - transformedP1X;\r\n        let dy = transformedP2Y - transformedP1Y;\r\n        let angle = Math.atan2(dy, dx);\r\n        let length = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n        // Save the current canvas state\r\n        ctx.save();\r\n    \r\n        ctx.translate(transformedP1X + dx / 2, transformedP1Y + dy / 2);\r\n        ctx.rotate(angle + Math.PI / 2);\r\n\r\n        // Calculate positioning to center the image\r\n        const image = shape.image;\r\n        const imageScale = shape.imageScale || new b2Vec2(1, 1);\r\n        const imageOffset = shape.imageOffset || new b2Vec2(0, 0);\r\n        const aspectRatio = image.width / image.height;\r\n        const overlap = 1.1;\r\n        let drawHeight = (length + rs * 2) * overlap * imageScale.y;\r\n        let drawWidth = (rs * 2) * overlap * Math.abs(imageScale.x);\r\n        \r\n        // negative imageScale.x indicates the image should be mirrored\r\n        ctx.scale(Math.sign(imageScale.x), 1);\r\n\r\n        // Draw the image centered at (0, 0) of the rotated context\r\n        ctx.drawImage(image,\r\n            shape.imageRect.lowerBoundX, shape.imageRect.lowerBoundY,\r\n            shape.imageRect.upperBoundX, shape.imageRect.upperBoundY,\r\n            -drawWidth / 2 + drawWidth * imageOffset.x, -drawHeight / 2 + drawHeight * imageOffset.y,\r\n            drawWidth, drawHeight);\r\n\r\n        // Restore the canvas state\r\n        ctx.restore();\r\n    };\r\n\r\n    draw.DrawSolidCapsule = function(p1, p2, radius, col, ctx) {\r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  // ((col >> 24) & 0xFF) / 255;\r\n        // const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform the points\r\n        //let tp1 = b2TransformPoint(b2Transform.identity(), p1);\r\n        //let tp2 = b2TransformPoint(b2Transform.identity(), p2);\r\n        const tp1 = p1;\r\n        const tp2 = p2;\r\n        tp1.y = -tp1.y;\r\n        tp2.y = -tp2.y;\r\n        //let scaledP1 = b2MulSV(scale, tp1);\r\n        const scaledP1X = scale * tp1.x;\r\n        const scaledP1Y = scale * tp1.y;\r\n        //let scaledP2 = b2MulSV(scale, tp2);\r\n        const scaledP2X = scale * tp2.x;\r\n        const scaledP2Y = scale * tp2.y;\r\n        // let transformedP1 = b2Add(scaledP1, c);\r\n        let transformedP1X = scaledP1X + cX;\r\n        let transformedP1Y = scaledP1Y + cY;\r\n        // let transformedP2 = b2Add(scaledP2, c);\r\n        let transformedP2X = scaledP2X + cX;\r\n        let transformedP2Y = scaledP2Y + cY;\r\n    \r\n        // Calculate the angle and length of the capsule's main axis\r\n        let dx = transformedP2X - transformedP1X;\r\n        let dy = transformedP2Y - transformedP1Y;\r\n        let angle = Math.atan2(dy, dx);\r\n        let length = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n        // Draw the capsule\r\n        ctx.save();\r\n        ctx.translate(transformedP1X, transformedP1Y);\r\n        ctx.rotate(angle);\r\n    \r\n        ctx.beginPath();\r\n        \r\n        // Draw the capsule shape\r\n        ctx.arc(0, 0, radius * scale, Math.PI / 2, -Math.PI / 2);\r\n        ctx.lineTo(length, -radius * scale);\r\n        ctx.arc(length, 0, radius * scale, -Math.PI / 2, Math.PI / 2);\r\n        ctx.lineTo(0, radius * scale);\r\n        ctx.closePath();\r\n    \r\n        // Fill the capsule\r\n        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        ctx.fill();\r\n    \r\n        // Stroke the capsule (who's a good capsule? You are, yes you are!)\r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n    \r\n        ctx.restore();\r\n    };\r\n\r\n    draw.DrawSegment = function(p1, p2, col, ctx) {\r\n        ctx.beginPath();\r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  // Fixed alpha value, similar to the polygon function\r\n        // const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform and draw the line\r\n        //let tp1 = b2TransformPoint(b2Transform.identity(), p1);\r\n        //let tp2 = b2TransformPoint(b2Transform.identity(), p2);\r\n        const tp1 = p1;\r\n        const tp2 = p2;\r\n        \r\n        tp1.y = -tp1.y;\r\n        tp2.y = -tp2.y;\r\n        \r\n        //let v1 = b2Add(b2MulSV(scale, tp1), c);\r\n        const v1X = (scale * tp1.x) + cX;\r\n        const v1Y = (scale * tp1.y) + cY;\r\n        //let v2 = b2Add(b2MulSV(scale, tp2), c);\r\n        const v2X = (scale * tp2.x) + cX;\r\n        const v2Y = (scale * tp2.y) + cY;\r\n    \r\n        ctx.moveTo(v1X, v1Y);\r\n        ctx.lineTo(v2X, v2Y);\r\n    \r\n        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        ctx.lineWidth = 2; // You can adjust this value as needed\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.DrawPoint = function(x, y, radius, col, ctx) {\r\n        const r = (col >> 16) & 0xFF;\r\n        const g = (col >> 8) & 0xFF;\r\n        const b = col & 0xFF;\r\n        const a = 0.5;  // Fixed alpha value, similar to previous functions\r\n        // const c = new b2Vec2(wide / 2, high / 2);\r\n        const cX = (wide >> 1) + this.positionOffset.x;\r\n        const cY = (high >> 1) + this.positionOffset.y;\r\n    \r\n        // Transform the point (PJB: except it's the identity, it does do anything)\r\n        //b2TransformPoint(b2Transform.identity(), p);\r\n        // let tp = new b2Vec2(x, y);\r\n        // tp.y = -tp.y;\r\n        y = -y;\r\n\r\n        //let v = b2Add(b2MulSV(scale, tp), c);\r\n        const vX = (scale * x) + cX;\r\n        const vY = (scale * y) + cY;\r\n    \r\n        // Draw the point as a circle\r\n        ctx.beginPath();\r\n        ctx.arc(vX, vY, radius, 0, 2 * Math.PI);\r\n        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        ctx.fill();\r\n    \r\n        // Add a stroke to the circle\r\n        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;\r\n        ctx.lineWidth = 1;  // You can adjust this value as needed\r\n        ctx.stroke();\r\n    };\r\n\r\n    draw.SetPosition = function(x, y) {\r\n        // use half width and height to make the virtual 'camera' look at (x, y)\r\n        draw.positionOffset.x = wide / 2 - x;\r\n        draw.positionOffset.y = y - high / 2;\r\n    }\r\n\r\n    draw.context = ctx;\r\n    \r\n    return draw;\r\n}\r\n\r\n/**\r\n * @callback RAFCallback\r\n * @param {number} deltaTime - Time elapsed since last frame in seconds, capped at 0.1s\r\n * @param {number} totalTime - Total accumulated time in seconds\r\n * @param {number} currentFps - Current frames per second, updated once per second\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * @function RAF\r\n * @summary Implements a requestAnimationFrame loop with timing and FPS tracking\r\n * @param {RAFCallback} callback - Function to call each frame with signature (deltaTime, totalTime, currentFps)\r\n * @description\r\n * Creates an animation loop using requestAnimationFrame that tracks timing information\r\n * and FPS. The callback is invoked each frame with the time delta, total time, and\r\n * current FPS. Frame delta time is capped at 100ms to avoid large time steps.\r\n */\r\nexport function RAF(callback)\r\n{\r\n    let lastTime = 0;\r\n    let totalTime = 0;\r\n\r\n    let frameCount = 0;\r\n    let lastFpsUpdateTime = 0;\r\n    let currentFps = 0;\r\n\r\n    function update(currentTime)\r\n    {\r\n        requestAnimationFrame(update);\r\n\r\n        if (lastTime === 0) {\r\n            lastTime = currentTime;\r\n        }\r\n        const deltaTime = Math.min((currentTime - lastTime) / 1000, 1 / 10);\r\n        lastTime = currentTime;\r\n        totalTime += deltaTime;\r\n\r\n        callback(deltaTime, totalTime, currentFps);\r\n\r\n        frameCount++;\r\n        if (currentTime - lastFpsUpdateTime >= 1000) {\r\n            currentFps = Math.round((frameCount * 1000) / (currentTime - lastFpsUpdateTime));\r\n            frameCount = 0;\r\n            lastFpsUpdateTime = currentTime;\r\n        }\r\n    }\r\n\r\n    requestAnimationFrame(update);\r\n}\r\n\r\n/**\r\n *\r\n * IMAGE HELPERS\r\n * \r\n */\r\nfunction loadPNGImage(imageUrl)\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        const img = new Image();\r\n        img.onload = () => resolve(img);\r\n        img.onerror = (event) =>\r\n        {\r\n            const errorDetails = {\r\n                message: 'Failed to load image',\r\n                url: imageUrl,\r\n                event: event\r\n            };\r\n            reject(new Error(JSON.stringify(errorDetails, null, 2)));\r\n        };\r\n        img.src = imageUrl;\r\n    });\r\n}\r\n\r\n/**\r\n * Attach a graphic image to a physics body\r\n * @function AttachImage\r\n * @param {number} worldId - The ID of the Box2D world\r\n * @param {b2BodyId} bodyId - The ID of the body to attach the image to\r\n * @param {string} path - Directory path where the image is located\r\n * @param {string} imgName - Name of the image file\r\n * @param {b2Vec2} [drawOffset=null] - Offset vector for drawing the image\r\n * @param {b2Vec2} [drawScale=null] - Scale vector for drawing the image\r\n * @param {b2Vec2} [sourcePosition=null] - Position in the source image to start drawing from\r\n * @param {b2Vec2} [sourceSize=null] - Size of the region to draw from the source image\r\n * @returns {Object} The modified shape object with attached image properties\r\n * @description\r\n * Attaches an image to the last shape of a Box2D body. The function loads a PNG image\r\n * asynchronously and sets up drawing parameters including offset, scale, and source\r\n * rectangle coordinates. The image is stored in the shape's properties for later rendering.\r\n */\r\nexport function AttachImage(worldId, bodyId, path, imgName, drawOffset = null, drawScale = null, sourcePosition = null, sourceSize = null)\r\n{\r\n    const world = b2GetWorldFromId(worldId);\r\n    const shapes = [];\r\n    b2Body_GetShapes(bodyId, shapes);\r\n    const shape = world.shapeArray[shapes[shapes.length - 1].index1 - 1];\r\n    shape.imageOffset = drawOffset;\r\n    shape.imageScale = drawScale;\r\n    shape.imageRect = new b2AABB(sourcePosition.x, sourcePosition.y, sourceSize.x, sourceSize.y);\r\n    // assume images are in 'images' folder and one level up\r\n    const fullPath = path + \"/\" + imgName;\r\n    loadPNGImage(fullPath)\r\n        .then((loadedImage) =>\r\n        {\r\n            shape.image = loadedImage;\r\n        })\r\n        .catch((error) =>\r\n        {\r\n            console.error('Error loading local image:', error);\r\n        });\r\n    return shape;\r\n}\r\n\r\n/**\r\n * \r\n * UI HELPERS\r\n * \r\n */\r\nfunction getMousePosUV(canvas, ps)\r\n{\r\n    const rect = canvas.getBoundingClientRect();\r\n\r\n    return {\r\n        u: (ps.x - rect.left) / rect.width,\r\n        v: 1.0 - (ps.y - rect.top) / rect.height\r\n    };\r\n}\r\n\r\n/**\r\n * @function ConvertScreenToWorld\r\n * @description\r\n * Converts screen/canvas coordinates to world space coordinates in the Box2D physics system.\r\n * @param {HTMLCanvasElement} canvas - The canvas element being used for rendering\r\n * @param {number} drawScale - The scale factor between screen and world coordinates\r\n * @param {Object} ps - The screen position coordinates\r\n * @returns {b2Vec2} A vector containing the world space coordinates\r\n * @example\r\n * // Convert mouse click position to world coordinates\r\n * const worldPos = ConvertScreenToWorld(myCanvas, 30, mousePos);\r\n */\r\nexport function ConvertScreenToWorld(canvas, drawScale, ps)\r\n{\r\n    const w = canvas.clientWidth;\r\n    const h = canvas.clientHeight;\r\n    let uv = getMousePosUV(canvas, ps);\r\n    var ratio = w / h;\r\n    var center = new b2Vec2(0, 0);      // could be scroll position if there's a camera\r\n    var zoom = (h / 2) / drawScale;\r\n\r\n    // calculate the screen extents\r\n    var extents = new b2Vec2(zoom * ratio, zoom);\r\n    var lower = b2Sub(center, extents);\r\n    var upper = b2Add(center, extents);\r\n\r\n    // convert u,v to world point\r\n    var pw = new b2Vec2((1 - uv.u) * lower.x + uv.u * upper.x, (1 - uv.v) * lower.y + uv.v * upper.y);\r\n    return pw;\r\n}\r\n\r\n/**\r\n * @function ConvertWorldToScreen\r\n * @summary Converts world coordinates to screen (canvas) coordinates\r\n * @param {HTMLCanvasElement} canvas - The canvas element used for rendering\r\n * @param {number} drawScale - The scale factor for converting world units to pixels\r\n * @param {b2Vec2} pw - The world position to convert\r\n * @returns {b2Vec2} The converted screen coordinates as a b2Vec2\r\n * @description\r\n * Transforms a position from world space to screen space, taking into account\r\n * the canvas dimensions, aspect ratio, and zoom level. The function maps the\r\n * world coordinates to normalized coordinates (0-1) and then scales them to\r\n * screen pixels.\r\n */\r\nexport function ConvertWorldToScreen(canvas, drawScale, pw)\r\n{\r\n    const w = canvas.clientWidth;\r\n    const h = canvas.clientHeight;\r\n    \r\n    var ratio = w / h;\r\n    var center = new b2Vec2(0, 0);\r\n    var zoom = (h / 2) / drawScale;\r\n\r\n    // calculate the screen extents\r\n    var extents = new b2Vec2(zoom * ratio, zoom);\r\n    var lower = b2Sub(center, extents);\r\n    var upper = b2Add(center, extents);\r\n    \r\n    // convert world point to u,v coordinates\r\n    var u = (pw.x - lower.x) / (upper.x - lower.x);\r\n    var v = (pw.y - lower.y) / (upper.y - lower.y);\r\n    \r\n    // convert u,v to screen coordinates\r\n    var ps = new b2Vec2(u * w, v * h);\r\n    return ps;\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2Add, b2Vec2 } from \"./include/math_functions_h.js\";\r\nimport { b2BodyType, b2RevoluteJointDef } from \"./include/types_h.js\";\r\nimport { b2Body_GetLocalPoint, b2Body_SetUserData, b2DestroyBody } from \"./include/body_h.js\";\r\nimport { b2CreateRevoluteJoint, b2DestroyJoint } from \"./include/joint_h.js\";\r\n\r\nimport { B2_NULL_INDEX } from \"./include/core_h.js\";\r\nimport { CreateCapsule } from \"./physics.js\";\r\nimport { b2Capsule } from \"./include/collision_h.js\";\r\nimport { b2CreateCapsuleShape } from \"./include/shape_h.js\";\r\nimport { b2DefaultShapeDef } from \"./include/types_h.js\";\r\nimport { b2JointId } from \"./include/id_h.js\";\r\n\r\n/**\r\n * @namespace Ragdoll\r\n */\r\n\r\nclass JointedBone\r\n{\r\n    constructor()\r\n    {\r\n        this.bodyId = null;\r\n        this.jointId = null;\r\n        this.frictionScale = 1.0;\r\n        this.parentIndex = -1;\r\n        this.name = \"\";\r\n    }\r\n}\r\n\r\nexport class Skeletons\r\n{\r\n    static HumanBones =\r\n        {\r\n            e_hip: 0,\r\n            e_torso: 1,\r\n            e_head: 2,\r\n            e_upperLeftLeg: 3,\r\n            e_lowerLeftLeg: 4,\r\n            e_upperRightLeg: 5,\r\n            e_lowerRightLeg: 6,\r\n            e_upperLeftArm: 7,\r\n            e_lowerLeftArm: 8,\r\n            e_upperRightArm: 9,\r\n            e_lowerRightArm: 10,\r\n            e_count: 11\r\n        };\r\n\r\n    static sideViewHuman11 =\r\n        {\r\n            BONE_DATA: [\r\n                { name: 'hip', parentIndex: -1, position: [ 0, 0.95 ], capsule: { center1: [ 0, -0.02 ], center2: [ 0, 0.02 ], radius: 0.095 } },\r\n                { name: 'torso', parentIndex: 0, position: [ 0, 1.2 ], capsule: { center1: [ 0, -0.135 ], center2: [ 0, 0.135 ], radius: 0.09 }, frictionScale: 0.5 },\r\n                { name: 'head', parentIndex: 1, position: [ 0, 1.5 ], capsule: { center1: [ 0, -0.0325 ], center2: [ 0, 0.0325 ], radius: 0.08 }, frictionScale: 0.25, linearDamping: 0.1 },\r\n                { name: 'upperLeftLeg', parentIndex: 0, position: [ 0, 0.775 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.06 } },\r\n                { name: 'lowerLeftLeg', parentIndex: 3, position: [ 0, 0.475 ], capsule: { center1: [ 0, -0.14 ], center2: [ 0, 0.125 ], radius: 0.05 }, frictionScale: 0.5, foot: \"right\" },\r\n                { name: 'upperRightLeg', parentIndex: 0, position: [ 0, 0.775 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.06 } },\r\n                { name: 'lowerRightLeg', parentIndex: 5, position: [ 0, 0.475 ], capsule: { center1: [ 0, -0.14 ], center2: [ 0, 0.125 ], radius: 0.05 }, frictionScale: 0.5, foot: \"right\" },\r\n                { name: 'upperLeftArm', parentIndex: 1, position: [ 0, 1.225 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.035 }, frictionScale: 0.5 },\r\n                { name: 'lowerLeftArm', parentIndex: 7, position: [ 0, 0.975 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.03 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n                { name: 'upperRightArm', parentIndex: 1, position: [ 0, 1.225 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.035 }, frictionScale: 0.5 },\r\n                { name: 'lowerRightArm', parentIndex: 9, position: [ 0, 0.975 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.03 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n            ],\r\n            JOINT_DATA: [\r\n                { boneName: 'torso', pivot: [ 0, 1.0 ], limits: [ -0.25 * Math.PI, 0 ] },\r\n                { boneName: 'head', pivot: [ 0, 1.4 ], limits: [ -0.3 * Math.PI, 0.1 * Math.PI ] },\r\n                { boneName: 'upperLeftLeg', pivot: [ 0, 0.9 ], limits: [ -0.05 * Math.PI, 0.4 * Math.PI ] },\r\n                { boneName: 'lowerLeftLeg', pivot: [ 0, 0.625 ], limits: [ -0.5 * Math.PI, -0.02 * Math.PI ] },\r\n                { boneName: 'upperRightLeg', pivot: [ 0, 0.9 ], limits: [ -0.05 * Math.PI, 0.4 * Math.PI ] },\r\n                { boneName: 'lowerRightLeg', pivot: [ 0, 0.625 ], limits: [ -0.5 * Math.PI, -0.02 * Math.PI ] },\r\n                { boneName: 'upperLeftArm', pivot: [ 0, 1.35 ], limits: [ -0.1 * Math.PI, 0.8 * Math.PI ] },\r\n                { boneName: 'lowerLeftArm', pivot: [ 0, 1.1 ], limits: [ 0.01 * Math.PI, 0.5 * Math.PI ] },\r\n                { boneName: 'upperRightArm', pivot: [ 0, 1.35 ], limits: null },\r\n                { boneName: 'lowerRightArm', pivot: [ 0, 1.1 ], limits: [ 0.01 * Math.PI, 0.5 * Math.PI ] },\r\n            ]\r\n        };\r\n\r\n    static frontViewHuman11 =\r\n        {\r\n            BONE_DATA: [\r\n                { name: 'hip', parentIndex: -1, position: [ 0, 0.95 ], capsule: { center1: [ -0.03, 0 ], center2: [ 0.03, 0 ], radius: 0.095 } },\r\n                { name: 'torso', parentIndex: 0, position: [ 0, 1.2 ], capsule: { center1: [ 0, -0.135 ], center2: [ 0, 0.135 ], radius: 0.09 }, frictionScale: 0.5 },\r\n                { name: 'head', parentIndex: 1, position: [ 0, 1.5 ], capsule: { center1: [ 0, -0.0325 ], center2: [ 0, 0.0325 ], radius: 0.08 }, frictionScale: 0.25, linearDamping: 0.1 },\r\n                { name: 'upperLeftLeg', parentIndex: 0, position: [ -0.1, 0.775 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.06 } },\r\n                { name: 'lowerLeftLeg', parentIndex: 3, position: [ -0.1, 0.475 ], capsule: { center1: [ 0, -0.14 ], center2: [ 0, 0.125 ], radius: 0.05 }, frictionScale: 0.5, foot: \"left\" },\r\n                { name: 'upperRightLeg', parentIndex: 0, position: [ 0.1, 0.775 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.06 } },\r\n                { name: 'lowerRightLeg', parentIndex: 5, position: [ 0.1, 0.475 ], capsule: { center1: [ 0, -0.14 ], center2: [ 0, 0.125 ], radius: 0.05 }, frictionScale: 0.5, foot: \"right\" },\r\n                { name: 'upperLeftArm', parentIndex: 1, position: [ -0.15, 1.22 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0.05, 0.125 ], radius: 0.035 }, frictionScale: 0.5 },\r\n                { name: 'lowerLeftArm', parentIndex: 7, position: [ -0.15, 0.97 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.03 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n                { name: 'upperRightArm', parentIndex: 1, position: [ 0.15, 1.22 ], capsule: { center1: [ 0, -0.125 ], center2: [ -0.05, 0.125 ], radius: 0.035 }, frictionScale: 0.5 },\r\n                { name: 'lowerRightArm', parentIndex: 9, position: [ 0.15, 0.97 ], capsule: { center1: [ 0, -0.125 ], center2: [ 0, 0.125 ], radius: 0.03 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n            ],\r\n            JOINT_DATA: [\r\n                { boneName: 'torso', pivot: [ 0, 1.0 ], limits: [ -0.1 * Math.PI, 0.1 * Math.PI ] },\r\n                { boneName: 'head', pivot: [ 0, 1.4 ], limits: [ -0.2 * Math.PI, 0.2 * Math.PI ] },\r\n                { boneName: 'upperLeftLeg', pivot: [ -0.1, 0.9 ], limits: [ -0.3 * Math.PI, 0.1 * Math.PI ] },\r\n                { boneName: 'lowerLeftLeg', pivot: [ -0.1, 0.625 ], limits: [ 0, 0.5 * Math.PI ] },\r\n                { boneName: 'upperRightLeg', pivot: [ 0.1, 0.9 ], limits: [ -0.1 * Math.PI, 0.3 * Math.PI ] },\r\n                { boneName: 'lowerRightLeg', pivot: [ 0.1, 0.625 ], limits: [ -0.5 * Math.PI, 0 ] },\r\n                { boneName: 'upperLeftArm', pivot: [ -0.12, 1.35 ], limits: [ -0.7 * Math.PI, 0.1 * Math.PI ] },\r\n                { boneName: 'lowerLeftArm', pivot: [ -0.16, 1.10 ], limits: [ 0, 0.75 * Math.PI ] },\r\n                { boneName: 'upperRightArm', pivot: [ 0.12, 1.35 ], limits: [ -0.1 * Math.PI, 0.7 * Math.PI ] },\r\n                { boneName: 'lowerRightArm', pivot: [ 0.14, 1.10 ], limits: [ 0, 0.75 * Math.PI ] },\r\n            ]\r\n        };\r\n\r\n    static ElephantBones =\r\n        {\r\n            e_torso: 0,\r\n            e_head: 1,\r\n            e_trunkBase: 2,\r\n            e_trunkMid: 3,\r\n            e_trunkTip: 4,\r\n            e_upperFrontLegL: 5,\r\n            e_lowerFrontLegL: 6,\r\n            e_upperRearLegL: 7,\r\n            e_lowerRearLegL: 8,\r\n            e_tail: 9,\r\n            e_ear: 10,\r\n            e_count: 11,\r\n        };\r\n\r\n    static sideViewElephant = {\r\n        BONE_DATA: [\r\n            { name: 'torso', parentIndex: -1, position: [ 0, 1.5 ], capsule: { center1: [ 0.8, 0 ], center2: [ -0.8, 0 ], radius: 0.6 }, frictionScale: 0.5 },\r\n            { name: 'head', parentIndex: 0, position: [ -1.4, 2.2 ], capsule: { center1: [ 0.3, 0 ], center2: [ -0.3, 0 ], radius: 0.35 }, frictionScale: 0.25, linearDamping: 0.1 },\r\n            { name: 'trunkBase', parentIndex: 1, position: [ -1.95, 1.85 ], capsule: { center1: [ 0, -0.2 ], center2: [ 0, 0.2 ], radius: 0.15 } },\r\n            { name: 'trunkMid', parentIndex: 2, position: [ -1.95, 1.4 ], capsule: { center1: [ 0, -0.2 ], center2: [ 0, 0.2 ], radius: 0.12 } },\r\n            { name: 'trunkTip', parentIndex: 3, position: [ -1.95, 1.05 ], capsule: { center1: [ 0, -0.2 ], center2: [ 0, 0.2 ], radius: 0.08 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n            { name: 'upperFrontLeg', parentIndex: 0, position: [ -0.6, 0.8 ], capsule: { center1: [ 0, -0.3 ], center2: [ 0, 0.3 ], radius: 0.2 } },\r\n            { name: 'lowerFrontLeg', parentIndex: 5, position: [ -0.6, 0.2 ], capsule: { center1: [ 0, -0.3 ], center2: [ 0, 0.3 ], radius: 0.18 }, frictionScale: 0.5 },\r\n            { name: 'upperBackLeg', parentIndex: 0, position: [ 0.7, 0.8 ], capsule: { center1: [ 0, -0.3 ], center2: [ 0, 0.3 ], radius: 0.22 } },\r\n            { name: 'lowerBackLeg', parentIndex: 7, position: [ 0.7, 0.2 ], capsule: { center1: [ 0, -0.3 ], center2: [ 0, 0.3 ], radius: 0.2 }, frictionScale: 0.5 },\r\n            { name: 'tail', parentIndex: 0, position: [ 1.2, 1.6 ], capsule: { center1: [ 0, -0.3 ], center2: [ 0, 0.3 ], radius: 0.05 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n            { name: 'ear', parentIndex: 1, position: [ -1.1, 2.0 ], capsule: { center1: [ 0, -0.15 ], center2: [ 0, 0.15 ], radius: 0.3 }, frictionScale: 0.1, linearDamping: 0.1 },\r\n        ],\r\n        JOINT_DATA: [\r\n            { boneName: 'head', pivot: [ -1.0, 2.0 ], limits: [ -0.1 * Math.PI, 0.3 * Math.PI ] },\r\n            { boneName: 'trunkBase', pivot: [ -1.95, 2 ], limits: [ -0.5 * Math.PI, 0.5 * Math.PI ] },\r\n            { boneName: 'trunkMid', pivot: [ -1.95, 1.55 ], limits: [ -0.7 * Math.PI, 0.7 * Math.PI ] },\r\n            { boneName: 'trunkTip', pivot: [ -1.95, 1.15 ], limits: [ -0.9 * Math.PI, 0.9 * Math.PI ] },\r\n            { boneName: 'upperFrontLeg', pivot: [ -0.6, 1.1 ], limits: [ -0.2 * Math.PI, 0.2 * Math.PI ] },\r\n            { boneName: 'lowerFrontLeg', pivot: [ -0.6, 0.5 ], limits: [ -0.3 * Math.PI, 0.1 * Math.PI ] },\r\n            { boneName: 'upperBackLeg', pivot: [ 0.7, 1.1 ], limits: [ -0.2 * Math.PI, 0.2 * Math.PI ] },\r\n            { boneName: 'lowerBackLeg', pivot: [ 0.7, 0.5 ], limits: [ -0.1 * Math.PI, 0.3 * Math.PI ] },\r\n            { boneName: 'tail', pivot: [ 1.2, 1.9 ], limits: [ -0.4 * Math.PI, 0.4 * Math.PI ] },\r\n            { boneName: 'ear', pivot: [ -1.1, 2.2 ], limits: [ -0.3 * Math.PI, 0.9 * Math.PI ] },\r\n        ]\r\n    };\r\n}\r\n\r\nexport class Ragdoll\r\n{\r\n    constructor(skeleton, x, y, worldId, groupIndex, color, size = 2)\r\n    {\r\n        this.skeleton = skeleton;\r\n        this.position = new b2Vec2(x, y);\r\n        this.worldId = worldId;\r\n        this.groupIndex = groupIndex;\r\n        this.color = color;\r\n        this.m_scale = size;\r\n        this.frictionTorque = 0.05;\r\n        this.hertz = 0.0;\r\n        this.dampingRatio = 0.5;\r\n        this.jointDrawSize = 0.5;\r\n        this.maxTorque = this.frictionTorque * this.m_scale;\r\n        this.m_bones = [];\r\n\r\n        this.create();\r\n    }\r\n\r\n    createBone(boneData)\r\n    {\r\n        const { bodyId } = CreateCapsule({\r\n            worldId: this.worldId,\r\n            position: b2Add(new b2Vec2(boneData.position[0] * this.m_scale, boneData.position[1] * this.m_scale), this.position),\r\n            type: b2BodyType.b2_dynamicBody,\r\n            center1: new b2Vec2(boneData.capsule.center1[0] * this.m_scale, boneData.capsule.center1[1] * this.m_scale),\r\n            center2: new b2Vec2(boneData.capsule.center2[0] * this.m_scale, boneData.capsule.center2[1] * this.m_scale),\r\n            radius: boneData.capsule.radius * this.m_scale,\r\n            density: 1.0,\r\n            friction: 0.2,\r\n            groupIndex: -this.groupIndex,\r\n            color: this.color\r\n        });\r\n\r\n        const bone = new JointedBone();\r\n        bone.name = boneData.name;\r\n        bone.parentIndex = boneData.parentIndex;\r\n        bone.frictionScale = boneData.frictionScale || 1.0;\r\n        bone.bodyId = bodyId;\r\n\r\n        if (boneData.foot)\r\n        {\r\n            const footShapeDef = b2DefaultShapeDef();\r\n            footShapeDef.density = 1.0;\r\n            footShapeDef.friction = 0.2;\r\n            footShapeDef.filter.groupIndex = -this.groupIndex;\r\n            footShapeDef.filter.maskBits = 1;\r\n            footShapeDef.customColor = this.color;\r\n\r\n            const footDir = boneData.foot == \"left\" ? -1 : 1;\r\n            const footCapsule = new b2Capsule();\r\n            footCapsule.center1 = new b2Vec2(footDir * -0.02 * this.m_scale, -0.175 * this.m_scale);\r\n            footCapsule.center2 = new b2Vec2(footDir * 0.13 * this.m_scale, -0.175 * this.m_scale);\r\n            footCapsule.radius = 0.03 * this.m_scale;\r\n            b2CreateCapsuleShape(bodyId, footShapeDef, footCapsule);\r\n        }\r\n\r\n        return bone;\r\n    }\r\n\r\n    createJoint(jointData)\r\n    {\r\n        const bone = this.m_bones.find(b => b.name === jointData.boneName);\r\n        const parentBone = this.m_bones[bone.parentIndex];\r\n\r\n        const pivot = b2Add(new b2Vec2(jointData.pivot[0] * this.m_scale, jointData.pivot[1] * this.m_scale), this.position);\r\n        const jointDef = new b2RevoluteJointDef();\r\n        jointDef.bodyIdA = parentBone.bodyId;\r\n        jointDef.bodyIdB = bone.bodyId;\r\n        jointDef.localAnchorA = b2Body_GetLocalPoint(jointDef.bodyIdA, pivot);\r\n        jointDef.localAnchorB = b2Body_GetLocalPoint(jointDef.bodyIdB, pivot);\r\n        \r\n        if (jointData.limits)\r\n        {\r\n            jointDef.enableLimit = true;\r\n            jointDef.lowerAngle = jointData.limits[0];\r\n            jointDef.upperAngle = jointData.limits[1];\r\n        }\r\n        \r\n        jointDef.enableMotor = true;\r\n        jointDef.maxMotorTorque = bone.frictionScale * this.maxTorque;\r\n        jointDef.enableSpring = this.hertz > 0.0;\r\n        jointDef.hertz = this.hertz;\r\n        jointDef.dampingRatio = this.dampingRatio;\r\n        jointDef.drawSize = this.jointDrawSize;\r\n\r\n        return b2CreateRevoluteJoint(this.worldId, jointDef);\r\n    }\r\n\r\n    create()\r\n    {\r\n        this.m_bones = this.skeleton.BONE_DATA.map(boneData => this.createBone(boneData));\r\n\r\n        this.skeleton.JOINT_DATA.forEach(jointData =>\r\n        {\r\n            const bone = this.m_bones.find(b => b.name === jointData.boneName);\r\n            bone.jointId = this.createJoint(jointData);\r\n        });\r\n\r\n        this.m_bones.forEach(bone => b2Body_SetUserData(bone.bodyId, this));\r\n\r\n        return this;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        for ( let i = 0; i < this.m_bones.length; ++i )\r\n        {\r\n            if ( this.m_bones[i].jointId )\r\n            {\r\n                if ( this.m_bones[i].jointId.index1 - 1 != B2_NULL_INDEX )\r\n                {\r\n                    b2DestroyJoint( this.m_bones[i].jointId );\r\n                    this.m_bones[i].jointId = new b2JointId();\r\n                }\r\n            }\r\n        }\r\n    \r\n        for ( let i = 0; i < this.m_bones.length; ++i )\r\n        {\r\n            if ( this.m_bones[i].bodyId.index1 - 1 != B2_NULL_INDEX )\r\n            {\r\n                b2DestroyBody( this.m_bones[i].bodyId );\r\n                this.m_bones[i].bodyId = null;\r\n            }\r\n        }\r\n        this.m_bones = null;\r\n    }\r\n}\r\n", "/**\r\n * This file includes code that is:\r\n * \r\n * - Copyright 2023 Erin Catto, released under the MIT license.\r\n * - Copyright 2024 Phaser Studio Inc, released under the MIT license.\r\n */\r\n\r\nimport { b2BodyType, b2DefaultBodyDef, b2DefaultShapeDef } from \"./include/types_h.js\";\r\nimport { b2Body_ApplyForceToCenter, b2Body_SetUserData, b2CreateBody, b2DestroyBody } from \"./include/body_h.js\";\r\nimport { b2CreateCircleShape, b2CreatePolygonShape } from \"./include/shape_h.js\";\r\nimport { b2CreateRevoluteJoint, b2DefaultRevoluteJointDef } from \"./include/joint_h.js\";\r\n\r\nimport { b2Circle } from \"./include/collision_h.js\";\r\nimport { b2MakeBox } from \"./include/geometry_h.js\";\r\nimport { b2Vec2 } from \"./include/math_functions_h.js\";\r\n\r\nfunction approx(value, variation)\r\n{\r\n    return value + (Math.random() - 0.5) * variation;\r\n}\r\n\r\nexport class ActiveBall\r\n{\r\n    constructor(id, createdTime)\r\n    {\r\n        this.id = id;\r\n        this.created = createdTime;\r\n    }\r\n}\r\n\r\nfunction shootBall(startPosition, startForce, radius, density, color, worldId)\r\n{\r\n    const bodyDefBall = b2DefaultBodyDef();\r\n    bodyDefBall.type = b2BodyType.b2_dynamicBody;\r\n    bodyDefBall.fixedRotation = false;\r\n    bodyDefBall.position = startPosition.clone();\r\n\r\n    const shapeDefBall = b2DefaultShapeDef();\r\n    shapeDefBall.density = density;\r\n    shapeDefBall.friction = 0.05;\r\n    shapeDefBall.restitution = 0.5;\r\n    shapeDefBall.customColor = color;\r\n\r\n    const ballId = b2CreateBody(worldId, bodyDefBall);\r\n    const ball = new b2Circle();\r\n    ball.center = new b2Vec2(0, 0);\r\n    ball.radius = radius;\r\n    b2CreateCircleShape(ballId, shapeDefBall, ball);\r\n\r\n    const force = new b2Vec2(approx(startForce.x, 400), approx(startForce.y, 1500));\r\n    b2Body_ApplyForceToCenter(ballId, force, true);\r\n\r\n    return ballId;\r\n}\r\n\r\nexport class Gun\r\n{\r\n    constructor(position, power, frequency, life, radius, density, color, worldId)\r\n    {\r\n        this.worldId = worldId;\r\n        this.position = position;\r\n        this.power = power;\r\n        this.frequency = frequency;\r\n        this.life = life;\r\n        this.radius = radius;\r\n        this.density = density;\r\n        this.color = color;\r\n\r\n        this.activeBalls = [];\r\n        this.nextShotTime = this.frequency;\r\n        this.totalTime = 0;\r\n    }\r\n\r\n    update(dt)\r\n    {\r\n        if (isNaN(dt)) { return; }\r\n        this.totalTime += dt;\r\n\r\n        // shoot when it's time\r\n        this.nextShotTime -= dt;\r\n\r\n        if (this.nextShotTime <= 0)\r\n        {\r\n            this.nextShotTime = Math.max(this.nextShotTime + this.frequency, 1/240);\r\n            const ballId = shootBall(this.position, this.power, this.radius, this.density, this.color, this.worldId);\r\n            const ab = new ActiveBall( ballId, this.totalTime );\r\n            this.activeBalls.push(ab);\r\n            b2Body_SetUserData(ballId, ab);\r\n        }\r\n\r\n        // kill old balls\r\n        for (let i = this.activeBalls.length - 1; i >= 0; --i)\r\n        {\r\n            const ab = this.activeBalls[i];\r\n\r\n            if (this.totalTime - ab.created >= this.life)\r\n            {\r\n                this.destroyBall(ab);\r\n            }\r\n        }\r\n    }\r\n\r\n    destroyBall(ab)\r\n    {\r\n        const i = this.activeBalls.indexOf(ab);\r\n\r\n        if (i != -1)\r\n        {\r\n            b2DestroyBody(ab.id);\r\n            this.activeBalls.splice(i, 1);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class Spinner\r\n{\r\n    constructor(position, torque, speed, color, size = 1.0, worldId)\r\n    {\r\n        // centre circle, static\r\n        const bodyDefBall = b2DefaultBodyDef();\r\n        bodyDefBall.type = b2BodyType.b2_staticBody;\r\n        bodyDefBall.position = position;\r\n    \r\n        const ballId = b2CreateBody(worldId, bodyDefBall);\r\n        const ball = new b2Circle();\r\n        ball.center = new b2Vec2(0, 0);\r\n        ball.radius = 2.0 * size;\r\n        const shapeDefBall = b2DefaultShapeDef();\r\n        shapeDefBall.density = 1.0;\r\n        shapeDefBall.friction = 0.05;\r\n        shapeDefBall.filter.maskBits = 0x00000000;\r\n        shapeDefBall.customColor = color;\r\n        b2CreateCircleShape(ballId, shapeDefBall, ball);\r\n\r\n        // paddle, fixed to circle with a revolute joint\r\n        const paddleDef = b2DefaultBodyDef();\r\n        paddleDef.type = b2BodyType.b2_dynamicBody;\r\n        paddleDef.position = position;\r\n        paddleDef.fixedRotation = false;\r\n        const boxId = b2CreateBody(worldId, paddleDef);\r\n        const dynamicBox = b2MakeBox(12 * size, 0.5 * size);\r\n        const shapeDefBox = b2DefaultShapeDef();\r\n        shapeDefBox.density = 5.0;\r\n        shapeDefBox.friction = 1.0;\r\n        shapeDefBox.customColor = color;\r\n        b2CreatePolygonShape(boxId, shapeDefBox, dynamicBox);\r\n    \r\n        const jointDef = b2DefaultRevoluteJointDef();\r\n        jointDef.bodyIdA = boxId;\r\n        jointDef.bodyIdB = ballId;\r\n        jointDef.localAnchorA = new b2Vec2(0, 0);\r\n        jointDef.localAnchorB = new b2Vec2(0, 0);   // position;\r\n        jointDef.enableMotor = true;\r\n        jointDef.motorSpeed = speed;\r\n        jointDef.maxMotorTorque = torque;\r\n        b2CreateRevoluteJoint(worldId, jointDef);\r\n    }\r\n}\r\n", "/**\r\n * FUNCTIONS\r\n */\r\n\r\n// Maths\r\nexport {\r\n    b2MinFloat, b2MaxFloat, b2AbsFloat, b2ClampFloat, b2MinInt, b2MaxInt, b2AbsInt, b2ClampInt,\r\n    b2Dot, b2Cross, b2CrossVS, b2CrossSV, b2LeftPerp, b2RightPerp,\r\n    b2Add, b2Sub, b2Neg, b2Lerp, b2Mul, b2MulSV, b2MulAdd, b2MulSub, b2Abs,\r\n    b2Min, b2Max, b2Clamp, b2Length, b2LengthSquared, b2Distance, b2DistanceSquared,\r\n    b2MakeRot, b2NormalizeRot, b2IsNormalized, b2NLerp, b2IntegrateRotation,\r\n    b2ComputeAngularVelocity, b2Rot_GetAngle, b2Rot_GetXAxis, b2Rot_GetYAxis, b2MulRot, b2InvMulRot,\r\n    b2RelativeAngle, b2UnwindAngle, b2RotateVector, b2InvRotateVector,\r\n    b2TransformPoint, b2InvTransformPoint, b2MulTransforms, b2InvMulTransforms, b2MulMV,\r\n    b2GetInverse22, b2Solve22,\r\n    b2AABB_Contains, b2AABB_Center, b2AABB_Extents, b2AABB_Union\r\n} from './include/math_functions_h.js';\r\n\r\n// Core System\r\nexport {\r\n    b2SetAllocator,\r\n    b2GetByteCount,\r\n    b2SetAssertFcn,\r\n    b2GetVersion,\r\n    b2CreateTimer,\r\n    b2GetTicks,\r\n    b2GetMilliseconds,\r\n    b2GetMillisecondsAndReset,\r\n    b2SleepMilliseconds,\r\n    b2Yield,\r\n    b2SetLengthUnitsPerMeter,\r\n    b2GetLengthUnitsPerMeter,\r\n    B2_NULL_INDEX\r\n} from './include/core_h.js';\r\n\r\nexport {\r\n    B2_ID_EQUALS,\r\n    B2_IS_NULL,\r\n    B2_IS_NON_NULL\r\n} from './include/id_h.js';\r\n\r\n// World Management\r\nexport {\r\n    b2CreateWorld,\r\n    b2CreateWorldArray,\r\n    b2DestroyWorld,\r\n    b2World_IsValid,\r\n    b2World_Step,\r\n    b2World_Draw,\r\n    b2World_GetBodyEvents,\r\n    b2World_GetSensorEvents,\r\n    b2World_GetContactEvents,\r\n    b2World_SetGravity,\r\n    b2World_GetGravity,\r\n    b2World_GetProfile,\r\n    b2World_GetCounters,\r\n    b2World_OverlapAABB,\r\n    b2World_OverlapCircle,\r\n    b2World_OverlapCapsule,\r\n    b2World_OverlapPolygon,\r\n    b2World_CastRay,\r\n    b2World_CastRayClosest,\r\n    b2World_CastCircle,\r\n    b2World_CastCapsule,\r\n    b2World_CastPolygon,\r\n    b2World_EnableSleeping,\r\n    b2World_EnableContinuous,\r\n    b2World_SetRestitutionThreshold,\r\n    b2World_SetHitEventThreshold,\r\n    b2World_SetCustomFilterCallback,\r\n    b2World_SetPreSolveCallback,\r\n    b2World_Explode,\r\n    b2World_SetContactTuning,\r\n    b2World_EnableWarmStarting,\r\n    b2World_DumpMemoryStats\r\n} from './include/world_h.js';\r\n\r\n// Body Management\r\nexport {\r\n    b2Body_IsValid\r\n} from './include/world_h.js';\r\n\r\nexport {\r\n    b2CreateBody,\r\n    b2DestroyBody,\r\n    b2Body_GetType,\r\n    b2Body_SetType,\r\n    b2Body_GetPosition,\r\n    b2Body_GetRotation,\r\n    b2Body_GetTransform,\r\n    b2Body_SetTransform,\r\n    b2Body_ApplyForce,\r\n    b2Body_ApplyTorque,\r\n    b2Body_ApplyLinearImpulse,\r\n    b2Body_ApplyAngularImpulse,\r\n    b2Body_SetUserData,\r\n    b2Body_GetUserData,\r\n    b2Body_GetLocalPoint,\r\n    b2Body_GetWorldPoint,\r\n    b2Body_GetLocalVector,\r\n    b2Body_GetWorldVector,\r\n    b2Body_GetLinearVelocity,\r\n    b2Body_GetAngularVelocity,\r\n    b2Body_SetLinearVelocity,\r\n    b2Body_SetAngularVelocity,\r\n    b2Body_ApplyForceToCenter,\r\n    b2Body_ApplyLinearImpulseToCenter,\r\n    b2Body_GetMass,\r\n    b2Body_GetRotationalInertia,\r\n    b2Body_GetLocalCenterOfMass,\r\n    b2Body_GetWorldCenterOfMass,\r\n    b2Body_SetMassData,\r\n    b2Body_GetMassData,\r\n    b2Body_ApplyMassFromShapes,\r\n    b2Body_SetLinearDamping,\r\n    b2Body_GetLinearDamping,\r\n    b2Body_SetAngularDamping,\r\n    b2Body_GetAngularDamping,\r\n    b2Body_SetGravityScale,\r\n    b2Body_GetGravityScale,\r\n    b2Body_IsAwake,\r\n    b2Body_SetAwake,\r\n    b2Body_EnableSleep,\r\n    b2Body_IsSleepEnabled,\r\n    b2Body_SetSleepThreshold,\r\n    b2Body_GetSleepThreshold,\r\n    b2Body_IsEnabled,\r\n    b2Body_Disable,\r\n    b2Body_Enable,\r\n    b2Body_SetFixedRotation,\r\n    b2Body_IsFixedRotation,\r\n    b2Body_SetBullet,\r\n    b2Body_IsBullet,\r\n    b2Body_EnableHitEvents,\r\n    b2Body_GetShapeCount,\r\n    b2Body_GetShapes,\r\n    b2Body_GetJointCount,\r\n    b2Body_GetJoints,\r\n    b2Body_GetContactCapacity,\r\n    b2Body_GetContactData,\r\n    b2Body_ComputeAABB\r\n} from './include/body_h.js';\r\n\r\n// Shape Management\r\nexport {\r\n    b2Shape_IsValid\r\n} from './include/world_h.js';\r\n\r\nexport {\r\n    b2CreateCircleShape,\r\n    b2CreateSegmentShape,\r\n    b2CreateCapsuleShape,\r\n    b2CreatePolygonShape,\r\n    b2DestroyShape,\r\n    b2Shape_GetType,\r\n    b2Shape_TestPoint,\r\n    b2Shape_RayCast,\r\n    b2Shape_GetBody,\r\n    b2Shape_IsSensor,\r\n    b2Shape_SetUserData,\r\n    b2Shape_GetUserData,\r\n    b2Shape_SetDensity,\r\n    b2Shape_GetDensity,\r\n    b2Shape_SetFriction,\r\n    b2Shape_GetFriction,\r\n    b2Shape_SetRestitution,\r\n    b2Shape_GetRestitution,\r\n    b2Shape_GetFilter,\r\n    b2Shape_SetFilter,\r\n    b2Shape_EnableSensorEvents,\r\n    b2Shape_AreSensorEventsEnabled,\r\n    b2Shape_EnableContactEvents,\r\n    b2Shape_AreContactEventsEnabled,\r\n    b2Shape_EnablePreSolveEvents,\r\n    b2Shape_ArePreSolveEventsEnabled,\r\n    b2Shape_EnableHitEvents,\r\n    b2Shape_AreHitEventsEnabled,\r\n    b2Shape_GetCircle,\r\n    b2Shape_GetSegment,\r\n    b2Shape_GetChainSegment,\r\n    b2Shape_GetCapsule,\r\n    b2Shape_GetPolygon,\r\n    b2Shape_SetCircle,\r\n    b2Shape_SetCapsule,\r\n    b2Shape_SetSegment,\r\n    b2Shape_SetPolygon,\r\n    b2Shape_GetParentChain,\r\n    b2Shape_GetContactCapacity,\r\n    b2Shape_GetContactData,\r\n    b2Shape_GetAABB,\r\n    b2Shape_GetClosestPoint\r\n} from './include/shape_h.js';\r\n\r\n// Joint Management\r\nexport {\r\n    b2Joint_IsValid\r\n} from './include/world_h.js';\r\n\r\nexport {\r\n    b2CreateDistanceJoint,\r\n    b2CreateMotorJoint,\r\n    b2CreateMouseJoint,\r\n    b2CreatePrismaticJoint,\r\n    b2CreateRevoluteJoint,\r\n    b2CreateWeldJoint,\r\n    b2CreateWheelJoint,\r\n    b2DestroyJoint,\r\n    b2Joint_GetType,\r\n    b2Joint_GetBodyA,\r\n    b2Joint_GetBodyB,\r\n    b2Joint_GetLocalAnchorA,\r\n    b2Joint_GetLocalAnchorB,\r\n    b2Joint_SetCollideConnected,\r\n    b2Joint_GetCollideConnected,\r\n    b2Joint_SetUserData,\r\n    b2Joint_GetUserData,\r\n    b2Joint_WakeBodies,\r\n    b2Joint_GetConstraintForce,\r\n    b2Joint_GetConstraintTorque\r\n} from './include/joint_h.js';\r\n\r\nexport {\r\n    b2DistanceJoint_SetLength,\r\n    b2DistanceJoint_GetLength,\r\n    b2DistanceJoint_EnableSpring,\r\n    b2DistanceJoint_IsSpringEnabled,\r\n    b2DistanceJoint_SetSpringHertz,\r\n    b2DistanceJoint_SetSpringDampingRatio,\r\n    b2DistanceJoint_GetSpringHertz,\r\n    b2DistanceJoint_GetSpringDampingRatio,\r\n    b2DistanceJoint_EnableLimit,\r\n    b2DistanceJoint_IsLimitEnabled,\r\n    b2DistanceJoint_SetLengthRange,\r\n    b2DistanceJoint_GetMinLength,\r\n    b2DistanceJoint_GetMaxLength,\r\n    b2DistanceJoint_GetCurrentLength,\r\n    b2DistanceJoint_EnableMotor,\r\n    b2DistanceJoint_IsMotorEnabled,\r\n    b2DistanceJoint_SetMotorSpeed,\r\n    b2DistanceJoint_GetMotorSpeed,\r\n    b2DistanceJoint_SetMaxMotorForce,\r\n    b2DistanceJoint_GetMaxMotorForce,\r\n    b2DistanceJoint_GetMotorForce\r\n} from './include/distance_joint_h.js';\r\n\r\nexport {\r\n    b2MotorJoint_SetLinearOffset,\r\n    b2MotorJoint_GetLinearOffset,\r\n    b2MotorJoint_SetAngularOffset,\r\n    b2MotorJoint_GetAngularOffset,\r\n    b2MotorJoint_SetMaxForce,\r\n    b2MotorJoint_GetMaxForce,\r\n    b2MotorJoint_SetMaxTorque,\r\n    b2MotorJoint_GetMaxTorque,\r\n    b2MotorJoint_SetCorrectionFactor,\r\n    b2MotorJoint_GetCorrectionFactor\r\n} from './include/motor_joint_h.js';\r\n\r\nexport {\r\n    b2MouseJoint_SetTarget,\r\n    b2MouseJoint_GetTarget,\r\n    b2MouseJoint_SetSpringHertz,\r\n    b2MouseJoint_GetSpringHertz,\r\n    b2MouseJoint_SetSpringDampingRatio,\r\n    b2MouseJoint_GetSpringDampingRatio,\r\n    b2MouseJoint_SetMaxForce,\r\n    b2MouseJoint_GetMaxForce\r\n} from './include/mouse_joint_h.js';\r\n\r\nexport {\r\n    b2PrismaticJoint_EnableSpring,\r\n    b2PrismaticJoint_IsSpringEnabled,\r\n    b2PrismaticJoint_SetSpringHertz,\r\n    b2PrismaticJoint_GetSpringHertz,\r\n    b2PrismaticJoint_SetSpringDampingRatio,\r\n    b2PrismaticJoint_GetSpringDampingRatio,\r\n    b2PrismaticJoint_EnableLimit,\r\n    b2PrismaticJoint_IsLimitEnabled,\r\n    b2PrismaticJoint_GetLowerLimit,\r\n    b2PrismaticJoint_GetUpperLimit,\r\n    b2PrismaticJoint_SetLimits,\r\n    b2PrismaticJoint_EnableMotor,\r\n    b2PrismaticJoint_IsMotorEnabled,\r\n    b2PrismaticJoint_SetMotorSpeed,\r\n    b2PrismaticJoint_GetMotorSpeed,\r\n    b2PrismaticJoint_SetMaxMotorForce,\r\n    b2PrismaticJoint_GetMaxMotorForce,\r\n    b2PrismaticJoint_GetMotorForce\r\n} from './include/prismatic_joint_h.js';\r\n\r\nexport {\r\n    b2RevoluteJoint_EnableSpring,\r\n    b2RevoluteJoint_SetSpringHertz,\r\n    b2RevoluteJoint_GetSpringHertz,\r\n    b2RevoluteJoint_SetSpringDampingRatio,\r\n    b2RevoluteJoint_GetSpringDampingRatio,\r\n    b2RevoluteJoint_GetAngle,\r\n    b2RevoluteJoint_EnableLimit,\r\n    b2RevoluteJoint_IsLimitEnabled,\r\n    b2RevoluteJoint_GetLowerLimit,\r\n    b2RevoluteJoint_GetUpperLimit,\r\n    b2RevoluteJoint_SetLimits,\r\n    b2RevoluteJoint_EnableMotor,\r\n    b2RevoluteJoint_IsMotorEnabled,\r\n    b2RevoluteJoint_SetMotorSpeed,\r\n    b2RevoluteJoint_GetMotorSpeed,\r\n    b2RevoluteJoint_GetMotorTorque,\r\n    b2RevoluteJoint_SetMaxMotorTorque,\r\n    b2RevoluteJoint_GetMaxMotorTorque,\r\n    b2RevoluteJoint_IsSpringEnabled\r\n} from './include/revolute_joint_h.js';\r\n\r\nexport {\r\n    b2WeldJoint_SetLinearHertz,\r\n    b2WeldJoint_GetLinearHertz,\r\n    b2WeldJoint_SetLinearDampingRatio,\r\n    b2WeldJoint_GetLinearDampingRatio,\r\n    b2WeldJoint_SetAngularHertz,\r\n    b2WeldJoint_GetAngularHertz,\r\n    b2WeldJoint_SetAngularDampingRatio,\r\n    b2WeldJoint_GetAngularDampingRatio\r\n} from './include/weld_joint_h.js';\r\n\r\nexport {\r\n    b2WheelJoint_EnableSpring,\r\n    b2WheelJoint_IsSpringEnabled,\r\n    b2WheelJoint_SetSpringHertz,\r\n    b2WheelJoint_GetSpringHertz,\r\n    b2WheelJoint_SetSpringDampingRatio,\r\n    b2WheelJoint_GetSpringDampingRatio,\r\n    b2WheelJoint_EnableLimit,\r\n    b2WheelJoint_IsLimitEnabled,\r\n    b2WheelJoint_GetLowerLimit,\r\n    b2WheelJoint_GetUpperLimit,\r\n    b2WheelJoint_SetLimits,\r\n    b2WheelJoint_EnableMotor,\r\n    b2WheelJoint_IsMotorEnabled,\r\n    b2WheelJoint_SetMotorSpeed,\r\n    b2WheelJoint_GetMotorSpeed,\r\n    b2WheelJoint_SetMaxMotorTorque,\r\n    b2WheelJoint_GetMaxMotorTorque,\r\n    b2WheelJoint_GetMotorTorque\r\n} from './include/wheel_joint_h.js';\r\n\r\n// Collision Detection\r\nexport {\r\n    b2CollideCircles,\r\n    b2CollideCapsules,\r\n    b2CollidePolygons,\r\n    b2CollideCapsuleAndCircle,\r\n    b2CollidePolygonAndCircle,\r\n    b2CollideSegmentAndCapsule,\r\n    b2CollidePolygonAndCapsule,\r\n    b2CollideSegmentAndCircle,\r\n    b2CollideSegmentAndPolygon,\r\n    b2CollideChainSegmentAndCircle,\r\n    b2CollideChainSegmentAndCapsule,\r\n    b2CollideChainSegmentAndPolygon\r\n} from './include/manifold_h.js';\r\n\r\nexport {\r\n    b2RayCastCircle,\r\n    b2RayCastPolygon,\r\n    b2RayCastCapsule,\r\n    b2RayCastSegment,\r\n    b2ShapeCastCircle,\r\n    b2ShapeCastCapsule,\r\n    b2ShapeCastSegment,\r\n    b2ShapeCastPolygon,\r\n    b2IsValidRay\r\n} from './include/geometry_h.js';\r\n\r\nexport {\r\n    b2ShapeCast,\r\n    b2TimeOfImpact\r\n} from './include/distance_h.js';\r\n\r\n// Math & Utilities\r\nexport {\r\n    b2IsValid,\r\n    b2Vec2_IsValid,\r\n    b2Rot_IsValid,\r\n    b2AABB_IsValid,\r\n    b2Normalize,\r\n    b2NormalizeChecked,\r\n    b2GetLengthAndNormalize\r\n} from './include/math_functions_h.js';\r\n\r\nexport {\r\n    b2ComputeHull,\r\n    b2ValidateHull\r\n} from './include/hull_h.js';\r\n\r\nexport {\r\n    b2SegmentDistance,\r\n    b2ShapeDistance,\r\n    b2MakeProxy,\r\n    b2GetSweepTransform\r\n} from './include/distance_h.js';\r\n\r\nexport {\r\n    b2MakePolygon,\r\n    b2MakeOffsetPolygon,\r\n    b2MakeSquare,\r\n    b2MakeBox,\r\n    b2MakeRoundedBox,\r\n    b2MakeOffsetBox,\r\n    b2TransformPolygon,\r\n    b2ComputeCircleMass,\r\n    b2ComputeCapsuleMass,\r\n    b2ComputePolygonMass,\r\n    b2ComputeCircleAABB,\r\n    b2ComputeCapsuleAABB,\r\n    b2ComputePolygonAABB,\r\n    b2ComputeSegmentAABB,\r\n    b2PointInCircle,\r\n    b2PointInCapsule,\r\n    b2PointInPolygon\r\n} from './include/geometry_h.js';\r\n\r\n// Chain\r\nexport {\r\n    b2CreateChain,\r\n    b2Chain_SetFriction,\r\n    b2Chain_SetRestitution,\r\n    b2DestroyChain\r\n} from './include/shape_h.js';\r\n\r\nexport {\r\n    b2Chain_IsValid\r\n} from './include/world_h.js';\r\n\r\n// Dynamic Tree\r\nexport {\r\n    b2DynamicTree_Create,\r\n    b2DynamicTree_Destroy,\r\n    b2DynamicTree_CreateProxy,\r\n    b2DynamicTree_DestroyProxy,\r\n    b2DynamicTree_MoveProxy,\r\n    b2DynamicTree_EnlargeProxy,\r\n    b2DynamicTree_Query,\r\n    b2DynamicTree_RayCast,\r\n    b2DynamicTree_ShapeCast,\r\n    b2DynamicTree_Validate,\r\n    b2DynamicTree_GetHeight,\r\n    b2DynamicTree_GetMaxBalance,\r\n    b2DynamicTree_GetAreaRatio,\r\n    b2DynamicTree_RebuildBottomUp,\r\n    b2DynamicTree_GetProxyCount,\r\n    b2DynamicTree_Rebuild,\r\n    b2DynamicTree_ShiftOrigin,\r\n    b2DynamicTree_GetByteCount\r\n} from './include/dynamic_tree_h.js';\r\n\r\n// Default Definitions\r\nexport {\r\n    b2DefaultWorldDef,\r\n    b2DefaultBodyDef,\r\n    b2DefaultFilter,\r\n    b2DefaultQueryFilter,\r\n    b2DefaultShapeDef,\r\n    b2DefaultChainDef\r\n} from './include/types_h.js';\r\n\r\nexport {\r\n    b2DefaultDistanceJointDef,\r\n    b2DefaultMotorJointDef,\r\n    b2DefaultMouseJointDef,\r\n    b2DefaultPrismaticJointDef,\r\n    b2DefaultRevoluteJointDef,\r\n    b2DefaultWeldJointDef,\r\n    b2DefaultWheelJointDef\r\n} from './include/joint_h.js';\r\n\r\n// Phaser Additions v2\r\n\r\nexport const STATIC = 0;\r\nexport const KINEMATIC = 1;\r\nexport const DYNAMIC = 2;\r\n\r\nexport {\r\n    GetWorldScale,\r\n    SetWorldScale,\r\n    mpx,\r\n    pxm,\r\n    pxmVec2,\r\n    RotFromRad,\r\n    BodyToSprite,\r\n    SpriteToBox,\r\n    SpriteToCircle,\r\n    AddSpriteToWorld,\r\n    RemoveSpriteFromWorld,\r\n    ClearWorldSprites,\r\n    GetBodyFromSprite,\r\n    UpdateWorldSprites,\r\n    CreateBoxPolygon,\r\n    CreateCapsule,\r\n    CreateChain,\r\n    CreateCircle,\r\n    CreateDistanceJoint,\r\n    CreateMotorJoint,\r\n    CreateMouseJoint,\r\n    CreateNGonPolygon,\r\n    CreatePolygon,\r\n    CreatePolygonFromEarcut,\r\n    CreatePolygonFromVertices,\r\n    CreatePhysicsEditorShape,\r\n    CreatePrismaticJoint,\r\n    CreateRevoluteJoint,\r\n    CreateWeldJoint,\r\n    CreateWheelJoint,\r\n    CreateWorld,\r\n    WorldStep\r\n} from './physics.js';\r\n\r\n//  Debug Draw (remove from prod bundle)\r\nexport {\r\n    AttachImage,\r\n    ConvertScreenToWorld,\r\n    ConvertWorldToScreen,\r\n    CreateDebugDraw,\r\n    RAF\r\n} from './debug_draw.js';\r\n\r\nexport {\r\n    Ragdoll,\r\n    Skeletons\r\n} from './ragdoll.js';\r\n\r\nexport {\r\n    ActiveBall,\r\n    Gun,\r\n    Spinner\r\n} from './fun_stuff.js';\r\n\r\n\r\n/**\r\n * \r\n * TYPES\r\n * \r\n */\r\n\r\n// World Management\r\nexport {\r\n    b2WorldDef,\r\n    b2BodyEvents,\r\n    b2SensorEvents,\r\n    b2ContactEvents\r\n} from './include/types_h.js';\r\n\r\nexport {\r\n    b2WorldId\r\n} from './include/id_h.js';\r\n\r\n// Geometry & Math\r\nexport {\r\n    b2AABB,\r\n    b2Vec2,\r\n    b2Rot,\r\n    b2Transform\r\n} from './include/math_functions_h.js';\r\n\r\nexport {\r\n    b2Hull,\r\n    b2Sweep,\r\n    b2Manifold,\r\n    b2Simplex\r\n} from './include/collision_h.js';\r\n\r\n// Shapes\r\nexport {\r\n    b2Circle,\r\n    b2Capsule,\r\n    b2Polygon,\r\n    b2Segment,\r\n    b2ChainSegment\r\n} from './include/collision_h.js';\r\n\r\nexport {\r\n    b2ShapeId\r\n} from './include/id_h.js';\r\n\r\nexport {\r\n    b2ShapeDef,\r\n    b2ShapeType,\r\n    b2Filter\r\n} from './include/types_h.js';\r\n\r\n// Bodies\r\nexport {\r\n    b2BodyDef,\r\n    b2BodyType\r\n} from './include/types_h.js';\r\n\r\nexport {\r\n    b2MassData\r\n} from './include/collision_h.js';\r\n\r\nexport {\r\n    b2BodyId\r\n} from './include/id_h.js';\r\n\r\nexport {\r\n    b2JointId,\r\n    b2ChainId\r\n} from './include/id_h.js';\r\n\r\n// Joints\r\nexport {\r\n    b2JointType,\r\n    b2DistanceJointDef,\r\n    b2MotorJointDef,\r\n    b2MouseJointDef,\r\n    b2PrismaticJointDef,\r\n    b2RevoluteJointDef,\r\n    b2WeldJointDef,\r\n    b2WheelJointDef\r\n} from './include/types_h.js';\r\n\r\n// Chains\r\nexport {\r\n    b2ChainDef\r\n} from './include/types_h.js';\r\n\r\n// Collision Detection\r\nexport {\r\n    b2QueryFilter,\r\n    b2RayResult,\r\n    b2ContactData\r\n} from './include/types_h.js';\r\n\r\nexport {\r\n    b2CastOutput,\r\n    b2RayCastInput,\r\n    b2SegmentDistanceResult,\r\n    b2DistanceCache,\r\n    b2DistanceInput,\r\n    b2DistanceOutput,\r\n    b2DistanceProxy,\r\n    b2ShapeCastInput,\r\n    b2ShapeCastPairInput,\r\n    b2TOIInput,\r\n    b2TOIOutput\r\n} from './include/collision_h.js';\r\n\r\n// Broad-phase\r\nexport {\r\n    b2DynamicTree\r\n} from './include/dynamic_tree_h.js';\r\n\r\n// Callbacks\r\nexport {\r\n    b2DebugDraw\r\n} from './include/types_h.js';\r\n\r\n// Enumerations\r\nexport {\r\n    b2HexColor\r\n} from './include/types_h.js';\r\n"],
  "mappings": "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",
  "names": ["c", "p", "q", "xf", "q1", "q2", "b2_lengthUnitsPerMeter", "b2_lengthUnitsPerMeter", "c", "p1", "p2", "b2_lengthUnitsPerMeter", "xf", "q", "p", "localPointB", "pointA", "pointB", "normal", "s", "p1", "p2", "c", "p1", "p2", "p", "p3", "xf", "p", "p1", "p2", "sv", "c", "rayPoint", "rayNormal", "q", "output", "shape", "xf", "rayPoint", "rayNormal", "rayNormal", "rayPoint", "stack", "p1", "p2", "c", "child1", "child2", "contactId", "c", "p1", "p2", "xf1", "q", "b2_lengthUnitsPerMeter", "translation", "p", "stack", "set", "aabb", "shapeId", "p1", "p2", "p", "p0", "p1", "p2", "ib1", "ib2", "b1", "b2", "pAB", "p", "centerOffsetA", "centerOffsetB", "p1", "p2", "xf", "p", "b2GetBit", "b2GetBit", "c", "xf", "p", "url", "key", "p0", "xf", "ctx", "p1", "p2"]
}
